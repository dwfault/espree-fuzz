[]
[]
null
CVE-2017-5121.js
IIFE-es6-default-parameters.js
IIFE-function-name-captured.js
JSON-parse-should-cache-array-lengths.js
Number-isNaN-basics.js
Object_static_methods_Object.getOwnPropertyDescriptors-proxy.js
Object_static_methods_Object.getOwnPropertyDescriptors.js
OverrideHasInstance-should-not-branch-across-register-allocations.js
SharedArrayBuffer-opt.js
SharedArrayBuffer.js
accessors-get-set-prefix.js
activation-sink-default-value-tdz-error.js
activation-sink-default-value.js
activation-sink-osrexit-default-value-tdz-error.js
activation-sink-osrexit-default-value.js
activation-sink-osrexit.js
activation-sink.js
activation-test-loop.js
add-constant-overflow-recovery.js
add-inferred-type-table-to-existing-structure.js
add-int52-constant-overflow-recovery.js
add-int52-large-constant-overflow-recovery.js
add-overflow-recovery.js
add-overflows-after-not-equal.js
add-small-constant-overflow-recovery.js
ai-consistency-filter-cells.js
ai-needs-to-model-spreads-effects.js
allocation-sinking-defs-may-have-replacements.js
allocation-sinking-puthint-control-flow.js
allow-math-ic-b3-code-duplication.js
always-enter-dictionary-indexing-mode-with-getter.js
any-int-as-double-add.js
apply-second-argument-must-be-array-like.js
argument-count-bytecode.js
argument-intrinsic-basic.js
argument-intrinsic-inlining-use-caller-arg.js
argument-intrinsic-inlining-with-result-escape.js
argument-intrinsic-inlining-with-vararg-with-enough-arguments.js
argument-intrinsic-inlining-with-vararg.js
argument-intrinsic-nested-inlining.js
argument-intrinsic-not-convert-to-get-argument.js
argument-intrinsic-with-stack-write.js
arguments-bizarre-behavior.js
arguments-bizarre-behaviour-disable-enumerability.js
arguments-callee-uninitialized.js
arguments-captured.js
arguments-copy-register-array-backing-store.js
arguments-custom-properties-gc.js
arguments-define-property.js
arguments-elimination-candidate-listings-should-respect-pseudo-terminals.js
arguments-elimination-force-exit.js
arguments-elimination-throw.js
arguments-elimination-varargs-too-many-args-arg-count.js
arguments-exit-fixed.js
arguments-exit-strict-mode-fixed.js
arguments-exit-strict-mode.js
arguments-exit.js
arguments-inlined-exit-strict-mode-fixed.js
arguments-inlined-exit-strict-mode.js
arguments-inlined-exit.js
arguments-interference-cfg.js
arguments-interference.js
arguments-iterator.js
arguments-length-always-dont-enum.js
arguments-non-configurable.js
arith-abs-integer-range-optimization.js
arith-abs-on-various-types.js
arith-abs-overflow.js
arith-abs-to-arith-negate-range-optimizaton.js
arith-abs-with-bitwise-or-zero.js
arith-acos-on-various-types.js
arith-acosh-on-various-types.js
arith-add-on-double-array-with-holes.js
arith-add-with-constant-overflow.js
arith-add-with-constants.js
arith-asin-on-various-types.js
arith-asinh-on-various-types.js
arith-atan-on-various-types.js
arith-atanh-on-various-types.js
arith-cbrt-on-various-types.js
arith-ceil-on-various-types.js
arith-clz32-effects.js
arith-clz32-on-various-types.js
arith-cos-on-various-types.js
arith-cosh-on-various-types.js
arith-expm1-on-various-types.js
arith-floor-on-various-types.js
arith-fround-on-various-types.js
arith-log-on-various-types.js
arith-log10-on-various-types.js
arith-log2-on-various-types.js
arith-modulo-node-behaviors.js
arith-modulo-twice.js
arith-mul-with-constants.js
arith-negate-on-various-types.js
arith-nodes-abstract-interpreter-untypeduse.js
arith-profile-for-negate-can-see-non-number-due-to-dfg-osr-exit-profiling.js
arith-round-on-various-types.js
arith-sin-on-various-types.js
arith-sinh-on-various-types.js
arith-sqrt-on-various-types.js
arith-sub-on-double-array-with-holes.js
arith-tan-on-various-types.js
arith-tanh-on-various-types.js
arith-trunc-on-various-types.js
arity-check-ftl-throw-more-args.js
arity-check-ftl-throw.js
arity-fixup-inlining-dont-generate-invalid-use.js
arity-fixup-should-not-touch-stack-area-below-sp.js
arity-mismatch-arguments-length.js
arity-mismatch-get-argument.js
arity-mismatch-inlining-extra-slots.js
arity-mismatch-inlining.js
arity-mismatch-rest.js
array-buffer-byte-length.js
array-concat-on-frozen-object.js
array-concat-spread-object.js
array-concat-spread-proxy-exception-check.js
array-concat-spread-proxy.js
array-concat-with-slow-indexingtypes.js
array-constructor-no-result.js
array-copywithin.js
array-fill-put-by-val.js
array-filter-put-by-val-direct.js
array-find-does-not-lookup-twice.js
array-flatmap.js
array-flatten.js
array-from-abs-and-floor.js
array-from-put-by-val-direct.js
array-from-set-length.js
array-from-with-accessors.js
array-from-with-iterable.js
array-from-with-iterator.js
array-indexof-array-prototype-change.js
array-indexof-arraystorage.js
array-indexof-constant-folding.js
array-indexof-have-a-bad-time-getter.js
array-indexof-have-a-bad-time.js
array-indexof-hole-and-other.js
array-indexof-hole-with-prototype.js
array-indexof-hole.js
array-indexof-index.js
array-indexof-negative-index.js
array-indexof-non-int32-start-index.js
array-indexof-object-prototype-change.js
array-indexof-object.js
array-indexof-original-array.js
array-indexof-other.js
array-indexof-string.js
array-indexof-structure-change-convert.js
array-indexof-structure-change.js
array-indexof-symbol.js
array-indexof.js
array-iterators-next-error-messages.js
array-iterators-next-with-call.js
array-iterators-next.js
array-join-on-strings-need-overflow-checks.js
array-length-array-storage-plain-object.js
array-length-not-writable.js
array-length-plain-object.js
array-map-put-by-val-direct.js
array-message-passing.js
array-pop-array-storage.js
array-pop-contiguous.js
array-pop-double-hole.js
array-pop-double.js
array-pop-int32.js
array-prototype-concat-of-long-spliced-arrays.js
array-prototype-concat-of-long-spliced-arrays2.js
array-prototype-slow-put-having-a-bad-time-2.js
array-prototype-slow-put-having-a-bad-time.js
array-prototype-splice-making-typed-array.js
array-push-array-storage-beyond-int32.js
array-push-array-storage.js
array-push-contiguous.js
array-push-double-then-nan.js
array-push-double.js
array-push-multiple-array-storage-beyond-int32.js
array-push-multiple-contiguous.js
array-push-multiple-double-nan.js
array-push-multiple-double.js
array-push-multiple-int32.js
array-push-multiple-many-contiguous.js
array-push-multiple-many-double.js
array-push-multiple-many-int32.js
array-push-multiple-many-storage.js
array-push-multiple-storage-continuous.js
array-push-multiple-storage.js
array-push-with-force-exit.js
array-push.js
array-reverse-proxy.js
array-setLength-on-ArrayClass-with-large-length.js
array-setLength-on-ArrayClass-with-small-length.js
array-slice-intrinsic.js
array-slice-jettison-on-constructor-change.js
array-slice-on-frozen-object.js
array-slice-osr-exit-2.js
array-slice-osr-exit.js
array-sort-bad-comparator.js
array-species-config-array-constructor.js
array-species-functions.js
array-storage-array-unshift.js
array-storage-get-by-val.js
array-storage-length.js
array-symbol-species-lazy-watchpoints.js
array-to-locale-string.js
arrayify-array-storage-array.js
arrayify-array-storage-non-array.js
arrayify-array-storage-typed-array.js
arrayify-array-storage.js
arrayify-fires-watchpoint.js
arrayify-int32-typed-array.js
arrayify-slow-put-array-storage-pass-array-storage.js
arrayify-slow-put-array-storage.js
arrayify-structure-bad-test.js
arrayify-to-structure-contradiction.js
arrayify.js
arrow-function-needs-its-own-structure.js
arrow-function-token-is-not-keyword.js
arrow-functions-as-default-parameter-values.js
arrowfunction-activation-sink-osrexit-default-value-tdz-error.js
arrowfunction-activation-sink-osrexit-default-value.js
arrowfunction-activation-sink-osrexit.js
arrowfunction-activation-sink.js
arrowfunction-bound.js
arrowfunction-call.js
arrowfunction-constructor.js
arrowfunction-lexical-bind-arguments-non-strict-1.js
arrowfunction-lexical-bind-arguments-non-strict-2.js
arrowfunction-lexical-bind-arguments-strict.js
arrowfunction-lexical-bind-newtarget.js
arrowfunction-lexical-bind-supercall-1.js
arrowfunction-lexical-bind-supercall-2.js
arrowfunction-lexical-bind-supercall-3.js
arrowfunction-lexical-bind-supercall-4.js
arrowfunction-lexical-bind-superproperty.js
arrowfunction-lexical-bind-this-1.js
arrowfunction-lexical-bind-this-2.js
arrowfunction-lexical-bind-this-3.js
arrowfunction-lexical-bind-this-4.js
arrowfunction-lexical-bind-this-5.js
arrowfunction-lexical-bind-this-6.js
arrowfunction-lexical-bind-this-7.js
arrowfunction-lexical-bind-this-8.js
arrowfunction-lexical-this-activation-sink-osrexit.js
arrowfunction-lexical-this-activation-sink.js
arrowfunction-lexical-this-sinking-no-double-allocate.js
arrowfunction-lexical-this-sinking-osrexit.js
arrowfunction-lexical-this-sinking-put.js
arrowfunction-name.js
arrowfunction-others.js
arrowfunction-prototype.js
arrowfunction-run-10-1.js
arrowfunction-run-10-2.js
arrowfunction-run-10000-1.js
arrowfunction-run-10000-2.js
arrowfunction-sinking-no-double-allocate.js
arrowfunction-sinking-osrexit.js
arrowfunction-sinking-put.js
arrowfunction-tdz-1.js
arrowfunction-tdz-2.js
arrowfunction-tdz-3.js
arrowfunction-tdz-4.js
arrowfunction-tostring.js
arrowfunction-typeof.js
assign-argument-in-inlined-call.js
assign-captured-argument-in-inlined-call.js
assignment-in-function-call-bracket-node.js
async-arrow-function-in-class-heritage.js
async-arrow-functions-lexical-arguments-binding.js
async-arrow-functions-lexical-binding-in-class.js
async-arrow-functions-lexical-new.target-binding.js
async-arrow-functions-lexical-super-binding.js
async-arrow-functions-lexical-this-binding.js
async-await-basic.js
async-await-long-loop.js
async-await-module-reserved-word.js
async-await-mozilla.js
async-await-reserved-word.js
async-await-syntax.js
async-await-throw-loop.js
async-function-create-nobaseline.js
async-function-create-optimized.js
async-function-declaration-sinking-no-double-allocate.js
async-function-declaration-sinking-osrexit.js
async-function-declaration-sinking-put.js
async-function-expression-sinking-no-double-allocate.js
async-function-expression-sinking-osrexit.js
async-function-expression-sinking-put.js
async-generator-assertion.js
async-iteration-async-from-sync.js
async-iteration-basic.js
async-iteration-evaluation.js
async-iteration-for-await-of-syntax.js
async-iteration-for-await-of.js
async-iteration-syntax.js
async-iteration-yield-promise.js
async-iteration-yield-star-interface.js
async-iteration-yield-star.js
atomics-add-uint32.js
atomics-known-int-use.js
atomics-neg-zero.js
atomics-store-return.js
b3-delete-orphans-should-neutralize-upsilons-with-dead-phis.js
basic-eden-gc-test.js
basic-weakmap.js
basic-weakset.js
big-int-as-key.js
big-int-constructor-gc.js
big-int-constructor-oom.js
big-int-constructor-properties.js
big-int-constructor-prototype-prop-descriptor.js
big-int-constructor-prototype.js
big-int-constructor.js
big-int-function-apply.js
big-int-length.js
big-int-literal-line-terminator.js
big-int-literals.js
big-int-operations-error.js
big-int-prop-descriptor.js
big-int-proto-constructor.js
big-int-proto-name.js
big-int-prototype-properties.js
big-int-prototype-proto.js
big-int-prototype-symbol-to-string-tag.js
big-int-prototype-to-string-apply.js
big-int-prototype-to-string-cast-overflow.js
big-int-prototype-to-string-exception.js
big-int-prototype-to-string-wrong-values.js
big-int-prototype-value-of.js
big-int-to-object.js
big-int-to-string.js
big-int-type-of.js
big-int-white-space-trailing-leading.js
big-match.js
big-split-captures.js
big-split.js
bit-op-value-to-int32-input-liveness.js
block-scoped-function-declarations.js
bound-function-does-not-have-caller-and-arguments.js
bound-function-lazy-name-generation.js
bound-function-tail-call-with-exception.js
bound-function-uses-prototype.js
bounds-check-not-eliminated-by-licm.js
branch-check-int32-on-boolean-to-number-untyped.js
branch-check-number-on-boolean-to-number-untyped.js
branch-may-exit-due-to-object-or-other-use-kind.js
broken-have-a-bad-time-with-arguments-for-gc-testing.js
bug-131764.js
bug-165091.js
bug-171786.js
builtin-function-is-construct-type-none.js
builtin-function-length.js
builtin-function-name.js
cached-prototype-setter.js
call-apply-builtin-functions-dont-use-iterators.js
call-apply-exponential-bytecode-size.js
call-forward-varargs-for-inlined-escaped-arguments.js
call-non-calleable-constructors-as-function.js
call-object-constructor.js
call-varargs-double-new-array-buffer.js
call-varargs-from-inlined-code-with-odd-number-of-arguments.js
call-varargs-from-inlined-code.js
call-varargs-length-effects.js
call-varargs-spread-new-array-buffer.js
call-varargs-spread-new-array-buffer2.js
call-varargs-spread.js
call-varargs-with-different-arguments-length-after-warmup.js
caller-and-arguments-properties-for-functions-that-dont-have-them.js
caller-native-code.js
capture-escape-and-throw.js
captured-arguments-variable.js
catch-clause-should-be-under-tdz1.js
catch-clause-should-be-under-tdz2.js
catch-clause-should-be-under-tdz3.js
catch-clause-should-be-under-tdz4.js
catch-clause-should-be-under-tdz5.js
catch-parameter-destructuring.js
catch-parameter-syntax.js
catch-set-argument-speculation-failure.js
catch-variables-under-tdz.js
check-dom-with-signature.js
check-string-ident.js
check-structure-ir-ensures-empty-does-not-flow-through.js
check-sub-class.js
chill-mod-chill-mod.js
class-derived-from-null.js
class-expression-generates-environment.js
class-expression-should-be-tdz-in-heritage.js
class-method-does-not-declare-variable-to-upper-scope.js
class-static-get-weird.js
class-subclassing-array.js
class-subclassing-function.js
class-subclassing-misc.js
class-subclassing-string.js
class-subclassing-typedarray.js
class-syntax-block-scoping.js
class-syntax-definition-semantics.js
class-syntax-derived-default-constructor.js
class-syntax-double-constructor.js
class-syntax-no-loop-tdz.js
class-syntax-no-tdz-in-catch.js
class-syntax-no-tdz-in-conditional.js
class-syntax-no-tdz-in-eval.js
class-syntax-no-tdz-in-loop-no-inline-super.js
class-syntax-no-tdz-in-loop.js
class-syntax-no-tdz.js
class-syntax-super-in-eval.js
class-syntax-tdz-in-catch.js
class-syntax-tdz-in-conditional.js
class-syntax-tdz-in-eval.js
class-syntax-tdz-in-loop.js
class-syntax-tdz-osr-entry-in-loop.js
class-syntax-tdz.js
clobberize-needs-to-model-spread-effects.js
cloned-arguments-elimination.js
cloned-arguments-get-by-val-double-array.js
cloned-arguments-modification.js
cloned-arguments-should-visit-callee-during-gc.js
closure-call-exit.js
closure-recursive-tail-call.js
code-cache-incorrect-caching.js
compare-clobber-untypeduse.js
compare-eq-incomplete-profile.js
compare-eq-object-or-other-to-object.js
compare-eq-object-to-object-or-other.js
compare-eq-on-null-and-undefined-non-peephole.js
compare-eq-on-null-and-undefined-optimized-in-constant-folding.js
compare-eq-on-null-and-undefined.js
compare-number-and-other.js
compare-semantic-origin-op-negate-method-of-getting-a-value-profile.js
compare-strict-eq-integer-to-misc.js
compare-strict-eq-on-various-types.js
completion-value.js
computed-accessor-parsing.js
computed-accessor.js
computed-function-names.js
concat-append-one-with-sparse-array.js
concat-with-holesMustForwardToPrototype.js
const-and-with-statement.js
const-exception-handling.js
const-loop-semantics.js
const-not-strict-mode.js
const-semantics.js
const-tdz.js
constant-closure-var-with-dynamic-invalidation.js
constant-fold-multi-get-by-offset-to-get-by-offset-on-prototype-and-sink-allocation.js
constant-folding-osr-exit.js
constant-folding-phase-insert-check-handle-varargs.js
constant-folding-should-fold-make-rope-with-empty-strings.js
construct-forward-varargs-for-inlined-escaped-arguments.js
construct-overwritten-variable.js
construct-spread-overwritten-variable-2.js
construct-spread-overwritten-variable.js
construct-varargs-inline-smaller-Foo.js
construct-varargs-inline.js
construct-varargs-no-inline.js
constructor-with-return.js
contiguous-array-unshift.js
create-subclass-structure-may-throw-exception-when-getting-prototype.js
create-subclass-structure-might-throw.js
create-this-with-callee-variants.js
cse-multi-get-by-offset-remove-checks.js
custom-get-set-inline-caching-one-level-up-proto-chain.js
custom-iterators.js
custom-prototype-may-be-same-to-original-one.js
dataview-construct.js
dataview-prototype-accessors.js
dataview-typedarray-toindex.js
date-relaxed.js
date-symbol-toprimitive.js
dead-access-to-captured-variable-preceded-by-a-live-store-in-function-with-multiple-basic-blocks.js
dead-access-to-captured-variable-preceded-by-a-live-store.js
dead-fiat-double-to-int52-then-exit-not-int52.js
dead-fiat-double-to-int52.js
dead-fiat-int32-to-int52.js
dead-fiat-value-to-int52-double-path.js
dead-fiat-value-to-int52-then-exit-not-double.js
dead-fiat-value-to-int52-then-exit-not-int52.js
dead-fiat-value-to-int52.js
dead-get-closure-var.js
dead-int32-to-double.js
dead-osr-entry-value.js
dead-speculating-argument-use.js
dead-uint32-to-number.js
dead-value-with-mov-hint-in-another-block.js
deep-StructureStubClearingWatchpoint-destructor-recursion.js
deeply-nested-finallys.js
default-value-parsing-should-propagate-error.js
delete-by-id.js
delete-by-val-ftl.js
delete-by-val.js
delete-to-object-exception.js
destructuring-assignment-accepts-iterables.js
destructuring-assignment-require-object-coercible.js
destructuring-assignment-syntax.js
destructuring-rest-element.js
dfg-call-class-constructor.js
dfg-create-arguments-inline-alloc.js
dfg-del-by-id.js
dfg-exception-try-catch-in-constructor-with-inlined-throw.js
dfg-get-by-id-should-not-assert-non-null-prediction.js
dfg-internal-function-call.js
dfg-internal-function-construct.js
dfg-node-convert-to-constant-must-clear-varargs-flags.js
dfg-object-proto-accessor.js
dfg-object-proto-getter.js
dfg-object-prototype-of.js
dfg-put-accessors-by-id-class.js
dfg-put-accessors-by-id.js
dfg-put-by-val-direct-with-edge-numbers.js
dfg-put-getter-by-id-class.js
dfg-put-getter-by-id.js
dfg-put-getter-by-val-class.js
dfg-put-getter-by-val.js
dfg-put-setter-by-id-class.js
dfg-put-setter-by-id.js
dfg-put-setter-by-val-class.js
dfg-put-setter-by-val.js
dfg-rare-data.js
dfg-reflect-get-prototype-of.js
dfg-ssa-swap.js
dfg-tail-calls.js
dfg-to-primitive-pass-symbol.js
dfg-try-catch-wrong-value-recovery-on-ic-miss.js
direct-arguments-in-bounds-to-out-of-bounds.js
direct-arguments-osr-entry.js
direct-arguments-out-of-bounds-watchpoint.js
direct-arguments-override-length-then-access-normal-length.js
direct-eval-in-object-literal-methods.js
direct-tail-call-arity-mismatch-count-args.js
disable-caching-when-lazy-materializing-error-property-on-put.js
disable-function-dot-arguments.js
disable-gigacage-arrays.js
disable-gigacage-strings.js
disable-gigacage-typed-arrays.js
do-eval-virtual-call-correctly.js
dom-jit-with-poly-proto.js
domjit-exception-ic.js
domjit-exception.js
domjit-getter-complex-with-incorrect-object.js
domjit-getter-complex.js
domjit-getter-poly.js
domjit-getter-proto.js
domjit-getter-super-poly.js
domjit-getter-try-catch-getter-as-get-by-id-register-restoration.js
domjit-getter-type-check.js
domjit-getter.js
dont-crash-in-cfg-simplification.js
dont-crash-on-bad-invalidation-point.js
dont-crash-when-hoist-check-structure-on-tdz.js
dont-dead-lock-put-by-val-as-put-by-id.js
dont-reserve-huge-capacity-lexer.js
dont-run-cleanup-after-licm.js
dont-strength-reduce-valuerep-of-doublerep.js
dont-unwind-past-vm-entry-frame.js
dont-validate-stack-offset-in-b3-because-it-might-be-guarded-by-control-flow.js
double-array-to-array-storage.js
double-array-unshift.js
double-as-int32.js
double-compare-to-float.js
double-rep-real-number-use-on-nan.js
double-rep-with-non-cell.js
double-rep-with-null.js
double-rep-with-undefined.js
double-to-float.js
duplicate-computed-accessors.js
each-block-at-top-of-polymorphic-call-inlining-should-be-exitOK.js
eden-gc-with-retired-blocks.js
element-property-get-should-not-handled-with-get-by-id.js
elidable-new-object-roflcopter-then-exit.js
elide-new-object-dag-then-exit.js
empty-function.js
empty_eos_regex_split.js
encode-decode-ascii.js
encode-decode-unicode.js
encode-decode-uri-component-surrogates.js
encode-decode-uri-surrogates.js
encode-decode-zero.js
ensure-proper-strict-mode-parsing.js
equality-type-checking.js
equals-masquerader.js
error-description-on-symbols-should-not-crash.js
error-message-for-function-base-not-found.js
error-messages-for-in-operator-should-not-crash.js
error-stack-trace-limit.js
errors-with-simple-names-or-messages-should-not-crash-toString.js
es6-default-parameters.js
es6-for-of-loop-exception.js
escape-object-in-diamond-then-exit.js
escape-unescape-surrogates.js
eval-and-super.js
eval-cached.js
eval-func-decl-block-scoping-reassign.js
eval-func-decl-block-with-remove.js
eval-func-decl-block-with-var-and-remove.js
eval-func-decl-block-with-var-sinthesize.js
eval-func-decl-in-block-scope-and-bind-to-top-eval-scope.js
eval-func-decl-in-eval-within-block-with-let.js
eval-func-decl-in-eval-within-with-scope.js
eval-func-decl-in-frozen-global.js
eval-func-decl-in-global-of-eval.js
eval-func-decl-in-global.js
eval-func-decl-in-if.js
eval-func-decl-with-let-const-class.js
eval-func-decl-within-eval-with-reassign-to-var.js
eval-func-decl-within-eval-without-reassign-to-let.js
eval-in-arrow-function.js
eval-script-contains-null-character.js
eval-that-is-not-eval.js
exception-dfg-inlined-frame-not-strict-equal.js
exception-dfg-not-strict-equal.js
exception-dfg-operation-read-value.js
exception-dfg-throw-from-catch-block.js
exception-effect-strcat.js
exception-in-strcat-string-overflow.js
exception-in-strcat.js
exception-in-to-property-key-should-be-handled-early-in-object-methods.js
exception-in-to-property-key-should-be-handled-early.js
exit-after-int32-to-double.js
exit-after-int52-to-double.js
exit-after-int52-to-value.js
exit-after-llvm-folds-large-int-constant.js
exit-during-inlined-arity-fixup-recover-proper-frame.js
exit-from-ftl-when-caller-passed-extra-args-then-use-function-dot-arguments.js
exit-from-ftl-with-arity-check-fail.js
exit-from-getter.js
exit-from-setter.js
exit-then-eval.js
fiat-double-to-int52-then-exit-not-int52.js
fiat-double-to-int52-then-fail-to-fold.js
fiat-double-to-int52-then-fold.js
fiat-double-to-int52.js
fiat-int32-to-int52.js
fiat-value-to-int52-double-path.js
fiat-value-to-int52-then-exit-not-double.js
fiat-value-to-int52-then-exit-not-int52.js
fiat-value-to-int52-then-fail-to-fold.js
fiat-value-to-int52-then-fold.js
fiat-value-to-int52.js
finally-for-in.js
flatten-oversize-dictionary-object.js
flattening-prototype-remove-butterfly.js
float32-array-nan-inlined.js
float32-array-nan.js
float32-array-out-of-bounds.js
float32-repeat-out-of-bounds.js
float32array-out-of-bounds.js
float64-array-nan-inlined.js
float64-array-nan.js
floating-point-div-to-mul.js
flush-after-force-exit-in-bytecodeparser-needs-to-update-argument-positions.js
fold-based-on-int32-proof-mul-branch.js
fold-based-on-int32-proof-mul.js
fold-based-on-int32-proof-or-zero.js
fold-based-on-int32-proof.js
fold-load-varargs-arity-check-fail-barely.js
fold-load-varargs-arity-check-fail.js
fold-multi-get-by-offset-to-get-by-offset-with-watchpoint.js
fold-multi-get-by-offset-to-get-by-offset-without-folding-the-structure-check-new.js
fold-multi-get-by-offset-to-get-by-offset-without-folding-the-structure-check.js
fold-multi-get-by-offset-to-get-by-offset.js
fold-multi-put-by-offset-to-put-by-offset-without-folding-the-structure-check.js
fold-multi-put-by-offset-to-put-by-offset.js
fold-profiled-call-to-call.js
fold-to-double-constant-then-exit.js
fold-to-int52-constant-then-exit.js
fold-to-primitive-in-cfa.js
fold-to-primitive-to-identity-in-cfa.js
fold-typed-array-properties.js
for-in-array-mode.js
for-in-base-reassigned-later-and-change-structure.js
for-in-base-reassigned-later.js
for-in-base-reassigned.js
for-in-capture-string-loop-var.js
for-in-delete-during-iteration.js
for-in-invalidate-context-weird-assignments.js
for-in-invalidation-for-any-write.js
for-in-modify-int-loop-var.js
for-in-modify-string-loop-var.js
for-in-of-const.js
for-in-postfix-ignored-index.js
for-in-postfix-index.js
for-in-prefix-index.js
for-in-prototype-with-indexed-properties-should-prevent-caching.js
for-in-prototype.js
for-in-proxy-target-changed-structure.js
for-in-proxy.js
for-in-shadow-prototype-property.js
for-in-side-effects.js
for-in-string.js
for-in-tests.js
for-in-typed-array.js
for-let-comma.js
force-exit-then-eval-dfg.js
force-exit-then-eval.js
forward-varargs-double-new-array-buffer.js
forward-varargs-for-inlined-escaped-arguments.js
freeze-and-seal-should-prevent-extensions.js
freeze-setter.js
freeze_leek.js
ftl-arithcos.js
ftl-arithsin.js
ftl-arithsqrt.js
ftl-arithtan.js
ftl-bit-xor-right-result-interference.js
ftl-call-bad-callee-exception-interesting-live-state.js
ftl-call-exception-interesting-live-state.js
ftl-call-exception-no-catch.js
ftl-call-exception.js
ftl-call-varargs-bad-args-exception-interesting-live-state.js
ftl-call-varargs-bad-callee-exception-interesting-live-state.js
ftl-call-varargs-exception-interesting-live-state.js
ftl-call-varargs-exception-no-catch.js
ftl-call-varargs-exception.js
ftl-checkin-variable.js
ftl-checkin.js
ftl-force-osr-exit.js
ftl-function-dot-arguments-with-callee-saves.js
ftl-get-by-id-getter-exception-interesting-live-state.js
ftl-get-by-id-getter-exception-no-catch.js
ftl-get-by-id-getter-exception.js
ftl-get-by-id-slow-exception-interesting-live-state.js
ftl-get-by-id-slow-exception-no-catch.js
ftl-get-by-id-slow-exception.js
ftl-get-my-argument-by-val-inlined-and-not-inlined.js
ftl-get-my-argument-by-val-inlined.js
ftl-get-my-argument-by-val.js
ftl-getmyargumentslength-inline.js
ftl-getmyargumentslength.js
ftl-gettypedarrayoffset-simple.js
ftl-gettypedarrayoffset-wasteful.js
ftl-has-a-bad-time.js
ftl-in-overflow.js
ftl-library-exception.js
ftl-library-inline-gettimezoneoffset.js
ftl-library-inlining-exceptions-dataview.js
ftl-library-inlining-exceptions.js
ftl-library-inlining-loops.js
ftl-library-inlining-random.js
ftl-library-substring.js
ftl-negate-zero.js
ftl-new-negative-array-size.js
ftl-operation-exception-interesting-live-state.js
ftl-operation-exception-no-catch.js
ftl-operation-exception.js
ftl-put-by-id-setter-exception-interesting-live-state.js
ftl-put-by-id-setter-exception-no-catch.js
ftl-put-by-id-setter-exception.js
ftl-put-by-id-slow-exception-interesting-live-state.js
ftl-put-by-id-slow-exception-no-catch.js
ftl-put-by-id-slow-exception.js
ftl-putbyid.js
ftl-putbyiddirect.js
ftl-reallocatepropertystorage.js
ftl-regexp-exec.js
ftl-regexp-test.js
ftl-shr-exception.js
ftl-string-equality.js
ftl-string-ident-equality.js
ftl-string-strict-equality.js
ftl-sub-exception.js
ftl-switch-string-slow-duplicate-cases.js
ftl-tail-call-throw-exception-from-slow-path-recover-stack-values.js
ftl-tail-call.js
ftl-to-ftl-arity-fixup.js
ftl-try-catch-arith-sub-exception.js
ftl-try-catch-getter-ic-fail-to-call-operation-throw-error.js
ftl-try-catch-getter-throw-interesting-value-recovery.js
ftl-try-catch-getter-throw.js
ftl-try-catch-oom-error-lazy-slow-path.js
ftl-try-catch-patchpoint-with-volatile-registers.js
ftl-try-catch-setter-throw.js
ftl-try-catch-tail-call-inilned-caller.js
ftl-try-catch-varargs-call-throws.js
ftl-xor-exception.js
function-configurable-properties.js
function-constructor-reading-from-global-lexical-environment.js
function-constructor-semantics.js
function-expression-exit.js
function-name-scope.js
function-reentry-infer-on-self.js
function-sinking-no-double-allocate.js
function-sinking-osrexit.js
function-sinking-put.js
function-with-defaults-inlining.js
function-with-defaults-non-inlining.js
fuzz-bug-16399949.js
generational-opaque-roots.js
generator-and-super.js
generator-arguments-from-function.js
generator-arguments.js
generator-class-methods-syntax.js
generator-class-methods.js
generator-eval-this.js
generator-fib-ftl-and-array.js
generator-fib-ftl-and-object.js
generator-fib-ftl-and-string.js
generator-fib-ftl.js
generator-frame-empty.js
generator-function-constructor-is-subclassible.js
generator-function-constructor.js
generator-function-create-optimized.js
generator-function-declaration-sinking-no-double-allocate.js
generator-function-declaration-sinking-osrexit.js
generator-function-declaration-sinking-put.js
generator-function-expression-sinking-no-double-allocate.js
generator-function-expression-sinking-osrexit.js
generator-function-expression-sinking-put.js
generator-function-name.js
generator-is-not-constructible.js
generator-methods-with-non-generator.js
generator-methods.js
generator-reduced-save-point-put-to-scope.js
generator-relations.js
generator-return-before-first-call.js
generator-return.js
generator-syntax.js
generator-this.js
generator-throw-before-first-call.js
generator-throw.js
generator-transfer-register-beyond-mutiple-yields.js
generator-with-new-target.js
generator-with-super.js
generator-with-this-strict.js
generator-with-this.js
generator-yield-star.js
generic-arguments-correct-delete-behavior.js
get-argument-by-val-in-inlined-varargs-call-out-of-bounds.js
get-argument-by-val-safe-in-inlined-varargs-call-out-of-bounds.js
get-array-length-on-undecided.js
get-array-length-phantom-new-array-buffer.js
get-by-id-strict-arguments.js
get-by-id-strict-callee.js
get-by-id-strict-caller.js
get-by-id-strict-nested-arguments-2.js
get-by-id-strict-nested-arguments.js
get-by-id-throw-from-getter-through-optimized-code.js
get-by-id-throw-from-unexpected-getter-through-optimized-code-that-does-not-exit.js
get-by-id-throw-from-unexpected-getter-through-optimized-code.js
get-by-id-untyped.js
get-by-offset-double.js
get-by-val-double-predicted-int.js
get-by-val-on-undecided-array-type.js
get-by-val-on-undecided-out-of-bounds.js
get-by-val-on-undecided-sane-chain-1.js
get-by-val-on-undecided-sane-chain-2.js
get-by-val-on-undecided-sane-chain-3.js
get-by-val-on-undecided-sane-chain-4.js
get-by-val-on-undecided-sane-chain-5.js
get-by-val-on-undecided-sane-chain-6.js
get-by-val-on-undecided-trivial.js
get-by-val-out-of-bounds-basics.js
get-by-val-string.js
get-by-val-to-id-with-getter.js
get-by-val-with-string-constructor.js
get-by-val-with-string-exit.js
get-by-val-with-string-generated.js
get-by-val-with-string-getter.js
get-by-val-with-string.js
get-by-val-with-symbol-constructor.js
get-by-val-with-symbol-exit.js
get-by-val-with-symbol-getter.js
get-by-val-with-symbol.js
get-declared-unpassed-argument-in-direct-arguments.js
get-declared-unpassed-argument-in-scoped-arguments.js
get-from-scope-dynamic-onto-proxy.js
get-local-elimination.js
get-my-argument-by-val-constant-folding.js
get-my-argument-by-val-creates-arguments.js
get-my-argument-by-val-for-inlined-escaped-arguments.js
get-my-argument-by-val-inlined-no-formal-parameters.js
get-my-argument-by-val-out-of-bounds-no-warm-up.js
get-my-argument-by-val-out-of-bounds.js
get-my-argument-by-val-safe-out-of-bounds.js
get-my-argument-by-val-safe-wrap-around.js
get-my-argument-by-val-wrap-around-no-warm-up.js
get-my-argument-by-val-wrap-around.js
get-prototype-create-this-effectful.js
get-stack-identity-due-to-sinking.js
get-stack-mapping-with-dead-get-stack.js
get-stack-mapping.js
getter-arity.js
getter.js
global-const-redeclaration-setting-2.js
global-const-redeclaration-setting-3.js
global-const-redeclaration-setting-4.js
global-const-redeclaration-setting-5.js
global-const-redeclaration-setting.js
global-environment-does-not-trap-unscopables.js
global-is-finite.js
global-is-nan.js
global-isNaN-basics.js
global-lexical-environment-to-this.js
global-lexical-let-no-rhs.js
global-lexical-redeclare-variable.js
global-lexical-redefine-const.js
global-lexical-var-injection.js
global-lexical-variable-tdz.js
global-lexical-variable-unresolved-property.js
global-lexical-variable-with-statement.js
global-property-into-variable-get-from-scope.js
goofy-function-reentry-incorrect-inference.js
has-custom-properties.js
has-indexed-property-array-storage-ftl.js
has-indexed-property-array-storage.js
has-indexed-property-slow-put-array-storage-ftl.js
has-indexed-property-slow-put-array-storage.js
has-instance-exception-check.js
has-own-property-cache-basics.js
has-own-property-called-on-non-object.js
has-own-property-name-cache-string-keys.js
has-own-property-name-cache-symbol-keys.js
has-own-property-name-cache-symbols-and-strings.js
have-a-bad-time-with-arguments.js
having-a-bad-time-with-derived-arrays.js
heap-allocator-allocates-incorrect-size-for-activation.js
ic-throw-through-optimized-code.js
ignore-promise-species.js
import-basic.js
import-from-eval.js
import-reject-with-exception.js
import-syntax.js
import-with-empty-string.js
impure-get-own-property-slot-inline-cache.js
in-ftl-exception-check.js
indirect-call-object-constructor-with-no-arguments.js
infer-constant-global-property.js
infer-constant-property.js
infer-uninitialized-closure-var.js
inferred-infinite-loop-that-uses-captured-variables.js
inferred-names.js
inferred-type-table-stale-identifiers.js
infinite-loop-that-uses-captured-variables-before-throwing.js
infinite-loop-that-uses-captured-variables-but-they-do-not-escape.js
infinite-loop-that-uses-captured-variables-with-osr-entry.js
infinite-loop-that-uses-captured-variables.js
initialize_functions_after_arguments.js
injected-numeric-setter-on-prototype.js
inline-call-that-doesnt-use-all-args.js
inline-call-to-recursive-tail-call.js
inline-call-varargs-and-call.js
inline-call-varargs.js
inline-closure-call.js
inline-llint-with-switch.js
inline-varargs-get-arguments.js
inlined-constructor-this-liveness.js
inlined-error-gets-correct-codeblock-for-bytecodeoffset.js
inlined-function-this-liveness.js
inlined-tail-call-in-inlined-setter-should-not-crash-when-getting-value-profile.js
inlining-unreachable.js
inserted-recovery-with-set-last-index.js
instanceof-custom-hasinstancesymbol.js
instanceof-late-constant-folding.js
instanceof-not-cell.js
instanceof.js
int16-put-by-val-in-and-out-of-bounds.js
int16-put-by-val-in-bounds-then-exit-out-of-bounds.js
int16-put-by-val-out-of-bounds-bounds-then-do-in-bounds.js
int32-array-unshift.js
int32-min-to-string.js
int32-object-out-of-bounds.js
int32-out-of-bounds.js
int32array-transition-on-nan.js
int52-ai-add-then-filter-int32.js
int52-ai-mul-and-clean-neg-zero-then-filter-int32.js
int52-ai-mul-then-filter-int32-directly.js
int52-ai-mul-then-filter-int32.js
int52-ai-neg-then-filter-int32.js
int52-ai-sub-then-filter-int32.js
int52-argument.js
int52-force-osr-exit-path.js
int52-inlined-call-argument.js
int52-variable.js
int8-repeat-out-of-bounds.js
integer-range-optimization-constant-representation-1.js
integer-range-optimization-constant-representation-2.js
internal-function-call.js
internal-function-construct.js
intl-constructors-with-proxy.js
intrinsic-getter-with-poly-proto-getter-change.js
intrinsic-getter-with-poly-proto-proto-change.js
intrinsic-getter-with-poly-proto.js
invalidation-point.js
inverted-additive-subsumption.js
is-constructor.js
is-undefined-exit-on-masquerader.js
is-undefined-jettison-on-masquerader.js
is-undefined-masquerader.js
isLockFree.js
istypedarrayview-intrinsic.js
iterator-functions.js
iterator-names.js
iterator-prototype.js
iterator-return-beyond-multiple-iteration-scopes.js
iterators-shape.js
jit-cache-poly-replace-then-cache-get-and-fold-then-invalidate.js
jit-cache-replace-then-cache-get-and-fold-then-invalidate.js
jit-gracefully-handle-double-constants-in-math-operators.js
jit-put-to-scope-global-cache-watchpoint-invalidate.js
joined-strings-should-not-exceed-max-string-length.js
js-fixed-array-out-of-memory.js
jsc-read.js
jsc-setImpureGetterDelegate-on-bad-type.js
jsc-test-functions-should-be-more-robust.js
json-parse-on-frozen-object.js
json-stringify-with-non-jsarray-array.js
jsonp-literal-parser-semicolon-is-not-assignment.js
jsonp-program-evaluate-path-must-consider-global-lexical-environment.js
large-regexp.js
lars-sab-workers.js
lexical-let-and-with-statement.js
lexical-let-exception-handling.js
lexical-let-global-not-captured-variables.js
lexical-let-loop-semantics.js
lexical-let-not-strict-mode.js
lexical-let-semantics.js
lexical-let-tdz.js
lexical-scoping-break-continue.js
lexical-scoping-for-loop.js
licm-no-pre-header-nested.js
licm-no-pre-header.js
licm-pre-header-cannot-exit-nested.js
licm-pre-header-cannot-exit.js
lift-tdz-bypass-catch.js
lift-template-literal.js
liveness-pruning-needed-for-osr-availability-eager.js
liveness-pruning-needed-for-osr-availability.js
llint-cache-replace-then-cache-get-and-fold-then-invalidate.js
llint-get-by-id-cache-prototype-load-from-dictionary.js
llint-put-to-scope-global-cache-watchpoint-invalidate.js
llint-stack-overflow-location.js
load-varargs-elimination-bounds-check-barely.js
load-varargs-elimination-bounds-check.js
load-varargs-on-new-array-with-spread-convert-to-static-loads.js
load-varargs-then-inlined-call-and-exit-strict.js
load-varargs-then-inlined-call-and-exit.js
load-varargs-then-inlined-call-exit-in-foo.js
load-varargs-then-inlined-call-inlined.js
load-varargs-then-inlined-call.js
logical-not-masquerades.js
make-dictionary-repatch.js
make-large-string-jit-strcat.js
make-large-string-jit.js
make-large-string-strcat.js
make-large-string.js
make-rope-2.js
make-rope-3.js
many-sunken-locals.js
map-clone-instance-iterator-change.js
map-clone-iterator-change.js
map-clone-next-change.js
map-clone.js
map-constructor-adder.js
map-constructor.js
map-cse-correctness.js
map-delete.js
map-inherit-set.js
map-iteration.js
map-iterator-result-should-have-expected-shape.js
map-iterators-next.js
map-rehash-2.js
map-rehash.js
map-set-change-get.js
map-set-check-failure.js
map-set-clobber-map-get.js
map-set-create-bucket.js
map-set-cse.js
map-set-does-not-clobber-set-has.js
map-set-does-not-clobber-weak-map-get.js
map-untyped-normalize-cse.js
map-untyped-normalize.js
marked-argument-buffer.js
materialize-activation-referenced-from-phantom-function.js
materialize-object-referenced-from-phantom-object.js
materialize-past-butterfly-allocation.js
materialize-past-put-structure.js
materialize-regexp-at-osr-exit.js
materialize-regexp-cyclic-regexp-at-osr-exit.js
materialize-regexp-cyclic-regexp.js
materialize-regexp-cyclic.js
materialize-regexp-referenced-from-phantom-regexp-cyclic.js
materialize-regexp-referenced-from-phantom-regexp.js
materialize-regexp.js
math-abs-positive.js
math-ceil-arith-rounding-mode.js
math-ceil-basics.js
math-clz32-basics.js
math-exceptions.js
math-floor-arith-rounding-mode.js
math-floor-basics.js
math-log-basics.js
math-log-with-constants.js
math-max-min-no-arguments.js
math-pow-basics.js
math-pow-becomes-custom-function.js
math-pow-coherency.js
math-pow-integer-exponent-fastpath.js
math-pow-nan-behaviors.js
math-pow-stable-results.js
math-pow-with-constants.js
math-pow-with-never-NaN-exponent.js
math-round-arith-rounding-mode.js
math-round-basics.js
math-round-should-not-use-truncate.js
math-rounding-infinity.js
math-rounding-nan.js
math-rounding-negative-zero.js
math-sqrt-basics-disable-architecture-specific-optimizations.js
math-sqrt-basics.js
math-trunc-arith-rounding-mode.js
math-trunc-basics.js
math-trunc-should-be-truncate.js
math-unary-no-arg.js
max-boolean-exit.js
method-name.js
misaligned-int8-view-byte-offset.js
misaligned-int8-view-read.js
misaligned-int8-view-write.js
misc-is-object-or-null.js
model-effects-properly-of-spread-over-phantom-create-rest.js
modify-map-during-iteration.js
modify-set-during-iteration.js
module-namespace-access-change.js
module-namespace-access-non-constant.js
module-namespace-access-poly.js
module-namespace-access-transitive-exports.js
module-namespace-access.js
modules-syntax-error-with-names.js
modules-syntax-error.js
modules-syntax.js
mul-boolean-exit.js
multi-get-by-offset-dce.js
multi-get-by-offset-hoist-around-structure-check.js
multi-get-by-offset-proto-and-self.js
multi-get-by-offset-proto-or-unset.js
multi-get-by-offset-proto-self-or-unset.js
multi-get-by-offset-self-or-proto.js
multi-get-by-offset-self-or-unset.js
multi-put-by-offset-multiple-transitions.js
multi-put-by-offset-reallocation-butterfly-cse.js
multi-put-by-offset-reallocation-cases.js
multiply-typed-double-and-object.js
mutual-tail-call-no-stack-overflow.js
nan-equal-untyped.js
nan-equal.js
native-constructors-length.js
native-error-properties.js
need-bytecode-liveness-for-unreachable-blocks-at-dfg-time.js
new-array-buffer-sinking-osrexit.js
new-array-dead.js
new-array-having-a-bad-time-double.js
new-array-storage-array-with-size.js
new-array-then-exit.js
new-array-with-size-div.js
new-array-with-size-throw-exception-and-tear-off-arguments.js
new-array-with-size-with-bad-time.js
new-array-with-spread-double-new-array-buffer.js
new-array-with-spread-with-normal-spread-and-phantom-spread.js
new-array-with-spread-with-phantom-new-array-buffer.js
new-contiguous-array-with-size.js
new-double-array-with-size.js
new-function-expression-has-structures.js
new-int32-array-with-size.js
new-largeish-contiguous-array-with-size.js
new-promise-capabilities-requires-constructor.js
new-regex-inline.js
new-string-object.js
new-target-syntax-errors.js
new-target.js
new-undecided-array-with-size.js
no-abc-skippy-loop.js
no-abc-skippy-paired-loop.js
non-constructors.js
normalize-map-key-constant-folding.js
not-cell-use.js
number-is-finite.js
number-is-integer-intrinsic.js
number-is-nan.js
number-prototype-to-string-cast-overflow.js
number-prototype-to-string-exception.js
number-prototype-to-string-wrong-values.js
number-to-locale-string-should-accept-strange-number-objects.js
number-to-string-abstract-operation.js
number-to-string-radix.js
number-to-string-strength-reduction.js
number-to-string-with-add.js
number-to-string-with-radix-10.js
number-to-string-with-radix-cse.js
number-to-string-with-radix-invalid.js
number-to-string-with-radix-watchpoint.js
number-to-string-with-radix.js
number-to-string.js
numeric-setter-on-prototype-non-blank-array.js
numeric-setter-on-prototype.js
numeric-setter-on-self.js
obj-rest-destructuring-order.js
obj-spread-order.js
object-add.js
object-allocation-sinking-with-uninitialized-property-on-one-path.js
object-assign-changing-properties.js
object-assign-correctness.js
object-assign-enumerable.js
object-assign-order.js
object-assign-proxy.js
object-assign-string-first.js
object-assign-symbols.js
object-assign.js
object-bit-and.js
object-bit-or.js
object-bit-xor.js
object-constructor-boolean-edge.js
object-constructor-global.js
object-constructor-null-edge.js
object-constructor-number-edge.js
object-constructor-object-edge.js
object-constructor-should-be-new-target-aware.js
object-constructor-string-edge.js
object-constructor-symbol-edge.js
object-constructor-undefined-edge.js
object-div.js
object-entries.js
object-escapes-in-loop.js
object-freeze-accept-non-object.js
object-freeze-with-proxy-preventExtensions.js
object-get-own-property-descriptor-perform-to-object.js
object-get-own-property-names-perform-to-object.js
object-get-own-property-symbols-perform-to-object.js
object-get-own-property-symbols.js
object-get-prototype-of-filtered.js
object-get-prototype-of-mono-proto.js
object-get-prototype-of-perform-to-object.js
object-get-prototype-of-poly-mono-proto.js
object-get-prototype-of-poly-proto.js
object-is-extensible-accept-non-object.js
object-is-frozen-accept-non-object.js
object-is-sealed-accept-non-object.js
object-iterate-symbols.js
object-iterate.js
object-keys-perform-to-object.js
object-literal-methods.js
object-lshift.js
object-mul.js
object-number-properties.js
object-own-property-keys.js
object-prevent-extensions-accept-non-object.js
object-proto-getter-filtered.js
object-proto-getter-poly-mono-proto.js
object-proto-getter-poly-proto.js
object-prototype-proto-accessors-should-throw-on-undefined-this.js
object-rest-deconstruct.js
object-rshift.js
object-seal-accept-non-object.js
object-seal-with-proxy-preventExtensions.js
object-spread.js
object-sub.js
object-toString-with-proxy.js
object-urshift.js
object-values-changing-properties.js
object-values.js
obscure-error-message-dont-crash.js
obviously-elidable-new-object-then-exit.js
op-add-exceptions.js
op-negate-inline-cache.js
op-push-name-scope-crashes-profiler.js
op_add.js
op_bitand.js
op_bitor.js
op_bitxor.js
op_div-ConstVar.js
op_div-VarConst.js
op_div-VarVar.js
op_lshift-ConstVar.js
op_lshift-VarConst.js
op_lshift-VarVar.js
op_mod-ConstVar.js
op_mod-VarConst.js
op_mod-VarVar.js
op_mul-ConstVar.js
op_mul-VarConst.js
op_mul-VarVar.js
op_negate.js
op_postdec.js
op_postinc.js
op_predec.js
op_preinc.js
op_rshift-ConstVar.js
op_rshift-VarConst.js
op_rshift-VarVar.js
op_sub-ConstVar.js
op_sub-VarConst.js
op_sub-VarVar.js
op_urshift-ConstVar.js
op_urshift-VarConst.js
op_urshift-VarVar.js
operation-get-by-val-default-should-not-called-for-already-optimized-site.js
operation-in-may-have-negative-int32-array-storage.js
operation-in-may-have-negative-int32-contiguous-array.js
operation-in-may-have-negative-int32-double-array.js
operation-in-may-have-negative-int32-generic-array.js
operation-in-may-have-negative-int32-int32-array.js
operation-in-may-have-negative-int32.js
operation-in-negative-int32-cast.js
operation-in-throw-error.js
optional-catch-binding-syntax.js
optional-catch-binding.js
ordinary-set-exceptions.js
osr-enter-to-catch-with-set-local-type-check-failure.js
osr-exit-on-op-negate-should-no-fail-assertions.js
other-is-object-or-null.js
override-map-constructor.js
pad-start-calls-repeat-character-with-double.js
parameter-scoping.js
parse-int-intrinsic-dfg-backend-flush.js
parse-int-intrinsic.js
parse-regexp-as-token.js
path-sensitive-known-cell-crash.js
pathname-resolve.js
phantom-arguments-set-local-then-exit-in-same-block.js
phantom-direct-arguments-clobber-argument-count.js
phantom-direct-arguments-clobber-callee.js
phantom-inadequacy.js
phantom-local-captured-but-not-flushed-to-ssa.js
phantom-new-array-buffer-forward-varargs.js
phantom-new-array-buffer-forward-varargs2.js
phantom-new-array-buffer-osr-exit.js
phantom-new-array-with-spread-osr-exit.js
phantom-regexp-regexp-exec.js
phantom-regexp-string-match.js
phantom-spread-forward-varargs.js
phantom-spread-osr-exit.js
plus-boolean-exit.js
plus-boolean-or-double.js
plus-boolean-or-int.js
poly-call-exit-this.js
poly-call-exit.js
poly-call-stub-in-getter-stub.js
poly-chain-getter.js
poly-chain-setter.js
poly-chain-then-getter.js
poly-chain-then-setter.js
poly-getter-combo.js
poly-getter-then-chain.js
poly-getter-then-self.js
poly-proto-clear-stub.js
poly-proto-custom-value-and-accessor.js
poly-proto-intrinsic-getter-correctness.js
poly-proto-miss.js
poly-proto-op-in-caching.js
poly-proto-prototype-map-having-a-bad-time.js
poly-proto-put-transition.js
poly-proto-set-prototype.js
poly-proto-setter.js
poly-proto-using-inheritance.js
poly-self-getter.js
poly-self-then-getter.js
poly-setter-combo.js
poly-setter-then-self.js
polymorphic-prototype-accesses.js
pow-basics.js
pow-coherency.js
pow-evaluation-order.js
pow-expects-update-expression-on-lhs.js
pow-integer-exponent-fastpath.js
pow-nan-behaviors.js
pow-no-result.js
pow-simple.js
pow-stable-results.js
pow-to-number-should-be-executed-in-code-side.js
pow-with-constants.js
pow-with-never-NaN-exponent.js
primitive-poly-proto.js
private-name-as-anonymous-builtin.js
promise-cannot-be-called.js
promise-finally.js
promise-infinite-recursion-should-not-crash.js
promise-species-functions.js
prop-type-boolean-then-string.js
prop-type-int32-then-string.js
prop-type-number-then-string.js
prop-type-object-or-other-then-string.js
prop-type-object-then-string.js
prop-type-other-then-string.js
prop-type-string-then-object.js
prop-type-struct-or-other-then-string.js
prop-type-struct-then-object-opt-fold.js
prop-type-struct-then-object-opt-multi.js
prop-type-struct-then-object-opt.js
prop-type-struct-then-object.js
prop-type-symbol-then-object.js
prop-type-symbol-then-string.js
proper-flushing-when-we-insert-unreachable-after-force-exit-in-bytecode-parser.js
proper-property-store-with-prototype-property-that-is-not-writable.js
property-name-enumerator-should-not-look-into-indexed-values-when-it-is-a-dictionary.js
property-setters-should-not-be-called-for-bound-arguments-list-entries.js
proto-setter.js
prototype-chain-has-dictionary-structure-for-in-caching.js
prototype-getter.js
prototype-is-not-js-object.js
proxy-all-the-parameters.js
proxy-and-json-stringify.js
proxy-and-typed-array.js
proxy-array-prototype-methods.js
proxy-basic.js
proxy-call.js
proxy-class.js
proxy-construct.js
proxy-define-own-property.js
proxy-delete.js
proxy-get-and-set-recursion-stack-overflow.js
proxy-get-own-property.js
proxy-get-prototype-of.js
proxy-get-set-correct-receiver.js
proxy-get-with-primitive-receiver.js
proxy-has-property.js
proxy-in-proto-chain.js
proxy-inline-cache.js
proxy-instanceof.js
proxy-is-array.js
proxy-is-extensible.js
proxy-json.js
proxy-of-a-proxy.js
proxy-own-keys.js
proxy-prevent-extensions.js
proxy-property-descriptor.js
proxy-returning-incomplete-property-descriptor.js
proxy-revoke.js
proxy-set-prototype-of.js
proxy-set.js
proxy-stack-overflow-exceptions.js
proxy-underscore-proto.js
proxy-with-private-symbols.js
proxy-with-statement.js
proxy-with-unbalanced-getter-setter.js
prune-multi-put-by-offset-replace-or-transition-variant.js
put-by-id-build-list-order-recurse.js
put-by-id-direct-should-be-done-for-non-index-property.js
put-by-id-on-new-object-after-prototype-transition-non-strict.js
put-by-id-on-new-object-after-prototype-transition-strict.js
put-by-id-strict-build-list-order.js
put-by-id-throw-through-optimized-code.js
put-by-id-transition-null-prototype.js
put-by-val-array-storage.js
put-by-val-direct-out-of-bounds-setter.js
put-by-val-out-of-bounds-basics.js
put-by-val-slow-put-array-storage.js
put-by-val-with-string-break.js
put-by-val-with-string-generated.js
put-by-val-with-string-generic.js
put-by-val-with-symbol-break.js
put-by-val-with-symbol-generic.js
put-direct-index-broken-2.js
put-direct-index-broken.js
put-indexed-getter-setter.js
put-inline-cache-side-effects.js
put-local-conservative.js
raise-error-in-iterator-close.js
random-53bit.js
random-in-range.js
re-execute-error-module.js
real-forward-varargs-for-inlined-escaped-arguments.js
recurse-infinitely-on-getter.js
recursive-tail-call-with-different-argument-count.js
recursive-try-catch.js
recursive_property_redefine_during_inline_caching.js
redundant-add-overflow-checks.js
redundant-array-bounds-checks-addition-skip-first.js
redundant-array-bounds-checks-addition.js
redundant-array-bounds-checks-unchecked-addition.js
redundant-array-bounds-checks.js
reflect-apply.js
reflect-construct.js
reflect-define-property.js
reflect-delete-property.js
reflect-get-own-property.js
reflect-get-prototype-of.js
reflect-get.js
reflect-has.js
reflect-is-extensible.js
reflect-own-keys.js
reflect-prevent-extensions.js
reflect-set-prototype-of.js
reflect-set-proxy-set.js
reflect-set-receiver-proxy-set.js
reflect-set-with-global-proxy.js
reflect-set.js
reflect.js
regexp-exec-effect-after-exception.js
regexp-last-index-sinking.js
regexp-last-index-writable.js
regexp-match-in-other-realm-should-work.js
regexp-match-proxy.js
regexp-match-should-work-with-objects-not-inheriting-object-prototype.js
regexp-match.js
regexp-matches-array-bad-time.js
regexp-matches-array-slow-put.js
regexp-matches-array.js
regexp-prototype-exec-on-too-long-rope.js
regexp-prototype-match-on-too-long-rope.js
regexp-prototype-replace-builtin-should-not-use-for-of.js
regexp-prototype-test-on-too-long-rope.js
regexp-prototype-tostring.js
regexp-replace-in-other-realm-should-work.js
regexp-replace-proxy.js
regexp-replace-should-work-with-objects-not-inheriting-object-prototype.js
regexp-search.js
regexp-syntax-error-invalid-flags.js
regress-132147.js
regress-135155.js
regress-141489.js
regress-141883.js
regress-148564.js
regress-150532.js
regress-151324.js
regress-153486.js
regress-153816.js
regress-156765.js
regress-156992.js
regress-157322.js
regress-157595.js
regress-158411.js
regress-158437.js
regress-159537.js
regress-159744.js
regress-159779-1.js
regress-159779-2.js
regress-159883.js
regress-159954.js
regress-160329.js
regress-160749.js
regress-161995.js
regress-163748.js
regress-164081.js
regress-166812.js
regress-168546.js
regress-169783.js
regress-169941.js
regress-170412.js
regress-170473.js
regress-170661.js
regress-170732.js
regress-170896-with-contiguous-shape-profile.js
regress-170896-with-double-shape-profile.js
regress-170896-with-int32-shape-profile.js
regress-170973.js
regress-170989.js
regress-170990.js
regress-171079.js
regress-172346.js
regress-172383.js
regress-172548.patch.js
regress-173035.js
regress-173053.js
regress-173321.js
regress-174044.js
regress-174948.js
regress-176485.js
regress-177423.js
regress-177570.js
regress-177584.js
regress-177600.js
regress-178385.js
regress-178386.js
regress-178420.js
regress-178890.js
regress-179140.js
regress-179185.js
regress-179355.js
regress-179562.js
regress-179619.js
regress-179634.js
regress-180219.js
regress-180761.js
regress-181388.js
regress-182419.js
relaxed-line-terminators-in-string.js
remove-phantom-after-setlocal.js
repeat-put-to-scope-global-with-same-value-watchpoint-invalidate.js
repeated-arity-check-fail.js
repeated-put-by-id-reallocating-transition.js
replacement-watchpoint-dictionary.js
replacement-watchpoint.js
reserved-word-with-escape.js
rest-elements.js
rest-parameter-allocation-elimination-watchpoints-2.js
rest-parameter-allocation-elimination-watchpoints-3.js
rest-parameter-allocation-elimination-watchpoints-4.js
rest-parameter-allocation-elimination-watchpoints-5.js
rest-parameter-allocation-elimination-watchpoints.js
rest-parameter-and-default-arguments.js
rest-parameter-basics.js
rest-parameter-having-a-bad-time.js
rest-parameter-inlined.js
rest-parameter-is-destructuring.js
rest-parameter-many-arguments.js
rest-parameter-negative.js
rest-parameter-various-types.js
retry-cache-later.js
right-left-context-invalidated-by-input.js
ropes-symbol-toprimitive.js
runtime-array.js
runtime-throw-through-optimized-code.js
sampling-profiler-anonymous-function.js
sampling-profiler-basic.js
sampling-profiler-bound-function-name.js
sampling-profiler-deep-stack.js
sampling-profiler-display-name.js
sampling-profiler-internal-function-name.js
sampling-profiler-microtasks.js
scoped-arguments-array-length.js
scoped-arguments-write-barrier-should-be-on-scope-object.js
scoped-then-direct-arguments-get-by-val-in-baseline.js
set-add-check-failure.js
set-add-clobber-set-has.js
set-add-create-bucket.js
set-add-cse.js
set-add-does-not-clobber-map-get.js
set-clone-instance-iterator-change.js
set-clone-iterator-change.js
set-clone-next-change.js
set-clone.js
set-constructor-adder.js
set-constructor.js
set-inherit-add.js
set-iterator-result-should-have-expected-shape.js
set-iterators-next.js
set-same-prototype.js
set-untyped-normalize-cse.js
set-untyped-normalize.js
setter-same-base-and-rhs-invalid-assertion-inside-access-case.js
setter.js
shadow-chicken-disabled.js
shadow-chicken-enabled.js
shadow-chicken-reading-from-scope-after-ftl-osr-exit-bytecode-liveness.js
simple-polyvariant-call-inlining-example.js
simple-polyvariant-get-by-id-inlining-example.js
simple-polyvariant-put-by-id-inlining-example.js
simple-prototype-accesses.js
simple-regexp-exec-folding-fail.js
simple-regexp-exec-folding.js
simple-regexp-test-folding-fail.js
simple-regexp-test-folding.js
simplify-varargs-mandatory-minimum-smaller-than-limit.js
singleton-scope-then-overwrite.js
singleton-scope-then-realloc-and-overwrite.js
singleton-scope-then-realloc.js
sink-arguments-past-invalid-check-dfg.js
sink-arguments-past-invalid-check-int32-dfg.js
sink-arguments-past-invalid-check-int32.js
sink-arguments-past-invalid-check-sneakier.js
sink-arguments-past-invalid-check.js
sink-function-past-invalid-check-sneakier.js
sink-function-past-invalid-check-sneaky.js
sink-multigetbyoffset.js
sink-object-past-invalid-check-int32.js
sink-object-past-invalid-check-sneakier.js
sink-object-past-invalid-check-sneaky.js
sink-object-past-invalid-check.js
sink-to-impossible-multi-get-by-offset-on-prototypes.js
sink_checkstructure.js
slightly-more-difficult-to-fold-reflective-arguments-access.js
sloppy-mode-function-hoisting.js
sloppy-mode-hoist-arguments-function-non-simple-parameter-list.js
slow-path-generator-updating-current-node-dfg.js
sort-array-with-undecided.js
sort-null-comparator.js
sorting-boolean-result-comparator.js
source-origin.js
sparse-array-entry-update-144067.js
sparse-define-empty-descriptor.js
sparse-map-non-overlapping.js
sparse-map-non-skip-getter-overriding.js
sparse-map-non-skip.js
sparse_splice.js
spec-empty-flows-through-cell-checks.js
splay-flash-access-1ms.js
splay-flash-access.js
spread-array-iterator-watchpoint-2.js
spread-array-iterator-watchpoint.js
spread-call-convert-to-static-call.js
spread-calling.js
spread-capture-rest.js
spread-consults-correct-global-object.js
spread-correct-global-object-on-exception.js
spread-escapes-but-create-rest-does-not.js
spread-escapes-but-new-array-buffer-does-not.js
spread-forward-call-varargs-stack-overflow.js
spread-forward-varargs-rest-parameter-change-iterator-protocol-2.js
spread-forward-varargs-rest-parameter-change-iterator-protocol.js
spread-forward-varargs-stack-overflow.js
spread-in-tail.js
spread-multi-layers.js
spread-non-array.js
spread-non-varargs.js
spread-optimized-properly.js
spread-outer-create-rest.js
static-function-delete.js
static-function-put.js
static-getter-delete.js
static-getter-descriptors.js
static-getter-enumeration.js
static-getter-get.js
static-getter-in-names.js
static-getter-names.js
static-getter-put.js
strcat-emtpy.js
strict-function-structure.js
strict-mode-arguments-caller.js
strict-nested-function-structure.js
strict-to-this-int.js
string-compare.js
string-from-char-code-slow.js
string-from-code-point.js
string-ident-to-not-string-var-equality.js
string-iterators.js
string-joining-long-strings-should-not-crash.js
string-normalize.js
string-object-define-own-property.js
string-object-put-by-index.js
string-out-of-bounds-negative-proto-value.js
string-proto.js
string-prototype-charCodeAt-on-too-long-rope.js
string-prototype-methods-endsWith-startsWith-includes-correctness.js
string-prototype-replace-should-throw-out-of-memory-error-when-using-too-much-memory.js
string-prototype-scopes-global-lexical-environment-strict.js
string-prototype-scopes-global-lexical-environment.js
string-prototype-scopes-strict.js
string-prototype-scopes.js
string-raw.js
string-repeat-copy-chars-crash.js
string-repeat-edge-cases.js
string-replace-constant-folding-replacer-not-string.js
string-replace-proxy.js
string-rope-with-custom-valueof.js
string-symbol-customization.js
sub-overflows-after-not-equal.js
super-call-does-not-look-up-constructor.js
super-call-function-subclass.js
super-dot-call-and-apply.js
super-force-ic-fail.js
super-get-by-id.js
super-getter-reset-ic.js
super-in-lexical-scope.js
super-method-calls-check-tdz.js
super-property-access-exceptions.js
super-property-access-object-literal-to-this-2.js
super-property-access-object-literal-to-this.js
super-property-access-tdz.js
super-property-access-to-this.js
super-property-access.js
switch-typeof-indirect.js
switch-typeof-slightly-indirect.js
switch-typeof.js
symbol-and-string-constructor.js
symbol-array-from.js
symbol-define-property.js
symbol-equality-over-gc.js
symbol-equality.js
symbol-error-messages.js
symbol-get-own-property.js
symbol-hasInstance.js
symbol-registry.js
symbol-seal-and-freeze.js
symbol-should-not-break-for-in.js
symbol-species.js
symbol-toprimitive-errors.js
symbol-toprimitive.js
symbol-tostringtag-watchpoints.js
symbol-tostringtag.js
symbol-with-json.js
tagged-template-object-collect.js
tagged-template-object.js
tagged-template-tdz.js
tagged-templates-identity.js
tagged-templates-raw-strings.js
tagged-templates-syntax.js
tagged-templates-template-object.js
tagged-templates-this.js
tagged-templates.js
tail-call-host-call-throw.js
tail-call-in-inline-cache.js
tail-call-no-stack-overflow.js
tail-call-profiler.js
tail-call-recognize.js
tail-call-varargs-no-stack-overflow.js
tail-calls-dont-overwrite-live-stack.js
tailCallForwardArguments.js
tdz-this-in-try-catch.js
template-literal-line-terminators.js
template-literal-syntax.js
template-literal.js
template-string-tags-eval.js
test-finally.js
test-spec-misc.js
throw-from-ftl-call-ic-slow-path-cells.js
throw-from-ftl-call-ic-slow-path-undefined.js
throw-from-ftl-call-ic-slow-path.js
throw-from-ftl-in-loop.js
throw-from-ftl.js
throw-through-optimized-code.js
tier-up-in-loop-with-cfg-simplification.js
to-int32-sensible.js
to-int32-sensible2.js
to-lower-case-intrinsic-on-empty-rope.js
to-lower-case.js
to-number-basics.js
to-number-convert-identity-without-execution.js
to-number-int52.js
to-number-intrinsic-convert-to-identity-without-execution.js
to-number-intrinsic-int52.js
to-number-intrinsic-object-without-execution.js
to-number-intrinsic-value-profiling.js
to-number-object-without-execution.js
to-number-object.js
to-number-throws-correct-exception.js
to-number-value-profiling.js
to-object-intrinsic-boolean-edge.js
to-object-intrinsic-null-or-undefined-edge.js
to-object-intrinsic-number-edge.js
to-object-intrinsic-object-edge.js
to-object-intrinsic-string-edge.js
to-object-intrinsic-symbol-edge.js
to-object-intrinsic.js
to-property-key-correctness.js
to-string-int32.js
to-string-int52.js
to-string-non-cell-use.js
to-string-on-object-or-string.js
to-string-on-object.js
to-string-on-string-object.js
to-string-on-string-or-string-object-then-object.js
to-string-on-string-or-string-object.js
to-string-on-value-or-string.js
to-string-on-value.js
to-string-with-int52.js
to-this-before-arrow-function-closes-over-this-that-starts-as-lexical-environment.js
to-this-boolean.js
to-this-double.js
to-this-global-object.js
to-this-int32.js
to-this-int52.js
to-this-number.js
to-this-numbers.js
to-this-on-constant-lexical-environment.js
to-this-polymorphic.js
to-this-string.js
to-this-symbol.js
toprimitive-speculated-types.js
trailing-comma-in-function-parameters.js
trailing-comma-in-patterns.js
tricky-array-bounds-checks.js
tricky-indirectly-inferred-infinite-loop-that-uses-captured-variables-and-creates-the-activation-outside-the-loop.js
tricky-inferred-infinite-loop-that-uses-captured-variables-and-creates-the-activation-outside-the-loop.js
tricky-infinite-loop-that-uses-captured-variables-and-creates-the-activation-outside-the-loop.js
tricky-infinite-loop-that-uses-captured-variables.js
trim.js
trivially-foldable-reflective-arguments-access.js
try-catch-custom-getter-as-get-by-id.js
try-catch-getter-as-get-by-id-register-restoration.js
try-catch-getter-as-get-by-id.js
try-catch-setter-as-put-by-id.js
try-catch-stub-routine-replaced.js
try-get-by-id-poly-proto.js
try-get-by-id-should-spill-registers-dfg.js
try-get-by-id.js
type-check-hoisting-phase-hoist-check-structure-on-tdz-this-value.js
type-of-functions-and-objects.js
typed-array-byte-offset.js
typed-array-get-by-val-profiling.js
typed-array-put-by-val-profiling.js
typed-array-view-set-should-not-crash-on-exception.js
typedarray-access-monomorphic-neutered.js
typedarray-access-neutered.js
typedarray-add-property-to-base-object.js
typedarray-bad-getter.js
typedarray-configure-index.js
typedarray-construct-iterator.js
typedarray-constructor.js
typedarray-copyWithin.js
typedarray-every.js
typedarray-fill.js
typedarray-filter.js
typedarray-find.js
typedarray-findIndex.js
typedarray-forEach.js
typedarray-from.js
typedarray-functions-with-neutered.js
typedarray-getownproperty-not-configurable.js
typedarray-getter-on-self.js
typedarray-includes.js
typedarray-indexOf.js
typedarray-intrinsic-getters-change-prototype.js
typedarray-lastIndexOf.js
typedarray-length-dictionary.js
typedarray-map.js
typedarray-of.js
typedarray-reduce.js
typedarray-reduceRight.js
typedarray-set.js
typedarray-slice.js
typedarray-some.js
typedarray-sort.js
typedarray-subarray.js
typedarray-view-string-properties-neutered.js
typeof-dfg-function-or-object.js
typeof-symbol.js
uint32-comparison-jump.js
uint32-comparison.js
uint32-to-number-constant-folding.js
uint32-to-number-fold-constant-with-do-overflow.js
uint32-to-number-overflows-to-uint52.js
uint32array-unsigned-load.js
undecided-concat.js
undecided-length.js
undefined-access-dictionary-then-proto-change.js
undefined-access-then-proto-change.js
undefined-access-then-self-change.js
unescape.js
unscopables.js
unshift-array-storage.js
unshiftCountSlowCase-correct-postCapacity.js
untyped-add.js
untyped-bit-and.js
untyped-bit-or.js
untyped-bit-xor.js
untyped-div.js
untyped-equality.js
untyped-less-than.js
untyped-lshift.js
untyped-mul.js
untyped-rshift.js
untyped-sub.js
untyped-urshift.js
use-arguments-as-object-pointer.js
v8-crypto-strict.js
v8-deltablue-strict.js
v8-earley-boyer-strict.js
v8-parameter-scoping.js
v8-raytrace-strict.js
v8-regexp-strict.js
v8-richards-strict.js
v8-splay-strict.js
value-add-on-double-array-with-holes.js
value-to-boolean.js
value-to-int32-undefined-constant.js
value-to-int32-undefined.js
values-unscopables.js
var-injection-cache-invalidation.js
varargs-closure-inlined-exit-strict-mode.js
varargs-closure-inlined-exit.js
varargs-exit.js
varargs-inlined-exit.js
varargs-inlined-simple-exit-aliasing-weird-reversed-args.js
varargs-inlined-simple-exit-aliasing-weird.js
varargs-inlined-simple-exit-aliasing.js
varargs-inlined-simple-exit.js
varargs-inlining-underflow.js
varargs-no-forward.js
varargs-simple.js
varargs-then-slow-call.js
varargs-too-few-arguments.js
varargs-two-level.js
varargs-varargs-closure-inlined-exit.js
varargs-varargs-inlined-exit-strict-mode.js
varargs-varargs-inlined-exit.js
varargs-with-unused-count.js
variable-named-eval-under-tdz.js
variable-under-tdz-eval-tricky.js
watchdog-dont-malloc-when-in-c-code.js
weak-map-constructor-adder.js
weak-map-constructor.js
weak-set-constructor-adder.js
weak-set-constructor.js
weakmap-cse-set-break.js
weakmap-cse.js
weakmap-gc.js
weakmap-set-change-get.js
weakmap-set-cse.js
weakset-add-change-get.js
weakset-add-cse.js
weakset-cse-add-break.js
weakset-cse.js
weakset-gc.js
weird-equality-folding-cases.js
weird-getter-counter.js
weird-put-stack-varargs.js
weird-setter-counter-syntactic.js
weird-setter-counter.js
with.js
with_and_arith.js
yield-and-line-terminator.js
yield-label-generator.js
yield-label.js
yield-named-accessors-generator.js
yield-named-accessors.js
yield-named-variable-generator.js
yield-named-variable.js
yield-out-of-generator.js
yield-reserved-word.js
yield-star-throw-continue.js
zero-to-string.js
arith-nodes-abstract-interpreter-untypeduse.js:SyntaxError: Unexpected token *
// This test that the DFG Abstract interpreter properly handles UntypedUse for various ArithXXX and CompareXXX nodes.
// This test should run without errors or crashing.

let errors = 0;
const smallValue = 2.3023e-320;

function test(functionName, testFunc) {
    try{
        var ary_1 = [1.1, 2.2, 3.3];
        var ary_2 = ary_1;
        var f64_1 = new Float64Array(0x10);

        for (var i = 0; i < 200000; i++)
            testFunc(ary_1, f64_1, '1');

        testFunc(ary_2, f64_1, { toString:()=>{ ary_2[0] = {}; return "3"}});
        if (ary_2[2] != smallValue)
            throw functionName + " returned the wrong value";
    } catch(e) {
        errors++;
        print("Exception testing " + functionName + ": " + e);
    };
};

for (let i = 0; i < 8; i++) {
    test("Warmup", function(a, b, c){
        a[0] = 1.1;
        a[1] = 2.2;
        var tmp = Math.abs(c);
        b[0] = a[0];
        a[2] = smallValue;
    });
}

test("Unary -", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = -c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("Unary +", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = +c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("+", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = a[1] + c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("-", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = a[1] - c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("*", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = a[1] * c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("/", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = a[1] / c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("%", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = a[1] % c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("**", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = c ** a[1];
    b[0] = a[0];
    a[2] = smallValue;
});

test("prefix ++", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = ++c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("prefix --", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = --c;
    b[0] = a[0];
    a[2] = smallValue;
});

test("==", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = c == 7;
    b[0] = a[0];
    a[2] = smallValue;
});

test("<", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = c < 42;
    b[0] = a[0];
    a[2] = smallValue;
});

test("<=", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = c <= 7;
    b[0] = a[0];
    a[2] = smallValue;
});

test(">", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = c > 3;
    b[0] = a[0];
    a[2] = smallValue;
});

test(">=", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = c >= 12;
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.abs", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.abs(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.acos", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.acos(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.acosh", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.acosh(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.asin", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.asin(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.asinh", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.asinh(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.atan", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.atan(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.atan2", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.atan2(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.atanh", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.atanh(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.ceil", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.ceil(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.cos", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.cos(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.cosh", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.cosh(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.exp", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.exp(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.expm1", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.expm1(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.floor", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.floor(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.fround", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.fround(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.log", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.log(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.log1p", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.log1p(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.log10", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.log10(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.log2", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.log2(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.round", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.round(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.sin", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.sin(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.sign", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.sign(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.sinh", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.sinh(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.sqrt", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.sqrt(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.tan", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.tan(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.tanh", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.tanh(c);
    b[0] = a[0];
    a[2] = smallValue;
});

test("Math.trunc", function(a, b, c){
    a[0] = 1.1;
    a[1] = 2.2;
    var tmp = Math.trunc(c);
    b[0] = a[0];
    a[2] = smallValue;
});


if (errors)
    throw "Failed " + errors + " tests."

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let errors = 0;',
       message: 'Parsing error: Unexpected token errors',
       line: 4,
       column: 5 } ],
  output: '// This test that the DFG Abstract interpreter properly handles UntypedUse for various ArithXXX and CompareXXX nodes.\n// This test should run without errors or crashing.\n\nlet errors = 0;\nconst smallValue = 2.3023e-320;\n\nfunction test(functionName, testFunc) {\n    try{\n        var ary_1 = [1.1, 2.2, 3.3];\n        var ary_2 = ary_1;\n        var f64_1 = new Float64Array(0x10);\n\n        for (var i = 0; i < 200000; i++)\n            testFunc(ary_1, f64_1, \'1\');\n\n        testFunc(ary_2, f64_1, { toString:()=>{ ary_2[0] = {}; return "3"}});\n        if (ary_2[2] != smallValue)\n            throw functionName + " returned the wrong value";\n    } catch(e) {\n        errors++;\n        print("Exception testing " + functionName + ": " + e);\n    };\n};\n\nfor (let i = 0; i < 8; i++) {\n    test("Warmup", function(a, b, c){\n        a[0] = 1.1;\n        a[1] = 2.2;\n        var tmp = Math.abs(c);\n        b[0] = a[0];\n        a[2] = smallValue;\n    });\n}\n\ntest("Unary -", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = -c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Unary +", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = +c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("+", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = a[1] + c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("-", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = a[1] - c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("*", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = a[1] * c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("/", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = a[1] / c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("%", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = a[1] % c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("**", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = c ** a[1];\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("prefix ++", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = ++c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("prefix --", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = --c;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("==", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = c == 7;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("<", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = c < 42;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("<=", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = c <= 7;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest(">", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = c > 3;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest(">=", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = c >= 12;\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.abs", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.abs(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.acos", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.acos(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.acosh", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.acosh(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.asin", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.asin(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.asinh", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.asinh(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.atan", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.atan(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.atan2", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.atan2(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.atanh", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.atanh(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.ceil", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.ceil(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.cos", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.cos(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.cosh", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.cosh(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.exp", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.exp(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.expm1", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.expm1(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.floor", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.floor(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.fround", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.fround(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.log", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.log(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.log1p", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.log1p(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.log10", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.log10(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.log2", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.log2(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.round", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.round(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.sin", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.sin(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.sign", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.sign(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.sinh", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.sinh(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.sqrt", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.sqrt(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.tan", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.tan(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.tanh", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.tanh(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\ntest("Math.trunc", function(a, b, c){\n    a[0] = 1.1;\n    a[1] = 2.2;\n    var tmp = Math.trunc(c);\n    b[0] = a[0];\n    a[2] = smallValue;\n});\n\n\nif (errors)\n    throw "Failed " + errors + " tests."\n' }
async-arrow-functions-lexical-arguments-binding.js:SyntaxError: Unexpected token =>
function shouldBe(expected, actual, msg) {
    if (msg === void 0)
        msg = "";
    else
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run, msg) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

function shouldThrowAsync(run, errorType, message) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (!hadError)
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");
    if (!(actual instanceof errorType))
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but threw '" + actual + "'");
    if (message !== void 0 && actual.message !== message)
        throw new Error("Expected " + run + "() to throw '" + message + "', but threw '" + actual.message + "'");
}

var noArgumentsArrow = async () => await [...arguments];
shouldThrowAsync(() => noArgumentsArrow(1, 2, 3), ReferenceError);
var noArgumentsArrow2 = async () => { return await [...arguments]; }
shouldThrowAsync(() => noArgumentsArrow2(1, 2, 3), ReferenceError);

shouldBeAsync("[1,2,3]", () => (function() { return (async () => JSON.stringify([...arguments]))(); })(1, 2, 3));
shouldBeAsync("[4,5,6]", () => (function() { return (async () => { return JSON.stringify([...await arguments]) })(); })(4, 5, 6));

(function testArgumentsBinding() {
    var argsBinding;
    var promise = (function() { argsBinding = arguments; return (async() => arguments)() })(1, 2, 3);
    shouldBeAsync(argsBinding, () => promise);
})();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let actual;',
       message: 'Parsing error: Unexpected token actual',
       line: 11,
       column: 9 } ],
  output: 'function shouldBe(expected, actual, msg) {\n    if (msg === void 0)\n        msg = "";\n    else\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run, msg) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nfunction shouldThrowAsync(run, errorType, message) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (!hadError)\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");\n    if (!(actual instanceof errorType))\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but threw \'" + actual + "\'");\n    if (message !== void 0 && actual.message !== message)\n        throw new Error("Expected " + run + "() to throw \'" + message + "\', but threw \'" + actual.message + "\'");\n}\n\nvar noArgumentsArrow = async () => await [...arguments];\nshouldThrowAsync(() => noArgumentsArrow(1, 2, 3), ReferenceError);\nvar noArgumentsArrow2 = async () => { return await [...arguments]; }\nshouldThrowAsync(() => noArgumentsArrow2(1, 2, 3), ReferenceError);\n\nshouldBeAsync("[1,2,3]", () => (function() { return (async () => JSON.stringify([...arguments]))(); })(1, 2, 3));\nshouldBeAsync("[4,5,6]", () => (function() { return (async () => { return JSON.stringify([...await arguments]) })(); })(4, 5, 6));\n\n(function testArgumentsBinding() {\n    var argsBinding;\n    var promise = (function() { argsBinding = arguments; return (async() => arguments)() })(1, 2, 3);\n    shouldBeAsync(argsBinding, () => promise);\n})();\n' }
async-arrow-functions-lexical-binding-in-class.js:SyntaxError: Unexpected token x
function shouldBe(expected, actual, msg) {
    if (msg === void 0)
        msg = "";
    else
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual);
}

class BaseWrongClass {
    baseClassValue() {
        return "wrong #1";
    }
    get property() {
        return "wrong #2";
    }
}

function shouldBeAsyncAndStoreBind(expected, run) {
    shouldBeAsync(expected, run);
    shouldBeAsync(expected, run.bind({}));
    shouldBeAsync(expected, run.bind(1));
    shouldBeAsync(expected, run.bind(undefined));
    const obj = { 
        property : 'wrong value #1', 
        baseClassValue : () => 'worng value #2'
    };
    shouldBeAsync(expected, run.bind(obj));
    shouldBeAsync(expected, run.bind(new BaseWrongClass()));
}

class BaseClass {
    baseClassValue() {
        return "BaseClassValue";
    }
    get property() {
        return "test!";
    }
}

function runSomething(callback) {
    callback();
}

class ChildClass extends BaseClass {
    classValue() {
        return "classValue";
    }
    get classProperty() {
        return "classProperty";
    }
    asyncValueExp() {
        return async x => 'value';
    }
    asyncValueBody() {
        return async x => { return 'value'; };
    }
    asyncThisPropExp() {
        return async x => this.classProperty;
    }
    asyncThisPropBody() {
        return async x => { return this.classProperty; };
    }
    asyncThisPropWithAwaitBody() {
        return async x => { 
            var self = this.classProperty; 
            self = await 'abc';  
            return this.classProperty; 
        };
    }
    asyncThisPropInEvalExp() {
        return async x => eval('this.classProperty');
    }
    asyncThisPropInEvalBody() {
        return async x => { return eval('this.classProperty'); };
    }
    asyncThisPropInEvalWithAwaitBody() {
        return async x => { 
            var self = eval('this.classProperty');
            await 'abc';
            return eval('this.classProperty'); 
        };
    }
    asyncThisValueExp() {
        return async x => this.classValue();
    }
    asyncThisValueBody() {
        return async x => { return this.classValue(); };
    }
    asyncThisValueBodyWithAwait() {
        return async x => { 
            var self = this.classValue();
            await 'self'; 
            return this.classValue(); 
        };
    }
    asyncThisValueInEvalExp() {
        return async x => eval('this.classValue()');
    }
    asyncThisValueInEvalBody() {
        return async x => { return eval('this.classValue()'); };
    }
    asyncThisValueInEvalWithAwaitBody() {
        return async x => { 
            var self = eval('this.classValue()');
            await 'self'; 
            return eval('this.classValue()'); 
        };
    }
}

shouldBeAsyncAndStoreBind("value", new ChildClass().asyncValueExp());
shouldBeAsyncAndStoreBind("value", new ChildClass().asyncValueBody());

shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropExp());
shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropBody());
shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropWithAwaitBody());
shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropWithAwaitBody());

shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropInEvalExp());
shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropInEvalBody());
shouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropInEvalWithAwaitBody());

shouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueExp());
shouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueBody());
shouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueBodyWithAwait());

shouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueInEvalExp());
shouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueInEvalBody());
shouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueInEvalWithAwaitBody());

class ChildClass2 extends BaseClass {
    constructor() {
        super();
        this.value = 'internalValue';
        return async () => this.classValue() + ' ' + this.classProperty;
    }
    classStaticValue() {
        return "classStaticValue";
    }
    classValue() {
        return this.value;
    }
    get classProperty() {
        return "classProperty";
    }
}

shouldBeAsyncAndStoreBind("internalValue classProperty", new ChildClass2());

class ChildClass3 extends BaseClass {
    constructor() {
        super();
        this.internalValue = 'internalValue';
        return async () => {
            var self = this.classValue() + ' ' + this.classProperty;
            await 'self';
            return this.classValue() + ' ' + this.classProperty;
        }
    }
    classValue() {
        return "classValue";
    }
    get classProperty() {
        return "classProperty";
    }
}

shouldBeAsyncAndStoreBind("classValue classProperty", new ChildClass3());

var promiseHolder = {};
var promise = new Promise((resolve, reject) => {
    promiseHolder.resolve = resolve;
    promiseHolder.reject = reject;
});

class ChildClass4 extends BaseClass {
    constructor() {
        var arr = async () => {
            var doSomeStaff = () => {};
            doSomeStaff();
            await promise;
            return this.classValue() + ' ' + this.classProperty;
        };
        arr();
        super();
        this.internalValue = 'internalValue';
        return async () => {
            await 'await';
            promiseHolder.resolve();
            return this.classValue() + ' ' + this.classProperty;;
        };
    }
    classValue() {
        return "classValue";
    }
    get classProperty() {
        return "classProperty";
    }
}

shouldBeAsyncAndStoreBind("classValue classProperty", new ChildClass4());

class ChildClass5 extends BaseClass {
    constructor(result) {
        const arr = async () => this.id;
        arr().then(()=>{}, e => { result.error = e; });
    }
}

class ChildClass6 extends BaseClass {
    constructor(result) {
        const arr = async () => { 
            let z = this.id;
        };
        arr().then(()=>{}, e => { result.error = e; });
        super();
    }
}

class ChildClass7 extends BaseClass {
    constructor(result) {
        const arr = async () => this.id;
        arr().then(()=>{}, e => { result.error = e; });
        super();
    }
}

class ChildClass8 extends BaseClass {
    constructor(result) {
        const arr = async () => { let i  = this.id; super(); };
        arr().then(()=>{}, e => { result.error = e; });
    }
}

function checkTDZDuringCreate(klass) {
    let asyncError = {};
    try {
        var c = new klass(asyncError);
    } catch(e) {
        // We do not care about this error
    }
    drainMicrotasks();
    const error = asyncError.error instanceof ReferenceError && asyncError.error.toString() === 'ReferenceError: Cannot access uninitialized variable.';
    if (!error) throw new Error('TDZ error is expected, but appeared:' + asyncError.error);
}

checkTDZDuringCreate(ChildClass5);
checkTDZDuringCreate(ChildClass6);
checkTDZDuringCreate(ChildClass7);
checkTDZDuringCreate(ChildClass8);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let actual;',
       message: 'Parsing error: Unexpected token actual',
       line: 11,
       column: 9 } ],
  output: 'function shouldBe(expected, actual, msg) {\n    if (msg === void 0)\n        msg = "";\n    else\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual);\n}\n\nclass BaseWrongClass {\n    baseClassValue() {\n        return "wrong #1";\n    }\n    get property() {\n        return "wrong #2";\n    }\n}\n\nfunction shouldBeAsyncAndStoreBind(expected, run) {\n    shouldBeAsync(expected, run);\n    shouldBeAsync(expected, run.bind({}));\n    shouldBeAsync(expected, run.bind(1));\n    shouldBeAsync(expected, run.bind(undefined));\n    const obj = { \n        property : \'wrong value #1\', \n        baseClassValue : () => \'worng value #2\'\n    };\n    shouldBeAsync(expected, run.bind(obj));\n    shouldBeAsync(expected, run.bind(new BaseWrongClass()));\n}\n\nclass BaseClass {\n    baseClassValue() {\n        return "BaseClassValue";\n    }\n    get property() {\n        return "test!";\n    }\n}\n\nfunction runSomething(callback) {\n    callback();\n}\n\nclass ChildClass extends BaseClass {\n    classValue() {\n        return "classValue";\n    }\n    get classProperty() {\n        return "classProperty";\n    }\n    asyncValueExp() {\n        return async x => \'value\';\n    }\n    asyncValueBody() {\n        return async x => { return \'value\'; };\n    }\n    asyncThisPropExp() {\n        return async x => this.classProperty;\n    }\n    asyncThisPropBody() {\n        return async x => { return this.classProperty; };\n    }\n    asyncThisPropWithAwaitBody() {\n        return async x => { \n            var self = this.classProperty; \n            self = await \'abc\';  \n            return this.classProperty; \n        };\n    }\n    asyncThisPropInEvalExp() {\n        return async x => eval(\'this.classProperty\');\n    }\n    asyncThisPropInEvalBody() {\n        return async x => { return eval(\'this.classProperty\'); };\n    }\n    asyncThisPropInEvalWithAwaitBody() {\n        return async x => { \n            var self = eval(\'this.classProperty\');\n            await \'abc\';\n            return eval(\'this.classProperty\'); \n        };\n    }\n    asyncThisValueExp() {\n        return async x => this.classValue();\n    }\n    asyncThisValueBody() {\n        return async x => { return this.classValue(); };\n    }\n    asyncThisValueBodyWithAwait() {\n        return async x => { \n            var self = this.classValue();\n            await \'self\'; \n            return this.classValue(); \n        };\n    }\n    asyncThisValueInEvalExp() {\n        return async x => eval(\'this.classValue()\');\n    }\n    asyncThisValueInEvalBody() {\n        return async x => { return eval(\'this.classValue()\'); };\n    }\n    asyncThisValueInEvalWithAwaitBody() {\n        return async x => { \n            var self = eval(\'this.classValue()\');\n            await \'self\'; \n            return eval(\'this.classValue()\'); \n        };\n    }\n}\n\nshouldBeAsyncAndStoreBind("value", new ChildClass().asyncValueExp());\nshouldBeAsyncAndStoreBind("value", new ChildClass().asyncValueBody());\n\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropExp());\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropBody());\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropWithAwaitBody());\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropWithAwaitBody());\n\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropInEvalExp());\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropInEvalBody());\nshouldBeAsyncAndStoreBind("classProperty", new ChildClass().asyncThisPropInEvalWithAwaitBody());\n\nshouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueExp());\nshouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueBody());\nshouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueBodyWithAwait());\n\nshouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueInEvalExp());\nshouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueInEvalBody());\nshouldBeAsyncAndStoreBind("classValue", new ChildClass().asyncThisValueInEvalWithAwaitBody());\n\nclass ChildClass2 extends BaseClass {\n    constructor() {\n        super();\n        this.value = \'internalValue\';\n        return async () => this.classValue() + \' \' + this.classProperty;\n    }\n    classStaticValue() {\n        return "classStaticValue";\n    }\n    classValue() {\n        return this.value;\n    }\n    get classProperty() {\n        return "classProperty";\n    }\n}\n\nshouldBeAsyncAndStoreBind("internalValue classProperty", new ChildClass2());\n\nclass ChildClass3 extends BaseClass {\n    constructor() {\n        super();\n        this.internalValue = \'internalValue\';\n        return async () => {\n            var self = this.classValue() + \' \' + this.classProperty;\n            await \'self\';\n            return this.classValue() + \' \' + this.classProperty;\n        }\n    }\n    classValue() {\n        return "classValue";\n    }\n    get classProperty() {\n        return "classProperty";\n    }\n}\n\nshouldBeAsyncAndStoreBind("classValue classProperty", new ChildClass3());\n\nvar promiseHolder = {};\nvar promise = new Promise((resolve, reject) => {\n    promiseHolder.resolve = resolve;\n    promiseHolder.reject = reject;\n});\n\nclass ChildClass4 extends BaseClass {\n    constructor() {\n        var arr = async () => {\n            var doSomeStaff = () => {};\n            doSomeStaff();\n            await promise;\n            return this.classValue() + \' \' + this.classProperty;\n        };\n        arr();\n        super();\n        this.internalValue = \'internalValue\';\n        return async () => {\n            await \'await\';\n            promiseHolder.resolve();\n            return this.classValue() + \' \' + this.classProperty;;\n        };\n    }\n    classValue() {\n        return "classValue";\n    }\n    get classProperty() {\n        return "classProperty";\n    }\n}\n\nshouldBeAsyncAndStoreBind("classValue classProperty", new ChildClass4());\n\nclass ChildClass5 extends BaseClass {\n    constructor(result) {\n        const arr = async () => this.id;\n        arr().then(()=>{}, e => { result.error = e; });\n    }\n}\n\nclass ChildClass6 extends BaseClass {\n    constructor(result) {\n        const arr = async () => { \n            let z = this.id;\n        };\n        arr().then(()=>{}, e => { result.error = e; });\n        super();\n    }\n}\n\nclass ChildClass7 extends BaseClass {\n    constructor(result) {\n        const arr = async () => this.id;\n        arr().then(()=>{}, e => { result.error = e; });\n        super();\n    }\n}\n\nclass ChildClass8 extends BaseClass {\n    constructor(result) {\n        const arr = async () => { let i  = this.id; super(); };\n        arr().then(()=>{}, e => { result.error = e; });\n    }\n}\n\nfunction checkTDZDuringCreate(klass) {\n    let asyncError = {};\n    try {\n        var c = new klass(asyncError);\n    } catch(e) {\n        // We do not care about this error\n    }\n    drainMicrotasks();\n    const error = asyncError.error instanceof ReferenceError && asyncError.error.toString() === \'ReferenceError: Cannot access uninitialized variable.\';\n    if (!error) throw new Error(\'TDZ error is expected, but appeared:\' + asyncError.error);\n}\n\ncheckTDZDuringCreate(ChildClass5);\ncheckTDZDuringCreate(ChildClass6);\ncheckTDZDuringCreate(ChildClass7);\ncheckTDZDuringCreate(ChildClass8);\n' }
async-arrow-functions-lexical-super-binding.js:SyntaxError: Unexpected token x
function shouldBe(expected, actual, msg) {
    if (msg === void 0)
        msg = "";
    else
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run, msg) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

class BaseClass {
    baseClassValue() {
        return "BaseClassValue";
    }
    get property() {
        return "test!";
    }
}

class ChildClass extends BaseClass {
    asyncSuperProp() {
        return async x => super.baseClassValue();
    }
    asyncSuperProp2() {
        return async x => { return super.baseClassValue(); }
    }
}

shouldBeAsync("BaseClassValue", new ChildClass().asyncSuperProp());
shouldBeAsync("BaseClassValue", new ChildClass().asyncSuperProp2());

class ChildClass2 extends BaseClass {
    constructor() {
        return async (self = super()) => self.baseClassValue() + ' ' + super.property;
    }
}

shouldBeAsync("BaseClassValue test!", new ChildClass2());

var error = undefined;
var value = undefined;

class A {
    constructor() {
        this._id = 'class-id';
    }
}

const childA1 = new class extends A {
  constructor() {
    var f = async (a=super()) => { return 'abc'; }
    f().then( val => {value = val; }, err => { error = err;});
  }
}

drainMicrotasks();

shouldBe(childA1._id, 'class-id');
shouldBe(value, 'abc');
shouldBe(error, undefined);

value = undefined;
error = undefined;

const childA2 = new class extends A {
  constructor() {
    var f = async (a) => { super(); return 'abc'; }
    f().then( val => {value = val; }, err => { error = err;});
  }
}

drainMicrotasks();

shouldBe(childA2._id, 'class-id');
shouldBe(value, 'abc');
shouldBe(error, undefined);

value = undefined;
error = undefined;

const childA3 = new class extends A {
    constructor() {
        var f = async (a = super()) => { super(); return 'abc'; }
        f().then( val => {value = val; }, err => { error = err;});
    }
}

drainMicrotasks();

shouldBe(childA3._id, 'class-id');
shouldBe(value, undefined);
shouldBe(error.toString(), 'ReferenceError: \'super()\' can\'t be called more than once in a constructor.');


let childA4;
let catchError;
error = undefined; 
try {
    childA4 = new class extends A {
        constructor() {
            var f = async (a) => { await 'await value'; super(); return 'abc'; }
            f().then(val => { value = val; }, err => { error = err; });
        }
    }
} catch (err) {
    catchError = err;  
}

drainMicrotasks();

shouldBe(childA4, undefined);
shouldBe(value, 'abc');
shouldBe(error, undefined);
shouldBe(catchError.toString(), 'ReferenceError: Cannot access uninitialized variable.');

catchError = undefined;
error = undefined; 
value = undefined;

const childA5 = new class extends A {
    constructor() {
        var f = async (a) => { super(); await 'await value'; return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}

drainMicrotasks();

shouldBe(childA5._id, 'class-id');
shouldBe(value, 'abc');
shouldBe(error, undefined);
shouldBe(catchError, undefined);

function checkClass(classSource) {
    let base1 = undefined;
    let error = undefined; 
    let value = undefined;
    let catchError = undefined;
    try {
        base1 = eval(classSource);

        drainMicrotasks();
    } catch (err) {
        catchError = err;  
    }

    shouldBe(base1, undefined);
    shouldBe(value, undefined);
    shouldBe(error, undefined);
    shouldBe(catchError.toString(), 'SyntaxError: super is not valid in this context.');
}

checkClass(`new class {
    constructor() {
        var f = async (a) => { super(); return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}`);

checkClass(`new class {
    constructor() {
        var f = async (a) => { await 'p'; super(); return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}`);

checkClass(`new class {
    constructor() {
        var f = async (a) => { super(); await 'p'; return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}`);


checkClass(`new class extends A {
    method() {
        var f = async (a) => { super(); return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}`);

checkClass(`new class extends A {
    get prop() {
        var f = async (a) => { super(); return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}`);

checkClass(`new class extends A {
    set prop(_value) {
        var f = async (a) => { super(); return 'abc'; }
        f().then(val => { value = val; }, err => { error = err; });
    }
}`);
{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let actual;',
       message: 'Parsing error: Unexpected token actual',
       line: 11,
       column: 9 } ],
  output: 'function shouldBe(expected, actual, msg) {\n    if (msg === void 0)\n        msg = "";\n    else\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run, msg) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nclass BaseClass {\n    baseClassValue() {\n        return "BaseClassValue";\n    }\n    get property() {\n        return "test!";\n    }\n}\n\nclass ChildClass extends BaseClass {\n    asyncSuperProp() {\n        return async x => super.baseClassValue();\n    }\n    asyncSuperProp2() {\n        return async x => { return super.baseClassValue(); }\n    }\n}\n\nshouldBeAsync("BaseClassValue", new ChildClass().asyncSuperProp());\nshouldBeAsync("BaseClassValue", new ChildClass().asyncSuperProp2());\n\nclass ChildClass2 extends BaseClass {\n    constructor() {\n        return async (self = super()) => self.baseClassValue() + \' \' + super.property;\n    }\n}\n\nshouldBeAsync("BaseClassValue test!", new ChildClass2());\n\nvar error = undefined;\nvar value = undefined;\n\nclass A {\n    constructor() {\n        this._id = \'class-id\';\n    }\n}\n\nconst childA1 = new class extends A {\n  constructor() {\n    var f = async (a=super()) => { return \'abc\'; }\n    f().then( val => {value = val; }, err => { error = err;});\n  }\n}\n\ndrainMicrotasks();\n\nshouldBe(childA1._id, \'class-id\');\nshouldBe(value, \'abc\');\nshouldBe(error, undefined);\n\nvalue = undefined;\nerror = undefined;\n\nconst childA2 = new class extends A {\n  constructor() {\n    var f = async (a) => { super(); return \'abc\'; }\n    f().then( val => {value = val; }, err => { error = err;});\n  }\n}\n\ndrainMicrotasks();\n\nshouldBe(childA2._id, \'class-id\');\nshouldBe(value, \'abc\');\nshouldBe(error, undefined);\n\nvalue = undefined;\nerror = undefined;\n\nconst childA3 = new class extends A {\n    constructor() {\n        var f = async (a = super()) => { super(); return \'abc\'; }\n        f().then( val => {value = val; }, err => { error = err;});\n    }\n}\n\ndrainMicrotasks();\n\nshouldBe(childA3._id, \'class-id\');\nshouldBe(value, undefined);\nshouldBe(error.toString(), \'ReferenceError: \\\'super()\\\' can\\\'t be called more than once in a constructor.\');\n\n\nlet childA4;\nlet catchError;\nerror = undefined; \ntry {\n    childA4 = new class extends A {\n        constructor() {\n            var f = async (a) => { await \'await value\'; super(); return \'abc\'; }\n            f().then(val => { value = val; }, err => { error = err; });\n        }\n    }\n} catch (err) {\n    catchError = err;  \n}\n\ndrainMicrotasks();\n\nshouldBe(childA4, undefined);\nshouldBe(value, \'abc\');\nshouldBe(error, undefined);\nshouldBe(catchError.toString(), \'ReferenceError: Cannot access uninitialized variable.\');\n\ncatchError = undefined;\nerror = undefined; \nvalue = undefined;\n\nconst childA5 = new class extends A {\n    constructor() {\n        var f = async (a) => { super(); await \'await value\'; return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}\n\ndrainMicrotasks();\n\nshouldBe(childA5._id, \'class-id\');\nshouldBe(value, \'abc\');\nshouldBe(error, undefined);\nshouldBe(catchError, undefined);\n\nfunction checkClass(classSource) {\n    let base1 = undefined;\n    let error = undefined; \n    let value = undefined;\n    let catchError = undefined;\n    try {\n        base1 = eval(classSource);\n\n        drainMicrotasks();\n    } catch (err) {\n        catchError = err;  \n    }\n\n    shouldBe(base1, undefined);\n    shouldBe(value, undefined);\n    shouldBe(error, undefined);\n    shouldBe(catchError.toString(), \'SyntaxError: super is not valid in this context.\');\n}\n\ncheckClass(`new class {\n    constructor() {\n        var f = async (a) => { super(); return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}`);\n\ncheckClass(`new class {\n    constructor() {\n        var f = async (a) => { await \'p\'; super(); return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}`);\n\ncheckClass(`new class {\n    constructor() {\n        var f = async (a) => { super(); await \'p\'; return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}`);\n\n\ncheckClass(`new class extends A {\n    method() {\n        var f = async (a) => { super(); return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}`);\n\ncheckClass(`new class extends A {\n    get prop() {\n        var f = async (a) => { super(); return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}`);\n\ncheckClass(`new class extends A {\n    set prop(_value) {\n        var f = async (a) => { super(); return \'abc\'; }\n        f().then(val => { value = val; }, err => { error = err; });\n    }\n}`);' }
async-arrow-functions-lexical-new.target-binding.js:SyntaxError: Unexpected token =>
function shouldBe(expected, actual, msg) {
    if (msg === void 0)
        msg = "";
    else
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run, msg) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

function C1() {
    return async () => await new.target;
}

function C2() {
    return async () => { return await new.target };
}

function C2WithAwait() {
    return async () => { 
        var self = new.target; await new.target;
        return new.target;
    }
}

shouldBeAsync(C1, new C1());
shouldBeAsync(undefined, C1());
shouldBeAsync(C2, new C2());
shouldBeAsync(undefined, C2());
shouldBeAsync(C2WithAwait, new C2WithAwait());
shouldBeAsync(undefined, C2WithAwait());

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let actual;',
       message: 'Parsing error: Unexpected token actual',
       line: 11,
       column: 9 } ],
  output: 'function shouldBe(expected, actual, msg) {\n    if (msg === void 0)\n        msg = "";\n    else\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run, msg) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nfunction C1() {\n    return async () => await new.target;\n}\n\nfunction C2() {\n    return async () => { return await new.target };\n}\n\nfunction C2WithAwait() {\n    return async () => { \n        var self = new.target; await new.target;\n        return new.target;\n    }\n}\n\nshouldBeAsync(C1, new C1());\nshouldBeAsync(undefined, C1());\nshouldBeAsync(C2, new C2());\nshouldBeAsync(undefined, C2());\nshouldBeAsync(C2WithAwait, new C2WithAwait());\nshouldBeAsync(undefined, C2WithAwait());\n' }
async-arrow-functions-lexical-this-binding.js:SyntaxError: Unexpected token z
function shouldBe(expected, actual, msg) {
    if (msg === void 0)
        msg = "";
    else
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run, msg) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

var d = ({ x : "bar", y : function() { return async z => this.x + z; }}).y();
var e = { x : "baz", y : d };

shouldBeAsync("barley", () => d("ley"));
shouldBeAsync("barley", () => e.y("ley"));

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let actual;',
       message: 'Parsing error: Unexpected token actual',
       line: 11,
       column: 9 } ],
  output: 'function shouldBe(expected, actual, msg) {\n    if (msg === void 0)\n        msg = "";\n    else\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run, msg) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nvar d = ({ x : "bar", y : function() { return async z => this.x + z; }}).y();\nvar e = { x : "baz", y : d };\n\nshouldBeAsync("barley", () => d("ley"));\nshouldBeAsync("barley", () => e.y("ley"));\n' }
async-await-basic.js:SyntaxError: Unexpected token function
function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run, msg) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

function shouldThrow(run, errorType, message) {
    let actual;
    var hadError = false;

    try {
        actual = run();
    } catch (e) {
        hadError = true;
        actual = e;
    }

    if (!hadError)
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");
    if (!(actual instanceof errorType))
        throw new Error("Expeced " + run + "() to throw " + errorType.name + " , but threw '" + actual + "'");
    if (message !== void 0 && actual.message !== message)
        throw new Error("Expected " + run + "() to throw '" + message + "', but threw '" + actual.message + "'");
}

function shouldThrowAsync(run, errorType, message) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (!hadError)
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");
    if (!(actual instanceof errorType))
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but threw '" + actual + "'");
    if (message !== void 0 && actual.message !== message)
        throw new Error("Expected " + run + "() to throw '" + message + "', but threw '" + actual.message + "'");
}

function shouldThrowSyntaxError(str, message) {
    try {
        eval(str);
        throw new Error("Expected `" + str + "` to throw a SyntaxError, but did not throw.")
    } catch (e) {
        if (e.constructor !== SyntaxError)
            throw new Error("Expected `" + str + "` to throw a SyntaxError, but threw '" + e + "'");
        if (message !== void 0 && e.message !== message)
            throw new Error("Expected `" + str + "` to throw SyntaxError: '" + message + "', but threw '" + e + "'");
    }
}

// Do not install `AsyncFunction` constructor on global object
shouldBe(undefined, this.AsyncFunction);
let AsyncFunction = (async function() {}).constructor;

// Let functionPrototype be the intrinsic object %AsyncFunctionPrototype%.
async function asyncFunctionForProto() {}
shouldBe(AsyncFunction.prototype, Object.getPrototypeOf(asyncFunctionForProto));
shouldBe(AsyncFunction.prototype, Object.getPrototypeOf(async function() {}));
shouldBe(AsyncFunction.prototype, Object.getPrototypeOf(async () => {}));
shouldBe(AsyncFunction.prototype, Object.getPrototypeOf({ async method() {} }.method));

// FIXME: AsyncFunction constructor should build functions with correct prototype.
// shouldBe(AsyncFunction.prototype, Object.getPrototypeOf(AsyncFunction()));

// AsyncFunctionCreate does not produce an object with a Prototype
shouldBe(undefined, asyncFunctionForProto.prototype);
shouldBe(false, asyncFunctionForProto.hasOwnProperty("prototype"));
shouldBe(undefined, (async function() {}).prototype);
shouldBe(false, (async function() {}).hasOwnProperty("prototype"));
shouldBe(undefined, (async() => {}).prototype);
shouldBe(false, (async() => {}).hasOwnProperty("prototype"));
shouldBe(undefined, ({ async method() {} }).method.prototype);
shouldBe(false, ({ async method() {} }).method.hasOwnProperty("prototype"));
shouldBe(undefined, AsyncFunction().prototype);
shouldBe(false, AsyncFunction().hasOwnProperty("prototype"));

// AsyncFunction.prototype[ @@toStringTag ]
var descriptor = Object.getOwnPropertyDescriptor(AsyncFunction.prototype, Symbol.toStringTag);
shouldBe("AsyncFunction", descriptor.value);
shouldBe(false, descriptor.enumerable);
shouldBe(false, descriptor.writable);
shouldBe(true, descriptor.configurable);

shouldBe(1, AsyncFunction.length);

// Let F be ! FunctionAllocate(functionPrototype, Strict, "non-constructor")
async function asyncNonConstructorDecl() {}
shouldThrow(() => new asyncNonConstructorDecl(), TypeError);
shouldThrow(() => new (async function() {}), TypeError);
shouldThrow(() => new ({ async nonConstructor() {} }).nonConstructor(), TypeError);
shouldThrow(() => new (() => "not a constructor!"), TypeError);
shouldThrow(() => new (AsyncFunction()), TypeError);

// Normal completion
async function asyncDecl() { return "test"; }
shouldBeAsync("test", asyncDecl);
shouldBeAsync("test2", async function() { return "test2"; });
shouldBeAsync("test3", async () => "test3");
shouldBeAsync("test4", () => ({ async f() { return "test4"; } }).f());

class MyError extends Error {};

// Throw completion
async function asyncDeclThrower(e) { throw new MyError(e); }
shouldThrowAsync(() => asyncDeclThrower("boom!"), MyError, "boom!");
shouldThrowAsync(() => (async function(e) { throw new MyError(e); })("boom!!!"), MyError, "boom!!!");
shouldThrowAsync(() => (async e => { throw new MyError(e) })("boom!!"), MyError, "boom!!");
shouldThrowAsync(() => ({ async thrower(e) { throw new MyError(e); } }).thrower("boom!!!!"), MyError, "boom!!!!");

function resolveLater(value) { return Promise.resolve(value); }
function rejectLater(error) { return Promise.reject(error); }

// Resume after Normal completion
var log = [];
async function resumeAfterNormal(value) {
    log.push("start:" + value);
    value = await resolveLater(value + 1);
    log.push("resume:" + value);
    value = await resolveLater(value + 1);
    log.push("resume:" + value);
    return value + 1;
}

shouldBeAsync(4, () => resumeAfterNormal(1));
shouldBe("start:1 resume:2 resume:3", log.join(" "));

var O = {
    async resumeAfterNormal(value) {
        log.push("start:" + value);
        value = await resolveLater(value + 1);
        log.push("resume:" + value);
        value = await resolveLater(value + 1);
        log.push("resume:" + value);
        return value + 1;
    }
};
log = [];
shouldBeAsync(5, () => O.resumeAfterNormal(2));
shouldBe("start:2 resume:3 resume:4", log.join(" "));

var resumeAfterNormalArrow = async (value) => {
    log.push("start:" + value);
    value = await resolveLater(value + 1);
    log.push("resume:" + value);
    value = await resolveLater(value + 1);
    log.push("resume:" + value);
    return value + 1;
};
log = [];
shouldBeAsync(6, () => resumeAfterNormalArrow(3));
shouldBe("start:3 resume:4 resume:5", log.join(" "));

var resumeAfterNormalEval = AsyncFunction("value", `
    log.push("start:" + value);
    value = await resolveLater(value + 1);
    log.push("resume:" + value);
    value = await resolveLater(value + 1);
    log.push("resume:" + value);
    return value + 1;
`);
log = [];
shouldBeAsync(7, () => resumeAfterNormalEval(4));
shouldBe("start:4 resume:5 resume:6", log.join(" "));

// Resume after Throw completion
async function resumeAfterThrow(value) {
    log.push("start:" + value);
    try {
        value = await rejectLater("throw1");
    } catch (e) {
        log.push("resume:" + e);
    }
    try {
        value = await rejectLater("throw2");
    } catch (e) {
        log.push("resume:" + e);
    }
    return value + 1;
}

log = [];
shouldBeAsync(2, () => resumeAfterThrow(1));
shouldBe("start:1 resume:throw1 resume:throw2", log.join(" "));

var O = {
    async resumeAfterThrow(value) {
        log.push("start:" + value);
        try {
            value = await rejectLater("throw1");
        } catch (e) {
            log.push("resume:" + e);
        }
        try {
            value = await rejectLater("throw2");
        } catch (e) {
            log.push("resume:" + e);
        }
        return value + 1;
    }
}
log = [];
shouldBeAsync(3, () => O.resumeAfterThrow(2));
shouldBe("start:2 resume:throw1 resume:throw2", log.join(" "));

var resumeAfterThrowArrow = async (value) => {
    log.push("start:" + value);
    try {
        value = await rejectLater("throw1");
    } catch (e) {
        log.push("resume:" + e);
    }
    try {
        value = await rejectLater("throw2");
    } catch (e) {
        log.push("resume:" + e);
    }
    return value + 1;
};
log = [];
shouldBeAsync(4, () => resumeAfterThrowArrow(3));
shouldBe("start:3 resume:throw1 resume:throw2", log.join(" "));

var resumeAfterThrowEval = AsyncFunction("value", `
    log.push("start:" + value);
    try {
        value = await rejectLater("throw1");
    } catch (e) {
        log.push("resume:" + e);
    }
    try {
        value = await rejectLater("throw2");
    } catch (e) {
        log.push("resume:" + e);
    }
    return value + 1;
`);
log = [];
shouldBeAsync(5, () => resumeAfterThrowEval(4));
shouldBe("start:4 resume:throw1 resume:throw2", log.join(" "));

var awaitEpression = async (value) => {
    log.push("start:" + value);
    if (!await false)
        log.push('step 1');
    var t = ~await true;
    log.push('step 2 ' + t);

    var t1 = +await Promise.resolve(12345);
    log.push('step 3 ' + t1);

    var t2 = -await 54321;
    log.push('step 4 ' + t2);

    var t3 = !!!!!await Promise.resolve(true);
    log.push('step 5 ' + t3);

    try {
        var t4 = ++await 1;
    } catch(e) {
        if (e instanceof ReferenceError) {
            log.push('step 6 ');
        } 
    }

    try {
        var t5 = --await 1;
    } catch(e) {
        if (e instanceof ReferenceError) {
            log.push('step 7');
        } 
    }

    return void await 'test';
};
log = [];

shouldBeAsync(undefined, () => awaitEpression(5));
shouldBe("start:5 step 1 step 2 -2 step 3 12345 step 4 -54321 step 5 false step 6  step 7", log.join(" "));

// MethoodDefinition SyntaxErrors
shouldThrowSyntaxError("var obj = { async foo : true };", "Unexpected token ':'. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async foo = true };", "Unexpected token '='. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async foo , bar };", "Unexpected token ','. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async foo }", "Unexpected token '}'. Expected a parenthesis for argument list.");

shouldThrowSyntaxError("var obj = { async 0 : true };", "Unexpected token ':'. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async 0 = true };", "Unexpected token '='. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async 0 , bar };", "Unexpected token ','. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async 0 }", "Unexpected token '}'. Expected a parenthesis for argument list.");

shouldThrowSyntaxError("var obj = { async 'foo' : true };", "Unexpected token ':'. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async 'foo' = true };", "Unexpected token '='. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async 'foo' , bar };", "Unexpected token ','. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async 'foo' }", "Unexpected token '}'. Expected a parenthesis for argument list.");

shouldThrowSyntaxError("var obj = { async ['foo'] : true };", "Unexpected token ':'. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async ['foo'] = true };", "Unexpected token '='. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async ['foo'] , bar };", "Unexpected token ','. Expected a parenthesis for argument list.");
shouldThrowSyntaxError("var obj = { async ['foo'] }", "Unexpected token '}'. Expected a parenthesis for argument list.");

shouldThrowSyntaxError("class C { async foo : true };", "Unexpected token ':'. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async foo = true };", "Unexpected token '='. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async foo , bar };", "Unexpected token ','. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async foo }", "Unexpected token '}'. Expected an opening '(' before a async method's parameter list.");

shouldThrowSyntaxError("class C { async 0 : true };", "Unexpected token ':'. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async 0 = true };", "Unexpected token '='. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async 0 , bar };", "Unexpected token ','. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async 0 }", "Unexpected token '}'. Expected an opening '(' before a async method's parameter list.");

shouldThrowSyntaxError("class C { async 'foo' : true };", "Unexpected token ':'. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async 'foo' = true };", "Unexpected token '='. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async 'foo' , bar };", "Unexpected token ','. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async 'foo' }", "Unexpected token '}'. Expected an opening '(' before a async method's parameter list.");

shouldThrowSyntaxError("class C { async ['foo'] : true };", "Unexpected token ':'. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async ['foo'] = true };", "Unexpected token '='. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async ['foo'] , bar };", "Unexpected token ','. Expected an opening '(' before a async method's parameter list.");
shouldThrowSyntaxError("class C { async ['foo'] }", "Unexpected token '}'. Expected an opening '(' before a async method's parameter list.");

// Ensure awaited builtin Promise objects are themselves wrapped in a new Promise,
// per https://tc39.github.io/ecma262/#sec-async-functions-abstract-operations-async-function-await
log = [];
async function awaitedPromisesAreWrapped() {
    log.push("before");
    await Promise.resolve();
    log.push("after");
}
awaitedPromisesAreWrapped();
Promise.resolve().then(() => log.push("Promise.resolve()"));
drainMicrotasks();
shouldBe("before|Promise.resolve()|after", log.join("|"));
{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 41 } ],
  output: 'function shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run, msg) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nfunction shouldThrow(run, errorType, message) {\n    let actual;\n    var hadError = false;\n\n    try {\n        actual = run();\n    } catch (e) {\n        hadError = true;\n        actual = e;\n    }\n\n    if (!hadError)\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");\n    if (!(actual instanceof errorType))\n        throw new Error("Expeced " + run + "() to throw " + errorType.name + " , but threw \'" + actual + "\'");\n    if (message !== void 0 && actual.message !== message)\n        throw new Error("Expected " + run + "() to throw \'" + message + "\', but threw \'" + actual.message + "\'");\n}\n\nfunction shouldThrowAsync(run, errorType, message) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (!hadError)\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");\n    if (!(actual instanceof errorType))\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but threw \'" + actual + "\'");\n    if (message !== void 0 && actual.message !== message)\n        throw new Error("Expected " + run + "() to throw \'" + message + "\', but threw \'" + actual.message + "\'");\n}\n\nfunction shouldThrowSyntaxError(str, message) {\n    try {\n        eval(str);\n        throw new Error("Expected `" + str + "` to throw a SyntaxError, but did not throw.")\n    } catch (e) {\n        if (e.constructor !== SyntaxError)\n            throw new Error("Expected `" + str + "` to throw a SyntaxError, but threw \'" + e + "\'");\n        if (message !== void 0 && e.message !== message)\n            throw new Error("Expected `" + str + "` to throw SyntaxError: \'" + message + "\', but threw \'" + e + "\'");\n    }\n}\n\n// Do not install `AsyncFunction` constructor on global object\nshouldBe(undefined, this.AsyncFunction);\nlet AsyncFunction = (async function() {}).constructor;\n\n// Let functionPrototype be the intrinsic object %AsyncFunctionPrototype%.\nasync function asyncFunctionForProto() {}\nshouldBe(AsyncFunction.prototype, Object.getPrototypeOf(asyncFunctionForProto));\nshouldBe(AsyncFunction.prototype, Object.getPrototypeOf(async function() {}));\nshouldBe(AsyncFunction.prototype, Object.getPrototypeOf(async () => {}));\nshouldBe(AsyncFunction.prototype, Object.getPrototypeOf({ async method() {} }.method));\n\n// FIXME: AsyncFunction constructor should build functions with correct prototype.\n// shouldBe(AsyncFunction.prototype, Object.getPrototypeOf(AsyncFunction()));\n\n// AsyncFunctionCreate does not produce an object with a Prototype\nshouldBe(undefined, asyncFunctionForProto.prototype);\nshouldBe(false, asyncFunctionForProto.hasOwnProperty("prototype"));\nshouldBe(undefined, (async function() {}).prototype);\nshouldBe(false, (async function() {}).hasOwnProperty("prototype"));\nshouldBe(undefined, (async() => {}).prototype);\nshouldBe(false, (async() => {}).hasOwnProperty("prototype"));\nshouldBe(undefined, ({ async method() {} }).method.prototype);\nshouldBe(false, ({ async method() {} }).method.hasOwnProperty("prototype"));\nshouldBe(undefined, AsyncFunction().prototype);\nshouldBe(false, AsyncFunction().hasOwnProperty("prototype"));\n\n// AsyncFunction.prototype[ @@toStringTag ]\nvar descriptor = Object.getOwnPropertyDescriptor(AsyncFunction.prototype, Symbol.toStringTag);\nshouldBe("AsyncFunction", descriptor.value);\nshouldBe(false, descriptor.enumerable);\nshouldBe(false, descriptor.writable);\nshouldBe(true, descriptor.configurable);\n\nshouldBe(1, AsyncFunction.length);\n\n// Let F be ! FunctionAllocate(functionPrototype, Strict, "non-constructor")\nasync function asyncNonConstructorDecl() {}\nshouldThrow(() => new asyncNonConstructorDecl(), TypeError);\nshouldThrow(() => new (async function() {}), TypeError);\nshouldThrow(() => new ({ async nonConstructor() {} }).nonConstructor(), TypeError);\nshouldThrow(() => new (() => "not a constructor!"), TypeError);\nshouldThrow(() => new (AsyncFunction()), TypeError);\n\n// Normal completion\nasync function asyncDecl() { return "test"; }\nshouldBeAsync("test", asyncDecl);\nshouldBeAsync("test2", async function() { return "test2"; });\nshouldBeAsync("test3", async () => "test3");\nshouldBeAsync("test4", () => ({ async f() { return "test4"; } }).f());\n\nclass MyError extends Error {};\n\n// Throw completion\nasync function asyncDeclThrower(e) { throw new MyError(e); }\nshouldThrowAsync(() => asyncDeclThrower("boom!"), MyError, "boom!");\nshouldThrowAsync(() => (async function(e) { throw new MyError(e); })("boom!!!"), MyError, "boom!!!");\nshouldThrowAsync(() => (async e => { throw new MyError(e) })("boom!!"), MyError, "boom!!");\nshouldThrowAsync(() => ({ async thrower(e) { throw new MyError(e); } }).thrower("boom!!!!"), MyError, "boom!!!!");\n\nfunction resolveLater(value) { return Promise.resolve(value); }\nfunction rejectLater(error) { return Promise.reject(error); }\n\n// Resume after Normal completion\nvar log = [];\nasync function resumeAfterNormal(value) {\n    log.push("start:" + value);\n    value = await resolveLater(value + 1);\n    log.push("resume:" + value);\n    value = await resolveLater(value + 1);\n    log.push("resume:" + value);\n    return value + 1;\n}\n\nshouldBeAsync(4, () => resumeAfterNormal(1));\nshouldBe("start:1 resume:2 resume:3", log.join(" "));\n\nvar O = {\n    async resumeAfterNormal(value) {\n        log.push("start:" + value);\n        value = await resolveLater(value + 1);\n        log.push("resume:" + value);\n        value = await resolveLater(value + 1);\n        log.push("resume:" + value);\n        return value + 1;\n    }\n};\nlog = [];\nshouldBeAsync(5, () => O.resumeAfterNormal(2));\nshouldBe("start:2 resume:3 resume:4", log.join(" "));\n\nvar resumeAfterNormalArrow = async (value) => {\n    log.push("start:" + value);\n    value = await resolveLater(value + 1);\n    log.push("resume:" + value);\n    value = await resolveLater(value + 1);\n    log.push("resume:" + value);\n    return value + 1;\n};\nlog = [];\nshouldBeAsync(6, () => resumeAfterNormalArrow(3));\nshouldBe("start:3 resume:4 resume:5", log.join(" "));\n\nvar resumeAfterNormalEval = AsyncFunction("value", `\n    log.push("start:" + value);\n    value = await resolveLater(value + 1);\n    log.push("resume:" + value);\n    value = await resolveLater(value + 1);\n    log.push("resume:" + value);\n    return value + 1;\n`);\nlog = [];\nshouldBeAsync(7, () => resumeAfterNormalEval(4));\nshouldBe("start:4 resume:5 resume:6", log.join(" "));\n\n// Resume after Throw completion\nasync function resumeAfterThrow(value) {\n    log.push("start:" + value);\n    try {\n        value = await rejectLater("throw1");\n    } catch (e) {\n        log.push("resume:" + e);\n    }\n    try {\n        value = await rejectLater("throw2");\n    } catch (e) {\n        log.push("resume:" + e);\n    }\n    return value + 1;\n}\n\nlog = [];\nshouldBeAsync(2, () => resumeAfterThrow(1));\nshouldBe("start:1 resume:throw1 resume:throw2", log.join(" "));\n\nvar O = {\n    async resumeAfterThrow(value) {\n        log.push("start:" + value);\n        try {\n            value = await rejectLater("throw1");\n        } catch (e) {\n            log.push("resume:" + e);\n        }\n        try {\n            value = await rejectLater("throw2");\n        } catch (e) {\n            log.push("resume:" + e);\n        }\n        return value + 1;\n    }\n}\nlog = [];\nshouldBeAsync(3, () => O.resumeAfterThrow(2));\nshouldBe("start:2 resume:throw1 resume:throw2", log.join(" "));\n\nvar resumeAfterThrowArrow = async (value) => {\n    log.push("start:" + value);\n    try {\n        value = await rejectLater("throw1");\n    } catch (e) {\n        log.push("resume:" + e);\n    }\n    try {\n        value = await rejectLater("throw2");\n    } catch (e) {\n        log.push("resume:" + e);\n    }\n    return value + 1;\n};\nlog = [];\nshouldBeAsync(4, () => resumeAfterThrowArrow(3));\nshouldBe("start:3 resume:throw1 resume:throw2", log.join(" "));\n\nvar resumeAfterThrowEval = AsyncFunction("value", `\n    log.push("start:" + value);\n    try {\n        value = await rejectLater("throw1");\n    } catch (e) {\n        log.push("resume:" + e);\n    }\n    try {\n        value = await rejectLater("throw2");\n    } catch (e) {\n        log.push("resume:" + e);\n    }\n    return value + 1;\n`);\nlog = [];\nshouldBeAsync(5, () => resumeAfterThrowEval(4));\nshouldBe("start:4 resume:throw1 resume:throw2", log.join(" "));\n\nvar awaitEpression = async (value) => {\n    log.push("start:" + value);\n    if (!await false)\n        log.push(\'step 1\');\n    var t = ~await true;\n    log.push(\'step 2 \' + t);\n\n    var t1 = +await Promise.resolve(12345);\n    log.push(\'step 3 \' + t1);\n\n    var t2 = -await 54321;\n    log.push(\'step 4 \' + t2);\n\n    var t3 = !!!!!await Promise.resolve(true);\n    log.push(\'step 5 \' + t3);\n\n    try {\n        var t4 = ++await 1;\n    } catch(e) {\n        if (e instanceof ReferenceError) {\n            log.push(\'step 6 \');\n        } \n    }\n\n    try {\n        var t5 = --await 1;\n    } catch(e) {\n        if (e instanceof ReferenceError) {\n            log.push(\'step 7\');\n        } \n    }\n\n    return void await \'test\';\n};\nlog = [];\n\nshouldBeAsync(undefined, () => awaitEpression(5));\nshouldBe("start:5 step 1 step 2 -2 step 3 12345 step 4 -54321 step 5 false step 6  step 7", log.join(" "));\n\n// MethoodDefinition SyntaxErrors\nshouldThrowSyntaxError("var obj = { async foo : true };", "Unexpected token \':\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async foo = true };", "Unexpected token \'=\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async foo , bar };", "Unexpected token \',\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async foo }", "Unexpected token \'}\'. Expected a parenthesis for argument list.");\n\nshouldThrowSyntaxError("var obj = { async 0 : true };", "Unexpected token \':\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async 0 = true };", "Unexpected token \'=\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async 0 , bar };", "Unexpected token \',\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async 0 }", "Unexpected token \'}\'. Expected a parenthesis for argument list.");\n\nshouldThrowSyntaxError("var obj = { async \'foo\' : true };", "Unexpected token \':\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async \'foo\' = true };", "Unexpected token \'=\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async \'foo\' , bar };", "Unexpected token \',\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async \'foo\' }", "Unexpected token \'}\'. Expected a parenthesis for argument list.");\n\nshouldThrowSyntaxError("var obj = { async [\'foo\'] : true };", "Unexpected token \':\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async [\'foo\'] = true };", "Unexpected token \'=\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async [\'foo\'] , bar };", "Unexpected token \',\'. Expected a parenthesis for argument list.");\nshouldThrowSyntaxError("var obj = { async [\'foo\'] }", "Unexpected token \'}\'. Expected a parenthesis for argument list.");\n\nshouldThrowSyntaxError("class C { async foo : true };", "Unexpected token \':\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async foo = true };", "Unexpected token \'=\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async foo , bar };", "Unexpected token \',\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async foo }", "Unexpected token \'}\'. Expected an opening \'(\' before a async method\'s parameter list.");\n\nshouldThrowSyntaxError("class C { async 0 : true };", "Unexpected token \':\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async 0 = true };", "Unexpected token \'=\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async 0 , bar };", "Unexpected token \',\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async 0 }", "Unexpected token \'}\'. Expected an opening \'(\' before a async method\'s parameter list.");\n\nshouldThrowSyntaxError("class C { async \'foo\' : true };", "Unexpected token \':\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async \'foo\' = true };", "Unexpected token \'=\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async \'foo\' , bar };", "Unexpected token \',\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async \'foo\' }", "Unexpected token \'}\'. Expected an opening \'(\' before a async method\'s parameter list.");\n\nshouldThrowSyntaxError("class C { async [\'foo\'] : true };", "Unexpected token \':\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async [\'foo\'] = true };", "Unexpected token \'=\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async [\'foo\'] , bar };", "Unexpected token \',\'. Expected an opening \'(\' before a async method\'s parameter list.");\nshouldThrowSyntaxError("class C { async [\'foo\'] }", "Unexpected token \'}\'. Expected an opening \'(\' before a async method\'s parameter list.");\n\n// Ensure awaited builtin Promise objects are themselves wrapped in a new Promise,\n// per https://tc39.github.io/ecma262/#sec-async-functions-abstract-operations-async-function-await\nlog = [];\nasync function awaitedPromisesAreWrapped() {\n    log.push("before");\n    await Promise.resolve();\n    log.push("after");\n}\nawaitedPromisesAreWrapped();\nPromise.resolve().then(() => log.push("Promise.resolve()"));\ndrainMicrotasks();\nshouldBe("before|Promise.resolve()|after", log.join("|"));' }
async-await-long-loop.js:SyntaxError: Unexpected token function
// Copyright (C) Copyright 2016 the v8 project authors. All rights reserved.

//@ runNoCJIT("--gcMaxHeapSize=2000000")


function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}


let out;

async function longLoop() {
    for (let i = 0; i < 10000; i++)
        await undefined;
    out = 1;
}

longLoop();

drainMicrotasks();

shouldBe(out, 1);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 6,
       column: 41 } ],
  output: '// Copyright (C) Copyright 2016 the v8 project authors. All rights reserved.\n\n//@ runNoCJIT("--gcMaxHeapSize=2000000")\n\n\nfunction shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\n\nlet out;\n\nasync function longLoop() {\n    for (let i = 0; i < 10000; i++)\n        await undefined;\n    out = 1;\n}\n\nlongLoop();\n\ndrainMicrotasks();\n\nshouldBe(out, 1);\n' }
async-await-mozilla.js:SyntaxError: Unexpected token function
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://moz.org/MPL/2.0/. */

function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, run, msg) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();
    if (hadError)
        throw actual;
    shouldBe(expected, actual, msg);
}

function shouldThrow(run, errorType, message) {
    let actual;
    var hadError = false;
    try {
        actual = run();
    } catch (e) {
        hadError = true;
        actual = e;
    }
    if (!hadError)
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");
    if (!(actual instanceof errorType))
        throw new Error("Expeced " + run + "() to throw " + errorType.name + " , but threw '" + actual + "'");
    if (message !== void 0 && actual.message !== message)
        throw new Error("Expected " + run + "() to throw '" + message + "', but threw '" + actual.message + "'");
}

function shouldThrowAsync(run, errorType, message) {
    let actual;
    var hadError = false;
    run().then(function(value) { actual = value; },
               function(error) { hadError = true; actual = error; });
    drainMicrotasks();
    if (!hadError)
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");
    if (!(actual instanceof errorType))
        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but threw '" + actual + "'");
    if (message !== void 0 && actual.message !== message)
        throw new Error("Expected " + run + "() to throw '" + message + "', but threw '" + actual.message + "'");
}

function assert(cond, msg = "") {
    if (!cond)
        throw new Error(msg);
}

function shouldThrowSyntaxError(str, message) {
    var hadError = false;
    try {
        eval(str);
    } catch (e) {
        if (e instanceof SyntaxError) {
            hadError = true;
            if (typeof message === "string")
                assert(e.message === message, "Expected '" + message + "' but threw '" + e.message + "'");
        }
    }
    assert(hadError, "Did not throw syntax error");
}

// semantics.js
(function mozSemantics() {

async function empty() {
}

async function simpleReturn() {
    return 1;
}

async function simpleAwait() {
    var result = await 2;
    return result;
}

async function simpleAwaitAsync() {
    var result = await simpleReturn();
    return 2 + result;
}

async function returnOtherAsync() {
    return 1 + await simpleAwaitAsync();
}

async function simpleThrower() {
    throw new Error();
}

async function delegatedThrower() {
    var val = await simpleThrower();
    return val;
}

async function tryCatch() {
    try {
        await delegatedThrower();
        return 'FAILED';
    } catch (_) {
        return 5;
    }
}

async function tryCatchThrow() {
    try {
        await delegatedThrower();
        return 'FAILED';
    } catch (_) {
        return delegatedThrower();
    }
}

async function wellFinally() {
    try {
        await delegatedThrower();
    } catch (_) {
        return 'FAILED';
    } finally {
        return 6;
    }
}

async function finallyMayFail() {
    try {
        await delegatedThrower();
    } catch (_) {
        return 5;
    } finally {
        return delegatedThrower();
    }
}

async function embedded() {
    async function inner() {
        return 7;
    }
    return await inner();
}

// recursion, it works!
async function fib(n) {
    return (n == 0 || n == 1) ? n : await fib(n - 1) + await fib(n - 2);
}

// mutual recursion
async function isOdd(n) {
    async function isEven(n) {
        return n === 0 || await isOdd(n - 1);
    }
    return n !== 0 && await isEven(n - 1);
}

// recursion, take three!
var hardcoreFib = async function fib2(n) {
    return (n == 0 || n == 1) ? n : await fib2(n - 1) + await fib2(n - 2);
}

var asyncExpr = async function() {
    return 10;
}

var namedAsyncExpr = async function simple() {
    return 11;
}

async function executionOrder() {
    var value = 0;
    async function first() {
        return (value = value === 0 ? 1 : value);
    }
    async function second() {
        return (value = value === 0 ? 2 : value);
    }
    async function third() {
        return (value = value === 0 ? 3 : value);
    }
    return await first() + await second() + await third() + 6;
}

async function miscellaneous() {
    if (arguments.length === 3 &&
        arguments.callee.name === "miscellaneous")
        return 14;
}

function thrower() {
    throw 15;
}

async function defaultArgs(arg = thrower()) {
}

// Async functions are not constructible
shouldThrow(() => {
    async function Person() {
    }
    new Person();
}, TypeError);

shouldBeAsync(undefined, empty);
shouldBeAsync(1, simpleReturn);
shouldBeAsync(2, simpleAwait);
shouldBeAsync(3, simpleAwaitAsync);
shouldBeAsync(4, returnOtherAsync);
shouldThrowAsync(simpleThrower, Error);
shouldBeAsync(5, tryCatch);
shouldBeAsync(6, wellFinally);
shouldThrowAsync(finallyMayFail, Error);
shouldBeAsync(7, embedded);
shouldBeAsync(8, () => fib(6));
shouldBeAsync(9, executionOrder);
shouldBeAsync(10, asyncExpr);
shouldBeAsync(11, namedAsyncExpr);
shouldBeAsync(12, () => isOdd(12).then(v => v ? "oops" : 12));
shouldBeAsync(13, () => hardcoreFib(7));
shouldBeAsync(14, () => miscellaneous(1, 2, 3));
shouldBeAsync(15, () => defaultArgs().catch(e => e));

})();

// methods.js
(function mozMethods() {

class X {
    constructor() {
        this.value = 42;
    }
    async getValue() {
        return this.value;
    }
    setValue(value) {
        this.value = value;
    }
    async increment() {
        var value = await this.getValue();
        this.setValue(value + 1);
        return this.getValue();
    }
    async getBaseClassName() {
        return 'X';
    }
    static async getStaticValue() {
        return 44;
    }
}

class Y extends X {
    async getBaseClassName() {
        return super.getBaseClassName();
    }
}

var objLiteral = {
    async get() {
        return 45;
    },
    someStuff: 5
};

var x = new X();
var y = new Y();

shouldBeAsync(42, () => x.getValue());
shouldBeAsync(43, () => x.increment());
shouldBeAsync(44, () => X.getStaticValue());
shouldBeAsync(45, () => objLiteral.get());
shouldBeAsync('X', () => y.getBaseClassName());

})();

(function mozFunctionNameInferrence() {

async function test() { }

var anon = async function() { }

shouldBe("test", test.name);
shouldBe("anon", anon.name);

})();

(function mozSyntaxErrors() {

shouldThrowSyntaxError("'use strict'; async function eval() {}");
shouldThrowSyntaxError("'use strict'; async function arguments() {}");
shouldThrowSyntaxError("async function a(k = super.prop) { }");
shouldThrowSyntaxError("async function a() { super.prop(); }");
shouldThrowSyntaxError("async function a() { super(); }");
shouldThrowSyntaxError("async function a(k = await 3) {}");

})();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 5,
       column: 41 } ],
  output: '/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://moz.org/MPL/2.0/. */\n\nfunction shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, run, msg) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n    if (hadError)\n        throw actual;\n    shouldBe(expected, actual, msg);\n}\n\nfunction shouldThrow(run, errorType, message) {\n    let actual;\n    var hadError = false;\n    try {\n        actual = run();\n    } catch (e) {\n        hadError = true;\n        actual = e;\n    }\n    if (!hadError)\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");\n    if (!(actual instanceof errorType))\n        throw new Error("Expeced " + run + "() to throw " + errorType.name + " , but threw \'" + actual + "\'");\n    if (message !== void 0 && actual.message !== message)\n        throw new Error("Expected " + run + "() to throw \'" + message + "\', but threw \'" + actual.message + "\'");\n}\n\nfunction shouldThrowAsync(run, errorType, message) {\n    let actual;\n    var hadError = false;\n    run().then(function(value) { actual = value; },\n               function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n    if (!hadError)\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but did not throw.");\n    if (!(actual instanceof errorType))\n        throw new Error("Expected " + run + "() to throw " + errorType.name + ", but threw \'" + actual + "\'");\n    if (message !== void 0 && actual.message !== message)\n        throw new Error("Expected " + run + "() to throw \'" + message + "\', but threw \'" + actual.message + "\'");\n}\n\nfunction assert(cond, msg = "") {\n    if (!cond)\n        throw new Error(msg);\n}\n\nfunction shouldThrowSyntaxError(str, message) {\n    var hadError = false;\n    try {\n        eval(str);\n    } catch (e) {\n        if (e instanceof SyntaxError) {\n            hadError = true;\n            if (typeof message === "string")\n                assert(e.message === message, "Expected \'" + message + "\' but threw \'" + e.message + "\'");\n        }\n    }\n    assert(hadError, "Did not throw syntax error");\n}\n\n// semantics.js\n(function mozSemantics() {\n\nasync function empty() {\n}\n\nasync function simpleReturn() {\n    return 1;\n}\n\nasync function simpleAwait() {\n    var result = await 2;\n    return result;\n}\n\nasync function simpleAwaitAsync() {\n    var result = await simpleReturn();\n    return 2 + result;\n}\n\nasync function returnOtherAsync() {\n    return 1 + await simpleAwaitAsync();\n}\n\nasync function simpleThrower() {\n    throw new Error();\n}\n\nasync function delegatedThrower() {\n    var val = await simpleThrower();\n    return val;\n}\n\nasync function tryCatch() {\n    try {\n        await delegatedThrower();\n        return \'FAILED\';\n    } catch (_) {\n        return 5;\n    }\n}\n\nasync function tryCatchThrow() {\n    try {\n        await delegatedThrower();\n        return \'FAILED\';\n    } catch (_) {\n        return delegatedThrower();\n    }\n}\n\nasync function wellFinally() {\n    try {\n        await delegatedThrower();\n    } catch (_) {\n        return \'FAILED\';\n    } finally {\n        return 6;\n    }\n}\n\nasync function finallyMayFail() {\n    try {\n        await delegatedThrower();\n    } catch (_) {\n        return 5;\n    } finally {\n        return delegatedThrower();\n    }\n}\n\nasync function embedded() {\n    async function inner() {\n        return 7;\n    }\n    return await inner();\n}\n\n// recursion, it works!\nasync function fib(n) {\n    return (n == 0 || n == 1) ? n : await fib(n - 1) + await fib(n - 2);\n}\n\n// mutual recursion\nasync function isOdd(n) {\n    async function isEven(n) {\n        return n === 0 || await isOdd(n - 1);\n    }\n    return n !== 0 && await isEven(n - 1);\n}\n\n// recursion, take three!\nvar hardcoreFib = async function fib2(n) {\n    return (n == 0 || n == 1) ? n : await fib2(n - 1) + await fib2(n - 2);\n}\n\nvar asyncExpr = async function() {\n    return 10;\n}\n\nvar namedAsyncExpr = async function simple() {\n    return 11;\n}\n\nasync function executionOrder() {\n    var value = 0;\n    async function first() {\n        return (value = value === 0 ? 1 : value);\n    }\n    async function second() {\n        return (value = value === 0 ? 2 : value);\n    }\n    async function third() {\n        return (value = value === 0 ? 3 : value);\n    }\n    return await first() + await second() + await third() + 6;\n}\n\nasync function miscellaneous() {\n    if (arguments.length === 3 &&\n        arguments.callee.name === "miscellaneous")\n        return 14;\n}\n\nfunction thrower() {\n    throw 15;\n}\n\nasync function defaultArgs(arg = thrower()) {\n}\n\n// Async functions are not constructible\nshouldThrow(() => {\n    async function Person() {\n    }\n    new Person();\n}, TypeError);\n\nshouldBeAsync(undefined, empty);\nshouldBeAsync(1, simpleReturn);\nshouldBeAsync(2, simpleAwait);\nshouldBeAsync(3, simpleAwaitAsync);\nshouldBeAsync(4, returnOtherAsync);\nshouldThrowAsync(simpleThrower, Error);\nshouldBeAsync(5, tryCatch);\nshouldBeAsync(6, wellFinally);\nshouldThrowAsync(finallyMayFail, Error);\nshouldBeAsync(7, embedded);\nshouldBeAsync(8, () => fib(6));\nshouldBeAsync(9, executionOrder);\nshouldBeAsync(10, asyncExpr);\nshouldBeAsync(11, namedAsyncExpr);\nshouldBeAsync(12, () => isOdd(12).then(v => v ? "oops" : 12));\nshouldBeAsync(13, () => hardcoreFib(7));\nshouldBeAsync(14, () => miscellaneous(1, 2, 3));\nshouldBeAsync(15, () => defaultArgs().catch(e => e));\n\n})();\n\n// methods.js\n(function mozMethods() {\n\nclass X {\n    constructor() {\n        this.value = 42;\n    }\n    async getValue() {\n        return this.value;\n    }\n    setValue(value) {\n        this.value = value;\n    }\n    async increment() {\n        var value = await this.getValue();\n        this.setValue(value + 1);\n        return this.getValue();\n    }\n    async getBaseClassName() {\n        return \'X\';\n    }\n    static async getStaticValue() {\n        return 44;\n    }\n}\n\nclass Y extends X {\n    async getBaseClassName() {\n        return super.getBaseClassName();\n    }\n}\n\nvar objLiteral = {\n    async get() {\n        return 45;\n    },\n    someStuff: 5\n};\n\nvar x = new X();\nvar y = new Y();\n\nshouldBeAsync(42, () => x.getValue());\nshouldBeAsync(43, () => x.increment());\nshouldBeAsync(44, () => X.getStaticValue());\nshouldBeAsync(45, () => objLiteral.get());\nshouldBeAsync(\'X\', () => y.getBaseClassName());\n\n})();\n\n(function mozFunctionNameInferrence() {\n\nasync function test() { }\n\nvar anon = async function() { }\n\nshouldBe("test", test.name);\nshouldBe("anon", anon.name);\n\n})();\n\n(function mozSyntaxErrors() {\n\nshouldThrowSyntaxError("\'use strict\'; async function eval() {}");\nshouldThrowSyntaxError("\'use strict\'; async function arguments() {}");\nshouldThrowSyntaxError("async function a(k = super.prop) { }");\nshouldThrowSyntaxError("async function a() { super.prop(); }");\nshouldThrowSyntaxError("async function a() { super(); }");\nshouldThrowSyntaxError("async function a(k = await 3) {}");\n\n})();\n' }
async-await-reserved-word.js:SyntaxError: Unexpected token function
function assert(cond, msg = "") {
    if (!cond)
        throw new Error(msg);
}
noInline(assert);

function shouldThrowSyntaxError(str, message) {
    var hadError = false;
    try {
        eval(str);
    } catch (e) {
        if (e instanceof SyntaxError) {
            hadError = true;
            if (typeof message === "string")
                assert(e.message === message, "Expected '" + message + "' but threw '" + e.message + "'");
        }
    }
    assert(hadError, "Did not throw syntax error");
}
noInline(shouldThrowSyntaxError);

var AsyncFunction = (async function() {}).constructor;

// AsyncFunctionExpression
shouldThrowSyntaxError("(async function() { var await; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("(async function() { var [await] = []; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("(async function() { var [...await] = []; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("(async function() { var {await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("(async function() { var {isAsync: await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("(async function() { var {isAsync: await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("(async function() { let await; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { let [await] = []; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { let [...await] = []; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { let {await} = {}; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { let {isAsync: await} = {}; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { let {isAsync: await} = {}; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { const await; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { const [await] = []; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { const [...await] = []; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { const {await} = {}; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { const {isAsync: await} = {}; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { const {isAsync: await} = {}; })", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("(async function() { function await() {} })", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("(async function() { async function await() {} })", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("(async function(await) {})", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("(async function f([await]) {})", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("(async function f([...await]) {})", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("(async function f(...await) {})", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("(async function f({await}) {})", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("(async function f({isAsync: await}) {})", "Cannot use 'await' as a parameter name in an async function.");

// AsyncFunctionDeclaration
shouldThrowSyntaxError("async function f() { var await; }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("async function f() { var [await] = []; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("async function f() { var [...await] = []; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("async function f() { var {await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("async function f() { var {isAsync: await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("async function f() { var {isAsync: await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("async function f() { let await; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { let [await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { let [...await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { let {await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { let {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { let {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { const await; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { const [await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { const [...await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { const {await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { const {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { const {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("async function f() { function await() {} }", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("async function f() { async function await() {} }", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("async function f(await) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("async function f([await]) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("async function f([...await]) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("async function f(...await) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("async function f({await}) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("async function f({isAsync: await}) {}", "Cannot use 'await' as a parameter name in an async function.");

// AsyncArrowFunction
shouldThrowSyntaxError("var f = async () => { var await; }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { var [await] = []; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { var [...await] = []; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { var {await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { var {isAsync: await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { var {isAsync: await} = {}; })", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { let await; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { let [await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { let [...await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { let {await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { let {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { let {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { const await; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { const [await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { const [...await] = []; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { const {await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { const {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { const {isAsync: await} = {}; }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var f = async () => { function await() {} }", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("var f = async () => { async function await() {} }", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("var f = async (await) => {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var f = async ([await]) => {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var f = async ([...await]) => {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var f = async (...await) => {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var f = async ({await}) => {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var f = async ({isAsync: await}) => {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var f = async await => {}", "Cannot use 'await' as a parameter name in an async function.");

// AsyncMethod
shouldThrowSyntaxError("var O = { async f() { var await; } }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { var [await] = []; } }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { var [...await] = []; } }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { var {await} = {}; } }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { var {isAsync: await} = {}; } }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { var {isAsync: await} = {}; } }", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { let await; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { let [await] = []; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { let [...await] = []; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { let {await} = {}; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { let {isAsync: await} = {}; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { let {isAsync: await} = {}; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { const await; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { const [await] = []; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { const [...await] = []; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { const {await} = {}; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { const {isAsync: await} = {}; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { const {isAsync: await} = {}; } }", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("var O = { async f() { function await() {} }", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("var O = { async f() { async function await() {} } }", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("var O = { async f(await) {} } ", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var O = { async f([await]) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var O = { async f([...await]) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var O = { async f(...await) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var O = { async f({await}) {}", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("var O = { async f({isAsync: await}) {}", "Cannot use 'await' as a parameter name in an async function.");

// AsyncFunction constructor
shouldThrowSyntaxError("AsyncFunction('var await;')", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('var [await] = [];')", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('var [...await] = [];')", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('var {await} = {};')", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('var {isAsync: await} = {};')", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('var {isAsync: await} = {};')", "Cannot use 'await' as a variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('let await;')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('let [await] = [];')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('let [...await] = [];')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('let {await} = {};')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('let {isAsync: await} = {};')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('let {isAsync: await} = {};')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('const await;')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('const [await] = [];')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('const [...await] = [];')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('const {await} = {};')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('const {isAsync: await} = {};')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('const {isAsync: await} = {};')", "Cannot use 'await' as a lexical variable name in an async function.");
shouldThrowSyntaxError("AsyncFunction('function await() {}')", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("AsyncFunction('async function await() {}')", "Cannot declare function named 'await' in an async function.");
shouldThrowSyntaxError("AsyncFunction('await', '')", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("AsyncFunction('[await]', '')", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("AsyncFunction('[...await]', '')", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("AsyncFunction('...await', '')", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("AsyncFunction('{await}', '')", "Cannot use 'await' as a parameter name in an async function.");
shouldThrowSyntaxError("AsyncFunction('{isAsync: await}', '')", "Cannot use 'await' as a parameter name in an async function.");

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function assert(cond, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 27 } ],
  output: 'function assert(cond, msg = "") {\n    if (!cond)\n        throw new Error(msg);\n}\nnoInline(assert);\n\nfunction shouldThrowSyntaxError(str, message) {\n    var hadError = false;\n    try {\n        eval(str);\n    } catch (e) {\n        if (e instanceof SyntaxError) {\n            hadError = true;\n            if (typeof message === "string")\n                assert(e.message === message, "Expected \'" + message + "\' but threw \'" + e.message + "\'");\n        }\n    }\n    assert(hadError, "Did not throw syntax error");\n}\nnoInline(shouldThrowSyntaxError);\n\nvar AsyncFunction = (async function() {}).constructor;\n\n// AsyncFunctionExpression\nshouldThrowSyntaxError("(async function() { var await; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("(async function() { var [await] = []; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("(async function() { var [...await] = []; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("(async function() { var {await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("(async function() { var {isAsync: await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("(async function() { var {isAsync: await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("(async function() { let await; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { let [await] = []; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { let [...await] = []; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { let {await} = {}; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { let {isAsync: await} = {}; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { let {isAsync: await} = {}; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { const await; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { const [await] = []; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { const [...await] = []; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { const {await} = {}; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { const {isAsync: await} = {}; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { const {isAsync: await} = {}; })", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("(async function() { function await() {} })", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("(async function() { async function await() {} })", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("(async function(await) {})", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("(async function f([await]) {})", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("(async function f([...await]) {})", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("(async function f(...await) {})", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("(async function f({await}) {})", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("(async function f({isAsync: await}) {})", "Cannot use \'await\' as a parameter name in an async function.");\n\n// AsyncFunctionDeclaration\nshouldThrowSyntaxError("async function f() { var await; }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("async function f() { var [await] = []; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("async function f() { var [...await] = []; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("async function f() { var {await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("async function f() { var {isAsync: await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("async function f() { var {isAsync: await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("async function f() { let await; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { let [await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { let [...await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { let {await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { let {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { let {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { const await; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { const [await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { const [...await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { const {await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { const {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { const {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("async function f() { function await() {} }", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("async function f() { async function await() {} }", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("async function f(await) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("async function f([await]) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("async function f([...await]) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("async function f(...await) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("async function f({await}) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("async function f({isAsync: await}) {}", "Cannot use \'await\' as a parameter name in an async function.");\n\n// AsyncArrowFunction\nshouldThrowSyntaxError("var f = async () => { var await; }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { var [await] = []; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { var [...await] = []; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { var {await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { var {isAsync: await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { var {isAsync: await} = {}; })", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { let await; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { let [await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { let [...await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { let {await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { let {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { let {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { const await; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { const [await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { const [...await] = []; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { const {await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { const {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { const {isAsync: await} = {}; }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var f = async () => { function await() {} }", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("var f = async () => { async function await() {} }", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("var f = async (await) => {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var f = async ([await]) => {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var f = async ([...await]) => {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var f = async (...await) => {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var f = async ({await}) => {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var f = async ({isAsync: await}) => {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var f = async await => {}", "Cannot use \'await\' as a parameter name in an async function.");\n\n// AsyncMethod\nshouldThrowSyntaxError("var O = { async f() { var await; } }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { var [await] = []; } }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { var [...await] = []; } }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { var {await} = {}; } }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { var {isAsync: await} = {}; } }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { var {isAsync: await} = {}; } }", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { let await; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { let [await] = []; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { let [...await] = []; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { let {await} = {}; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { let {isAsync: await} = {}; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { let {isAsync: await} = {}; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { const await; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { const [await] = []; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { const [...await] = []; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { const {await} = {}; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { const {isAsync: await} = {}; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { const {isAsync: await} = {}; } }", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("var O = { async f() { function await() {} }", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("var O = { async f() { async function await() {} } }", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("var O = { async f(await) {} } ", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var O = { async f([await]) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var O = { async f([...await]) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var O = { async f(...await) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var O = { async f({await}) {}", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("var O = { async f({isAsync: await}) {}", "Cannot use \'await\' as a parameter name in an async function.");\n\n// AsyncFunction constructor\nshouldThrowSyntaxError("AsyncFunction(\'var await;\')", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'var [await] = [];\')", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'var [...await] = [];\')", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'var {await} = {};\')", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'var {isAsync: await} = {};\')", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'var {isAsync: await} = {};\')", "Cannot use \'await\' as a variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'let await;\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'let [await] = [];\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'let [...await] = [];\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'let {await} = {};\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'let {isAsync: await} = {};\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'let {isAsync: await} = {};\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'const await;\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'const [await] = [];\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'const [...await] = [];\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'const {await} = {};\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'const {isAsync: await} = {};\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'const {isAsync: await} = {};\')", "Cannot use \'await\' as a lexical variable name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'function await() {}\')", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'async function await() {}\')", "Cannot declare function named \'await\' in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'await\', \'\')", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'[await]\', \'\')", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'[...await]\', \'\')", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'...await\', \'\')", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'{await}\', \'\')", "Cannot use \'await\' as a parameter name in an async function.");\nshouldThrowSyntaxError("AsyncFunction(\'{isAsync: await}\', \'\')", "Cannot use \'await\' as a parameter name in an async function.");\n' }
async-await-throw-loop.js:SyntaxError: Unexpected token function
// Copyright (C) Copyright 2016 the v8 project authors. All rights reserved.

//@ runNoCJIT("--gcMaxHeapSize=2000000")

function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}


let out;

async function thrower() { throw undefined; }

async function throwLoop() {
    for (let i = 0; i < 8000; i++) {
        try {
            await thrower();
        } catch (error) {
            void 0;
        }
    }
    out = 2;
}

throwLoop();

drainMicrotasks();

shouldBe(out, 2);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 5,
       column: 41 } ],
  output: '// Copyright (C) Copyright 2016 the v8 project authors. All rights reserved.\n\n//@ runNoCJIT("--gcMaxHeapSize=2000000")\n\nfunction shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\n\nlet out;\n\nasync function thrower() { throw undefined; }\n\nasync function throwLoop() {\n    for (let i = 0; i < 8000; i++) {\n        try {\n            await thrower();\n        } catch (error) {\n            void 0;\n        }\n    }\n    out = 2;\n}\n\nthrowLoop();\n\ndrainMicrotasks();\n\nshouldBe(out, 2);\n' }
async-function-create-nobaseline.js:SyntaxError: Unexpected token function
function test(cond)
{
    if (cond) {
        var func = async function () {};
        return func;
    }

    return 42;
}
noInline(test);

for (var i = 0; i < 1e4; ++i)
    test();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '        var func = async function () {};',
       message: 'Parsing error: Unexpected token function',
       line: 4,
       column: 26 } ],
  output: 'function test(cond)\n{\n    if (cond) {\n        var func = async function () {};\n        return func;\n    }\n\n    return 42;\n}\nnoInline(test);\n\nfor (var i = 0; i < 1e4; ++i)\n    test();\n' }
async-function-declaration-sinking-osrexit.js:SyntaxError: Unexpected token function
function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, promise, msg) {
    let actual;
    var hadError = false;
    promise.then(function(value) { actual = value; },
                 function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

var AsyncFunctionPrototype = async function(){}.__proto__;

function sink (p, q) {
    async function g(x) { return x; };
    if (p) { if (q) OSRExit(); return g; }
    async function f(x) { return x; };
    return f;
}
noInline(sink);

for (var i = 0; i < 10000; ++i) {
    var f = sink(true, false);
    shouldBe(f.__proto__, AsyncFunctionPrototype);
    shouldBeAsync(42, f(42));
}

// At this point, the function should be compiled down to the FTL

// Check that the function is properly allocated on OSR exit
var f = sink(true, true);
shouldBe(f.__proto__, AsyncFunctionPrototype);
shouldBeAsync(42, f(42));

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 41 } ],
  output: 'function shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, promise, msg) {\n    let actual;\n    var hadError = false;\n    promise.then(function(value) { actual = value; },\n                 function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nvar AsyncFunctionPrototype = async function(){}.__proto__;\n\nfunction sink (p, q) {\n    async function g(x) { return x; };\n    if (p) { if (q) OSRExit(); return g; }\n    async function f(x) { return x; };\n    return f;\n}\nnoInline(sink);\n\nfor (var i = 0; i < 10000; ++i) {\n    var f = sink(true, false);\n    shouldBe(f.__proto__, AsyncFunctionPrototype);\n    shouldBeAsync(42, f(42));\n}\n\n// At this point, the function should be compiled down to the FTL\n\n// Check that the function is properly allocated on OSR exit\nvar f = sink(true, true);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nshouldBeAsync(42, f(42));\n' }
async-function-create-optimized.js:SyntaxError: Unexpected token function
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

var AsyncFunctionPrototype = async function() {}.__proto__;

function testAsyncFunctionExpression()
{
    return async function()
    {
        await 42;
        return 1;
    };
}
noInline(testAsyncFunctionExpression);

function testAsyncFunctionDeclaration()
{
    async function asyncFn()
    {
        await 42;
        return 1;
    }

    return asyncFn;
}
noInline(testAsyncFunctionDeclaration);

function testAsyncArrowFunction()
{
    return async() =>
    {
        await 42;
        return 1;
    };
}
noInline(testAsyncArrowFunction);

for (var i = 0; i < 1e4; ++i) {
    shouldBe(testAsyncFunctionExpression().__proto__, AsyncFunctionPrototype);
    shouldBe(testAsyncFunctionDeclaration().__proto__, AsyncFunctionPrototype);
    shouldBe(testAsyncArrowFunction().__proto__, AsyncFunctionPrototype);
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var AsyncFunctionPrototype = async function() {}.__proto__;',
       message: 'Parsing error: Unexpected token function',
       line: 6,
       column: 36 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nvar AsyncFunctionPrototype = async function() {}.__proto__;\n\nfunction testAsyncFunctionExpression()\n{\n    return async function()\n    {\n        await 42;\n        return 1;\n    };\n}\nnoInline(testAsyncFunctionExpression);\n\nfunction testAsyncFunctionDeclaration()\n{\n    async function asyncFn()\n    {\n        await 42;\n        return 1;\n    }\n\n    return asyncFn;\n}\nnoInline(testAsyncFunctionDeclaration);\n\nfunction testAsyncArrowFunction()\n{\n    return async() =>\n    {\n        await 42;\n        return 1;\n    };\n}\nnoInline(testAsyncArrowFunction);\n\nfor (var i = 0; i < 1e4; ++i) {\n    shouldBe(testAsyncFunctionExpression().__proto__, AsyncFunctionPrototype);\n    shouldBe(testAsyncFunctionDeclaration().__proto__, AsyncFunctionPrototype);\n    shouldBe(testAsyncArrowFunction().__proto__, AsyncFunctionPrototype);\n}\n' }
async-function-declaration-sinking-no-double-allocate.js:SyntaxError: Unexpected token function
function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}
var AsyncFunctionPrototype = async function(){}.__proto__;

function call(o) { o.x = 3; }
noInline(call);

function sink (p, q) {
    async function f() { };
    if (p) {
        call(f); // Force allocation of f
        if (q) {
            OSRExit();
        }
        return f;
    }
    return { 'x': 2 };
}
noInline(sink);

for (var i = 0; i < 100000; ++i) {
    var o = sink(true, false);
    shouldBe(o.__proto__, AsyncFunctionPrototype);
    if (o.x != 3)
        throw "Error: expected o.x to be 2 but is " + result;
}

// At this point, the function should be compiled down to the FTL

// Check that the function is properly allocated on OSR exit
var f = sink(true, true);
shouldBe(f.__proto__, AsyncFunctionPrototype);
if (f.x != 3)
    throw "Error: expected o.x to be 3 but is " + result;

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 41 } ],
  output: 'function shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\nvar AsyncFunctionPrototype = async function(){}.__proto__;\n\nfunction call(o) { o.x = 3; }\nnoInline(call);\n\nfunction sink (p, q) {\n    async function f() { };\n    if (p) {\n        call(f); // Force allocation of f\n        if (q) {\n            OSRExit();\n        }\n        return f;\n    }\n    return { \'x\': 2 };\n}\nnoInline(sink);\n\nfor (var i = 0; i < 100000; ++i) {\n    var o = sink(true, false);\n    shouldBe(o.__proto__, AsyncFunctionPrototype);\n    if (o.x != 3)\n        throw "Error: expected o.x to be 2 but is " + result;\n}\n\n// At this point, the function should be compiled down to the FTL\n\n// Check that the function is properly allocated on OSR exit\nvar f = sink(true, true);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nif (f.x != 3)\n    throw "Error: expected o.x to be 3 but is " + result;\n' }
async-function-declaration-sinking-put.js:SyntaxError: Unexpected token function
function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, promise, msg) {
    let actual;
    var hadError = false;
    promise.then(function(value) { actual = value; },
                 function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

var AsyncFunctionPrototype = async function(){}.__proto__;

function sink (p, q) {
    async function g(x) { return x; };
    if (p) { if (q) g.inner = 42; return g; }
    async function f(x) { return x; };
    return f;
}
noInline(sink);

for (var i = 0; i < 10000; ++i) {
    var f = sink(true, true);
    shouldBe(f.__proto__, AsyncFunctionPrototype);
    shouldBeAsync(42, f(42));
}

// At this point, the function should be compiled down to the FTL

// Test the allocation on the implicit inner else branch
var f = sink(true, false);
shouldBe(f.__proto__, AsyncFunctionPrototype);
shouldBeAsync(12, f(12));

// Check that the allocation did not sink beyond the property assignment
var f = sink(true, true);
shouldBe(f.__proto__, AsyncFunctionPrototype);
var result = f.inner;
if (result !== 42)
    throw "Error: inner should be 42 but is " + result;

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 41 } ],
  output: 'function shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, promise, msg) {\n    let actual;\n    var hadError = false;\n    promise.then(function(value) { actual = value; },\n                 function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nvar AsyncFunctionPrototype = async function(){}.__proto__;\n\nfunction sink (p, q) {\n    async function g(x) { return x; };\n    if (p) { if (q) g.inner = 42; return g; }\n    async function f(x) { return x; };\n    return f;\n}\nnoInline(sink);\n\nfor (var i = 0; i < 10000; ++i) {\n    var f = sink(true, true);\n    shouldBe(f.__proto__, AsyncFunctionPrototype);\n    shouldBeAsync(42, f(42));\n}\n\n// At this point, the function should be compiled down to the FTL\n\n// Test the allocation on the implicit inner else branch\nvar f = sink(true, false);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nshouldBeAsync(12, f(12));\n\n// Check that the allocation did not sink beyond the property assignment\nvar f = sink(true, true);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nvar result = f.inner;\nif (result !== 42)\n    throw "Error: inner should be 42 but is " + result;\n' }
async-function-expression-sinking-no-double-allocate.js:SyntaxError: Unexpected token function
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}
var AsyncFunctionPrototype = async function(){}.__proto__;

function call(o) { o.x = 3; }
noInline(call);

function sink (p, q) {
    var f = async function() { };
    if (p) {
        call(f); // Force allocation of f
        if (q) {
            OSRExit();
        }
        return f;
    }
    return { 'x': 2 };
}
noInline(sink);

for (var i = 0; i < 100000; ++i) {
    var o = sink(true, false);
    shouldBe(o.__proto__, AsyncFunctionPrototype);
    if (o.x != 3)
        throw "Error: expected o.x to be 2 but is " + result;
}

// At this point, the function should be compiled down to the FTL

// Check that the function is properly allocated on OSR exit
var f = sink(true, true);
shouldBe(f.__proto__, AsyncFunctionPrototype);
if (f.x != 3)
    throw "Error: expected o.x to be 3 but is " + result;

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var AsyncFunctionPrototype = async function(){}.__proto__;',
       message: 'Parsing error: Unexpected token function',
       line: 5,
       column: 36 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\nvar AsyncFunctionPrototype = async function(){}.__proto__;\n\nfunction call(o) { o.x = 3; }\nnoInline(call);\n\nfunction sink (p, q) {\n    var f = async function() { };\n    if (p) {\n        call(f); // Force allocation of f\n        if (q) {\n            OSRExit();\n        }\n        return f;\n    }\n    return { \'x\': 2 };\n}\nnoInline(sink);\n\nfor (var i = 0; i < 100000; ++i) {\n    var o = sink(true, false);\n    shouldBe(o.__proto__, AsyncFunctionPrototype);\n    if (o.x != 3)\n        throw "Error: expected o.x to be 2 but is " + result;\n}\n\n// At this point, the function should be compiled down to the FTL\n\n// Check that the function is properly allocated on OSR exit\nvar f = sink(true, true);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nif (f.x != 3)\n    throw "Error: expected o.x to be 3 but is " + result;\n' }
async-generator-assertion.js:SyntaxError: Unexpected token function
function assert(b) {
    if (!b)
        throw new Error("Bad");
}

async function* asyncIterator() {
    yield 42;
}

function test1() {
    let p = asyncIterator();
    p.next().then((x) => {
        assert(x.value === 42);
        assert(x.done === false);
    });
    p.__proto__ = {};
    assert(p.next === undefined);
}
test1();

let error = null;
async function test2() {
    let p2 = asyncIterator();
    p2.__proto__ = {};
    try {
        for await (let x of p2) {
            throw new Error("Bad!");
        }
    } 
    catch(e) {
        error = e;
    }
}
test2();
assert(error instanceof TypeError);
assert(error.message === "undefined is not a function (near '...x of p2...')");

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'async function* asyncIterator() {',
       message: 'Parsing error: Unexpected token function',
       line: 6,
       column: 7 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad");\n}\n\nasync function* asyncIterator() {\n    yield 42;\n}\n\nfunction test1() {\n    let p = asyncIterator();\n    p.next().then((x) => {\n        assert(x.value === 42);\n        assert(x.done === false);\n    });\n    p.__proto__ = {};\n    assert(p.next === undefined);\n}\ntest1();\n\nlet error = null;\nasync function test2() {\n    let p2 = asyncIterator();\n    p2.__proto__ = {};\n    try {\n        for await (let x of p2) {\n            throw new Error("Bad!");\n        }\n    } \n    catch(e) {\n        error = e;\n    }\n}\ntest2();\nassert(error instanceof TypeError);\nassert(error.message === "undefined is not a function (near \'...x of p2...\')");\n' }
async-function-expression-sinking-osrexit.js:SyntaxError: Unexpected token function
function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}
function shouldBeAsync(expected, promise, msg) {
    let actual;
    var hadError = false;
    promise.then(function(value) { actual = value; },
                 function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

var AsyncFunctionPrototype = async function(){}.__proto__;

function sink (p, q) {
    var g = async function (x) { return x; };
    if (p) { if (q) OSRExit(); return g; }
    return async function (x) { return x; };
}
noInline(sink);

for (var i = 0; i < 10000; ++i) {
    var f = sink(true, false);
    shouldBe(f.__proto__, AsyncFunctionPrototype);
    shouldBeAsync(42, f(42));
}

// At this point, the function should be compiled down to the FTL

// Check that the function is properly allocated on OSR exit
var f = sink(true, true);
shouldBe(f.__proto__, AsyncFunctionPrototype);
shouldBeAsync(42, f(42));

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 41 } ],
  output: 'function shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\nfunction shouldBeAsync(expected, promise, msg) {\n    let actual;\n    var hadError = false;\n    promise.then(function(value) { actual = value; },\n                 function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nvar AsyncFunctionPrototype = async function(){}.__proto__;\n\nfunction sink (p, q) {\n    var g = async function (x) { return x; };\n    if (p) { if (q) OSRExit(); return g; }\n    return async function (x) { return x; };\n}\nnoInline(sink);\n\nfor (var i = 0; i < 10000; ++i) {\n    var f = sink(true, false);\n    shouldBe(f.__proto__, AsyncFunctionPrototype);\n    shouldBeAsync(42, f(42));\n}\n\n// At this point, the function should be compiled down to the FTL\n\n// Check that the function is properly allocated on OSR exit\nvar f = sink(true, true);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nshouldBeAsync(42, f(42));\n' }
async-function-expression-sinking-put.js:SyntaxError: Unexpected token function
function shouldBe(expected, actual, msg = "") {
    if (msg)
        msg = " for " + msg;
    if (actual !== expected)
        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);
}

function shouldBeAsync(expected, promise, msg) {
    let actual;
    var hadError = false;
    promise.then(function(value) { actual = value; },
                 function(error) { hadError = true; actual = error; });
    drainMicrotasks();

    if (hadError)
        throw actual;

    shouldBe(expected, actual, msg);
}

var AsyncFunctionPrototype = async function(){}.__proto__;

function sink (p, q) {
    var g = async function(x) { return x; };
    if (p) { if (q) g.inner = 42; return g; }
    return async function(x) { return x; };
}
noInline(sink);

for (var i = 0; i < 10000; ++i) {
    var f = sink(true, true);
    shouldBe(f.__proto__, AsyncFunctionPrototype);
    shouldBeAsync(42, f(42));
}

// At this point, the function should be compiled down to the FTL

// Test the allocation on the implicit inner else branch
var f = sink(true, false);
shouldBe(f.__proto__, AsyncFunctionPrototype);
shouldBeAsync(12, f(12));

// Check that the allocation did not sink beyond the property assignment
var f = sink(true, true);
shouldBe(f.__proto__, AsyncFunctionPrototype);
shouldBe(42, f.inner);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function shouldBe(expected, actual, msg = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 41 } ],
  output: 'function shouldBe(expected, actual, msg = "") {\n    if (msg)\n        msg = " for " + msg;\n    if (actual !== expected)\n        throw new Error("bad value" + msg + ": " + actual + ". Expected " + expected);\n}\n\nfunction shouldBeAsync(expected, promise, msg) {\n    let actual;\n    var hadError = false;\n    promise.then(function(value) { actual = value; },\n                 function(error) { hadError = true; actual = error; });\n    drainMicrotasks();\n\n    if (hadError)\n        throw actual;\n\n    shouldBe(expected, actual, msg);\n}\n\nvar AsyncFunctionPrototype = async function(){}.__proto__;\n\nfunction sink (p, q) {\n    var g = async function(x) { return x; };\n    if (p) { if (q) g.inner = 42; return g; }\n    return async function(x) { return x; };\n}\nnoInline(sink);\n\nfor (var i = 0; i < 10000; ++i) {\n    var f = sink(true, true);\n    shouldBe(f.__proto__, AsyncFunctionPrototype);\n    shouldBeAsync(42, f(42));\n}\n\n// At this point, the function should be compiled down to the FTL\n\n// Test the allocation on the implicit inner else branch\nvar f = sink(true, false);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nshouldBeAsync(12, f(12));\n\n// Check that the allocation did not sink beyond the property assignment\nvar f = sink(true, true);\nshouldBe(f.__proto__, AsyncFunctionPrototype);\nshouldBe(42, f.inner);\n' }
async-iteration-async-from-sync.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};

const Logger = function () {
    var log = [];

    this.logEvent = (type, value, done) => {
        log.push({ type, value, done});
    };
    this.logFulfilledEvent = (value, done) => {
        this.logEvent('fulfilled', value, done);
    };
    this.logRejectEvent = error => {
        this.logEvent('reject', error.toString(), true);
    };
    this.logCatchEvent = value => {
        this.logEvent('catch', value, true);
    };
    this.getLogger = () => log;

    this.clear = () => {
        log = [];
    }
};

const fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);
const rejectSpy = logger => error => logger.logRejectEvent(error);
const catchSpy = logger => error => logger.logCatchEvent(error);

const assertLogger = function (loggerObject) {
    const logger = loggerObject.getLogger();

    var _assertLogger = function () {
        let index = 0;

        const isNotOutOfLength = () => {
            assert(index < logger.length, true, `Index is greater then log length`);   
        }

        this.fullfilled = function (expectedValue, message = 'on fulfill') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.fullfilledDone = function (expectedValue, message = 'on fulfill with done true') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.rejected = function (error, message = 'on reject') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'reject', msg);
            assert(step.value, error.toString(), msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.catched = function (expectedError, message = 'on catch') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'catch', msg);
            assert(step.value, expectedError, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.isFinal = function (message = '') {
            assert(index, logger.length, `expected final step: ${message}`);
        }; 
    }; 
    
    return new _assertLogger();
};

const getPromise = promiseHolder => {
    return new Promise((resolve, reject) => {
        promiseHolder.resolve = resolve;
        promiseHolder.reject = reject;
    });
};

var logger = new Logger();
const someValue = 'some-value';
const errorMessage = 'error-message';

function * foo(value) {
  let re = yield '1:' + value;
  re = yield '2:' + re;
  re = yield '3:' + re;
  return 'end foo:' + re;
}

async function * boo(value) {
  let reply = yield '0:' + value;
  reply = yield* foo(reply);
  yield '4:' + reply;
}

var b = boo('init');
const errorprint = error => print(error);
b.next('0').then(fulfillSpy(logger), errorprint);
b.next('1').then(fulfillSpy(logger), errorprint);
b.next('2').then(fulfillSpy(logger), errorprint);
b.next('3').then(fulfillSpy(logger), errorprint);
b.next('4').then(fulfillSpy(logger), errorprint);
b.next('5').then(fulfillSpy(logger), errorprint);

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:init')
    .fullfilled('1:1')
    .fullfilled('2:2')
    .fullfilled('3:3')
    .fullfilled('4:end foo:4')
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
var b2 = boo(':value');

b2.next(':0').then(fulfillSpy(logger));
b2.next(':1').then(fulfillSpy(logger), rejectSpy(logger));
b2.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
b2.next(':2').then(fulfillSpy(logger));
b2.next(':3').then(fulfillSpy(logger));
b2.next(':4').then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0::value')
    .fullfilled('1::1')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
var b2 = boo('#value');

b2.next('#0').then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#1').then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#2').then(fulfillSpy(logger), rejectSpy(logger));
b2.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#3').then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#4').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:#value')
    .fullfilled('1:#1')
    .fullfilled('2:#2')
    .rejected(new Error(errorMessage)) // TODO: Check if this correct
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

function * bar() {
  yield '1';
  yield '2';
  throw new Error(errorMessage);
  yield '3';
  return 'end foo';
}

async function * baz() {
  yield '0';
  yield* bar();
  yield '4';
}

logger.clear();
var bz1 = baz();

bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
let promiseHolder = {};

function *joo() {
    yield '1';
    yield getPromise(promiseHolder);
}

async function *goo () {
    yield '0';
    yield* joo();
    yield '3';
}

let g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.resolve('2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('2')
    .fullfilled('3')
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('#2')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('#2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();
{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\n\nconst Logger = function () {\n    var log = [];\n\n    this.logEvent = (type, value, done) => {\n        log.push({ type, value, done});\n    };\n    this.logFulfilledEvent = (value, done) => {\n        this.logEvent(\'fulfilled\', value, done);\n    };\n    this.logRejectEvent = error => {\n        this.logEvent(\'reject\', error.toString(), true);\n    };\n    this.logCatchEvent = value => {\n        this.logEvent(\'catch\', value, true);\n    };\n    this.getLogger = () => log;\n\n    this.clear = () => {\n        log = [];\n    }\n};\n\nconst fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);\nconst rejectSpy = logger => error => logger.logRejectEvent(error);\nconst catchSpy = logger => error => logger.logCatchEvent(error);\n\nconst assertLogger = function (loggerObject) {\n    const logger = loggerObject.getLogger();\n\n    var _assertLogger = function () {\n        let index = 0;\n\n        const isNotOutOfLength = () => {\n            assert(index < logger.length, true, `Index is greater then log length`);   \n        }\n\n        this.fullfilled = function (expectedValue, message = \'on fulfill\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.fullfilledDone = function (expectedValue, message = \'on fulfill with done true\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.rejected = function (error, message = \'on reject\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'reject\', msg);\n            assert(step.value, error.toString(), msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.catched = function (expectedError, message = \'on catch\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'catch\', msg);\n            assert(step.value, expectedError, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.isFinal = function (message = \'\') {\n            assert(index, logger.length, `expected final step: ${message}`);\n        }; \n    }; \n    \n    return new _assertLogger();\n};\n\nconst getPromise = promiseHolder => {\n    return new Promise((resolve, reject) => {\n        promiseHolder.resolve = resolve;\n        promiseHolder.reject = reject;\n    });\n};\n\nvar logger = new Logger();\nconst someValue = \'some-value\';\nconst errorMessage = \'error-message\';\n\nfunction * foo(value) {\n  let re = yield \'1:\' + value;\n  re = yield \'2:\' + re;\n  re = yield \'3:\' + re;\n  return \'end foo:\' + re;\n}\n\nasync function * boo(value) {\n  let reply = yield \'0:\' + value;\n  reply = yield* foo(reply);\n  yield \'4:\' + reply;\n}\n\nvar b = boo(\'init\');\nconst errorprint = error => print(error);\nb.next(\'0\').then(fulfillSpy(logger), errorprint);\nb.next(\'1\').then(fulfillSpy(logger), errorprint);\nb.next(\'2\').then(fulfillSpy(logger), errorprint);\nb.next(\'3\').then(fulfillSpy(logger), errorprint);\nb.next(\'4\').then(fulfillSpy(logger), errorprint);\nb.next(\'5\').then(fulfillSpy(logger), errorprint);\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:init\')\n    .fullfilled(\'1:1\')\n    .fullfilled(\'2:2\')\n    .fullfilled(\'3:3\')\n    .fullfilled(\'4:end foo:4\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nvar b2 = boo(\':value\');\n\nb2.next(\':0\').then(fulfillSpy(logger));\nb2.next(\':1\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\':2\').then(fulfillSpy(logger));\nb2.next(\':3\').then(fulfillSpy(logger));\nb2.next(\':4\').then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0::value\')\n    .fullfilled(\'1::1\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nvar b2 = boo(\'#value\');\n\nb2.next(\'#0\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#1\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#2\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#3\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#4\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:#value\')\n    .fullfilled(\'1:#1\')\n    .fullfilled(\'2:#2\')\n    .rejected(new Error(errorMessage)) // TODO: Check if this correct\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nfunction * bar() {\n  yield \'1\';\n  yield \'2\';\n  throw new Error(errorMessage);\n  yield \'3\';\n  return \'end foo\';\n}\n\nasync function * baz() {\n  yield \'0\';\n  yield* bar();\n  yield \'4\';\n}\n\nlogger.clear();\nvar bz1 = baz();\n\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nlet promiseHolder = {};\n\nfunction *joo() {\n    yield \'1\';\n    yield getPromise(promiseHolder);\n}\n\nasync function *goo () {\n    yield \'0\';\n    yield* joo();\n    yield \'3\';\n}\n\nlet g = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.resolve(\'2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'2\')\n    .fullfilled(\'3\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'#2\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'#2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();' }
async-iteration-evaluation.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};

let error = false; 

async function * foo(value = obj) {
    yield '1';
    return 'end';
}

try {
    var f = foo();
} catch(e) {
    error = e instanceof ReferenceError;
}

assert(error, true, 'Error in arguments declaration should to error during evaluation of async generator.');
{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\n\nlet error = false; \n\nasync function * foo(value = obj) {\n    yield \'1\';\n    return \'end\';\n}\n\ntry {\n    var f = foo();\n} catch(e) {\n    error = e instanceof ReferenceError;\n}\n\nassert(error, true, \'Error in arguments declaration should to error during evaluation of async generator.\');' }
async-iteration-basic.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};

const Logger = function () {
    var log = [];

    this.logEvent = (type, value, done) => {
        log.push({ type, value, done});
    };
    this.logFulfilledEvent = (value, done) => {
        this.logEvent('fulfilled', value, done);
    };
    this.logRejectEvent = error => {
        this.logEvent('reject', error.toString(), true);
    };
    this.logCatchEvent = value => {
        this.logEvent('catch', value, true);
    };
    this.getLogger = () => log;

    this.clear = () => {
        log = [];
    }
};

const fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);
const rejectSpy = logger => error => logger.logRejectEvent(error);
const catchSpy = logger => error => logger.logCatchEvent(error);

const assertLogger = function (loggerObject) {
    const logger = loggerObject.getLogger();

    var _assertLogger = function () {
        let index = 0;

        const isNotOutOfLength = () => {
            assert(index < logger.length, true, `Index is greater then log length`);   
        }

        this.fullfilled = function (expectedValue, message = 'on fulfill') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.fullfilledDone = function (expectedValue, message = 'on fulfill with done true') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.rejected = function (error, message = 'on reject') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'reject', msg);
            assert(step.value, error.toString(), msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.catched = function (expectedError, message = 'on catch') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'catch', msg);
            assert(step.value, expectedError, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.isFinal = function (message = '') {
            assert(index, logger.length, `expected final step: ${message}`);
        }; 
    }; 
    
    return new _assertLogger();
};

const getPromise = promiseHolder => {
    return new Promise((resolve, reject) => {
        promiseHolder.resolve = resolve;
        promiseHolder.reject = reject;
    });
};

async function*generator () {
    yield 42;
}

var passed = false;
var iterator = generator();

iterator.next().then(function(step) {
    if(iterator[Symbol.asyncIterator]() === iterator && step.done === false && step.value === 42) passed = true;
});

drainMicrotasks();

assert(passed, true, '');

assert(generator[Symbol.toStringTag], 'AsyncGeneratorFunction');
assert(Object.prototype.toString.call(generator), '[object AsyncGeneratorFunction]');


var holder = {};

var promise = getPromise(holder);
var logger = new Logger();

async function * baz(value) {
    var t = await promise;
    let reply = yield t + ' data-0' + value;
    let last = yield t + ' data-1' + reply;
    return 'data-result' + last;
}

var bz1 = baz(':init');

bz1.next(':0').then(fulfillSpy(logger), rejectSpy(logger));
bz1.next(':1').then(fulfillSpy(logger), rejectSpy(logger));
bz1.next(':2').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .isFinal();

holder.resolve('abcd');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-0:init')
    .fullfilled('abcd data-1:1')
    .fullfilledDone('data-result:2')
    .isFinal();

logger.clear();

promise = getPromise(holder);

var bz2 = baz(':init');

bz2.next(':0').then(fulfillSpy(logger), rejectSpy(logger));
bz2.next(':1').then(fulfillSpy(logger), rejectSpy(logger));
bz2.next(':2').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .isFinal();

holder.reject('abcd');

drainMicrotasks();

assertLogger(logger)
    .rejected('abcd')
    .fullfilledDone()
    .fullfilledDone()
    .isFinal();

var holder1 = {}; holder2 = {};
var promise1 = getPromise(holder1);
var promise2 = getPromise(holder2);

logger.clear();

async function *boo() {
    var t1 = await promise1;
    yield t1 + ' data-1';
    yield t1 + ' data-2';
    var t2 = await promise2;
    yield t2 + ' data-3';
    yield t2 + ' data-4';
    return 'data-5';
};

var b = boo();

b.next().then(fulfillSpy(logger));
b.next().then(fulfillSpy(logger));
b.next().then(fulfillSpy(logger));
b.next().then(fulfillSpy(logger));
b.next().then(fulfillSpy(logger));
b.next().then(fulfillSpy(logger));

assertLogger(logger)
    .isFinal('async generator should not resolve any promise until await is no resolved');

holder1.resolve('abcd');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-1')
    .fullfilled('abcd data-2')
    .isFinal();

holder2.resolve('efgh');
drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-1')
    .fullfilled('abcd data-2')
    .fullfilled('efgh data-3')
    .fullfilled('efgh data-4')
    .fullfilledDone('data-5')
    .fullfilledDone(undefined, error => print(error))
    .isFinal();

holder = {};

promise = getPromise(holder);

async function *foo() {
    var t = await 'abcd';
    yield t + ' data-5';
    var t2 = await promise;
    yield t2 + ' data-6';
};

logger.clear();

var f = foo();

f.next().then(fulfillSpy(logger));
f.next().then(fulfillSpy(logger));
f.next().then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-5')
    .isFinal('async generator should not resolve any promise until await is not resolved');

holder.resolve('xyz');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-5')
    .fullfilled('xyz data-6')
    .fullfilledDone(undefined)
    .isFinal('async generator should not resolve any promise until await is not resolved');

holder = {};
promise = getPromise(holder);

async function *goo() {
    yield 'data-5';
    var t = await promise;
    yield t + ' data-6';
    yield t + ' data-7';
};

logger.clear();
var errorText = 'error-reject';
var g = goo();

drainMicrotasks();

g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('data-5')
    .isFinal('async generator should not resolve any promise until await is not resolved');

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

assertLogger(logger)
    .fullfilled('data-5')
    .isFinal('async generator should not resolve any promise until await is not resolved');

holder.reject(errorText);

drainMicrotasks();

assertLogger(logger)
    .fullfilled('data-5')
    .rejected(errorText)
    .fullfilledDone(undefined, 'After reject all resolved value have undefined')
    .isFinal();

/* Method in class */

const someText = 'foo';
const resolveText = 'bar';

logger.clear();

holder = {};
promise = getPromise(holder);

class A { 
    async * foo() { yield someText; } 
    async * boo() { var text = await promise; yield text + someText; }
}
var a = new A;
var gf = a.foo();

gf.next().then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(someText)
    .isFinal();

const gb = a.boo();

gb.next().then(fulfillSpy(logger));

assertLogger(logger)
    .fullfilled(someText)
    .isFinal();

holder.resolve(resolveText);

drainMicrotasks();

assertLogger(logger)
    .fullfilled(someText)
    .fullfilled(resolveText + someText)
    .isFinal();

/* Async generator function expression */
logger.clear();
holder = {};
promise = getPromise(holder);

var asyncGenExp = async function *() { var t = await promise; yield t + someText + someText; };

var gAsyncGenExp = asyncGenExp();

gAsyncGenExp.next().then(fulfillSpy(logger));

holder.resolve(resolveText);
drainMicrotasks();

assertLogger(logger)
    .fullfilled(resolveText + someText + someText)
    .isFinal();

logger.clear();

/*Test throw*/
async function *joo() {
    yield 'data-1';
    yield 'data-2';
    yield 'data-3';
};

var j = joo();
var errorTextInFunction = "ErrorInFunction";
const errorWrongGenerator = "|this| should be an async generator";
let errorRaised = false;

j.next()
.then(function(value) {
    fulfillSpy(logger)(value);
    return j.throw(new Error(errorTextInFunction));
})
.then(function (value) {
    fulfillSpy(logger)(value);
}, function (error) {
    rejectSpy(logger)(error);
    return j.next();
})
.then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('data-1')
    .rejected((new Error(errorTextInFunction)).toString())
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
var j1 = joo();

j1.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));
j1.next().then(fulfillSpy(logger), rejectSpy(logger));
j1.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new Error(errorText))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
var j2 = joo();

const returnValue = 'return-value';

j1.return(returnValue).then(fulfillSpy(logger), rejectSpy(logger));
j1.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));
j1.next().then(fulfillSpy(logger), rejectSpy(logger));
j1.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilledDone(returnValue)
    .rejected(new Error(errorText))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
let j3 = joo();

j3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));
drainMicrotasks();

assertLogger(logger)
    .rejected(new TypeError(errorWrongGenerator))
    .isFinal();

logger.clear();
j3 = joo();

j3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new TypeError(errorWrongGenerator))
    .fullfilled('data-1')
    .fullfilled('data-2')
    .fullfilled('data-3')
    .isFinal();

logger.clear();
j3 = joo();

j3.next().then(fulfillSpy(logger), rejectSpy(logger));
j3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new TypeError(errorWrongGenerator))
    .fullfilled('data-1')
    .fullfilled('data-2')
    .fullfilled('data-3')
    .isFinal();

logger.clear();
j3 = joo();

j3.next().then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));
j3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));
j3.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new TypeError(errorWrongGenerator))
    .fullfilled('data-1')
    .fullfilled('data-2')
    .fullfilled('data-3')
    .isFinal();

logger.clear();
j3 = joo();

j3.next.call({}).catch(rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new TypeError(errorWrongGenerator))

logger.clear();
j3 = joo();
j3.next.call('string').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new TypeError(errorWrongGenerator))
    .isFinal();

logger.clear();
j3 = joo();
let gen = generator();
j3.next.call(gen).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(42)
    .isFinal();

logger.clear();
holder = {};
promise = getPromise(holder);

async function *koo() {
    var t = await 'abcd';
    yield t + ' data-first';
    var t2 = await promise;
    yield t2 + ' data-second';
    yield t2 + ' data-third';
};

const k1 = koo();

k1.next().then(fulfillSpy(logger));
k1.next().then(fulfillSpy(logger));

k1.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));
k1.next().then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-first')
    .isFinal();

holder.resolve('xyz');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-first')
    .fullfilled('xyz data-second')
    .rejected(new Error(errorText))
    .fullfilledDone(undefined)
    .isFinal();


logger.clear();
holder = {};
promise = getPromise(holder);

const k2 = koo();

k2.next().then(fulfillSpy(logger));
k2.next().then(fulfillSpy(logger));

k2.return(returnValue).then(fulfillSpy(logger));

holder.resolve('xyz');

k2.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));
k2.next().then(fulfillSpy(logger));
k2.next().then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abcd data-first')
    .fullfilled('xyz data-second')
    .fullfilledDone(returnValue)
    .rejected(new Error(errorText))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();


logger.clear();
holder = {};
promise = getPromise(holder);

async function *loo() {
    var t = await promise;
    throw new Error(errorText);
    yield t + 'data-first';
    yield t + 'data-second';
};

const l1 = loo();

l1.next().then(fulfillSpy(logger), rejectSpy(logger));
l1.next().then(fulfillSpy(logger), rejectSpy(logger));
l1.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .isFinal();

holder.resolve('qwe');

drainMicrotasks();

assertLogger(logger)
    .rejected(new Error(errorText))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
holder = {};
promise = getPromise(holder);

const l2 = loo();

l2.throw(new Error('another error')).then(fulfillSpy(logger), rejectSpy(logger));
l2.next().then(fulfillSpy(logger), rejectSpy(logger));
l2.next().then(fulfillSpy(logger), rejectSpy(logger));

holder.resolve('abc');

drainMicrotasks();

assertLogger(logger)
    .rejected(new Error('another error'))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
holder = {};
promise = getPromise(holder);

const l3 = loo();

l3.return(someText).then(fulfillSpy(logger), rejectSpy(logger));
l3.next().then(fulfillSpy(logger), rejectSpy(logger));
l3.next().then(fulfillSpy(logger), rejectSpy(logger));

holder.resolve(resolveText);

drainMicrotasks();

assertLogger(logger)
    .fullfilledDone(someText)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

async function *moo() {
    throw new Error(errorText);
    yield t + 'data-first';
    yield t + 'data-second';
};

const m1 = moo();

m1.next().then(fulfillSpy(logger), rejectSpy(logger));
m1.next().then(fulfillSpy(logger), rejectSpy(logger));
m1.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new Error(errorText))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

const m2 = moo();

m2.throw(new Error('another error')).then(fulfillSpy(logger), rejectSpy(logger));
m2.next().then(fulfillSpy(logger), rejectSpy(logger));
m2.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .rejected(new Error('another error'))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

const m3 = moo();

m3.return(someText).then(fulfillSpy(logger), rejectSpy(logger));
m3.next().then(fulfillSpy(logger), rejectSpy(logger));
m3.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilledDone(someText)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

async function* noo() {
  const x = Promise.resolve(1);
  const y = Promise.resolve(2);
  
  const fromX = yield x;
  return y;
}

const n1 = noo();

let value1 = Promise.resolve("a");
let value2 = Promise.resolve("b");

n1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));
n1.next(value2).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilledDone(2)
    .isFinal();

logger.clear();

const n2 = noo();

value1 = Promise.resolve("a");
value2 = Promise.resolve("b");

n2.return(value1).then(fulfillSpy(logger), rejectSpy(logger));
n2.next(value2).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilledDone('a')
    .fullfilledDone()
    .isFinal();

logger.clear();

promise = getPromise(holder);

async function *ooo() {
    yield promise; 
}

const o1 = ooo();

o1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));

holder.reject("a");

drainMicrotasks();

assertLogger(logger)
    .rejected('a')
    .isFinal();

logger.clear();

promise = getPromise(holder);

async function *roo() {
    try {
        yield promise; 
    } catch (e) {
        yield e;
    }
}

const r1 = roo();
value1 = 'value-1';
value2 = 'value-2';
value3 = 'value-3';

r1.next().then(fulfillSpy(logger), rejectSpy(logger));
r1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));
r1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));

holder.reject("abc");

drainMicrotasks();

assertLogger(logger)
    .fullfilled('abc')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

holder1 = {};
holder2 = {};
promise1 = getPromise(holder1);
promise2 = getPromise(holder2);

async function *poo() {
    try {
        yield promise1; 
    } catch (e) {
        yield promise2;
    }
}

const p1 = poo();

p1.next().then(fulfillSpy(logger), rejectSpy(logger));
p1.next(value3).then(fulfillSpy(logger), rejectSpy(logger));
p1.next(value3).then(fulfillSpy(logger), rejectSpy(logger));

holder1.reject(value1);
holder2.reject(value2);

drainMicrotasks();

assertLogger(logger)
    .rejected(value2)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

async function *soo() {
    yield 1;
}

const endValue = 'end-value-1';

logger.clear();

const s1 = soo();

s1.next().then(fulfillSpy(logger), rejectSpy(logger));
s1.next().then(fulfillSpy(logger), rejectSpy(logger));
s1.return(Promise.resolve(endValue)).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilledDone()
    .fullfilledDone(endValue)
    .isFinal();

logger.clear();

const s2 = soo();

s2.next().then(fulfillSpy(logger), rejectSpy(logger));
s2.next().then(fulfillSpy(logger), rejectSpy(logger));
s2.return(Promise.reject(endValue)).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilledDone()
    .rejected(endValue)
    .isFinal();

logger.clear();
const s3 = soo();

s3.next().then(fulfillSpy(logger), rejectSpy(logger));
s3.next().then(fulfillSpy(logger), rejectSpy(logger));
s3.return(endValue).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilledDone()
    .fullfilledDone(endValue)
    .isFinal();

logger.clear();

const s4 = soo();
promise1 = Promise.resolve(endValue);

s4.next().then(fulfillSpy(logger), rejectSpy(logger));
s4.next().then(fulfillSpy(logger), rejectSpy(logger));
s4.throw(promise1).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilledDone()
    .rejected(promise1)
    .isFinal();

logger.clear();

const s5 = soo();

s5.next().then(fulfillSpy(logger), rejectSpy(logger));
s5.next().then(fulfillSpy(logger), rejectSpy(logger));
s5.throw(endValue).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilledDone()
    .rejected(endValue)
    .isFinal();

async function *too() {
    return Promise.resolve('abcd');
}

logger.clear();

const t = too();

t.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilledDone('abcd')
    .isFinal();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\n\nconst Logger = function () {\n    var log = [];\n\n    this.logEvent = (type, value, done) => {\n        log.push({ type, value, done});\n    };\n    this.logFulfilledEvent = (value, done) => {\n        this.logEvent(\'fulfilled\', value, done);\n    };\n    this.logRejectEvent = error => {\n        this.logEvent(\'reject\', error.toString(), true);\n    };\n    this.logCatchEvent = value => {\n        this.logEvent(\'catch\', value, true);\n    };\n    this.getLogger = () => log;\n\n    this.clear = () => {\n        log = [];\n    }\n};\n\nconst fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);\nconst rejectSpy = logger => error => logger.logRejectEvent(error);\nconst catchSpy = logger => error => logger.logCatchEvent(error);\n\nconst assertLogger = function (loggerObject) {\n    const logger = loggerObject.getLogger();\n\n    var _assertLogger = function () {\n        let index = 0;\n\n        const isNotOutOfLength = () => {\n            assert(index < logger.length, true, `Index is greater then log length`);   \n        }\n\n        this.fullfilled = function (expectedValue, message = \'on fulfill\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.fullfilledDone = function (expectedValue, message = \'on fulfill with done true\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.rejected = function (error, message = \'on reject\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'reject\', msg);\n            assert(step.value, error.toString(), msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.catched = function (expectedError, message = \'on catch\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'catch\', msg);\n            assert(step.value, expectedError, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.isFinal = function (message = \'\') {\n            assert(index, logger.length, `expected final step: ${message}`);\n        }; \n    }; \n    \n    return new _assertLogger();\n};\n\nconst getPromise = promiseHolder => {\n    return new Promise((resolve, reject) => {\n        promiseHolder.resolve = resolve;\n        promiseHolder.reject = reject;\n    });\n};\n\nasync function*generator () {\n    yield 42;\n}\n\nvar passed = false;\nvar iterator = generator();\n\niterator.next().then(function(step) {\n    if(iterator[Symbol.asyncIterator]() === iterator && step.done === false && step.value === 42) passed = true;\n});\n\ndrainMicrotasks();\n\nassert(passed, true, \'\');\n\nassert(generator[Symbol.toStringTag], \'AsyncGeneratorFunction\');\nassert(Object.prototype.toString.call(generator), \'[object AsyncGeneratorFunction]\');\n\n\nvar holder = {};\n\nvar promise = getPromise(holder);\nvar logger = new Logger();\n\nasync function * baz(value) {\n    var t = await promise;\n    let reply = yield t + \' data-0\' + value;\n    let last = yield t + \' data-1\' + reply;\n    return \'data-result\' + last;\n}\n\nvar bz1 = baz(\':init\');\n\nbz1.next(\':0\').then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next(\':1\').then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next(\':2\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .isFinal();\n\nholder.resolve(\'abcd\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-0:init\')\n    .fullfilled(\'abcd data-1:1\')\n    .fullfilledDone(\'data-result:2\')\n    .isFinal();\n\nlogger.clear();\n\npromise = getPromise(holder);\n\nvar bz2 = baz(\':init\');\n\nbz2.next(\':0\').then(fulfillSpy(logger), rejectSpy(logger));\nbz2.next(\':1\').then(fulfillSpy(logger), rejectSpy(logger));\nbz2.next(\':2\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .isFinal();\n\nholder.reject(\'abcd\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(\'abcd\')\n    .fullfilledDone()\n    .fullfilledDone()\n    .isFinal();\n\nvar holder1 = {}; holder2 = {};\nvar promise1 = getPromise(holder1);\nvar promise2 = getPromise(holder2);\n\nlogger.clear();\n\nasync function *boo() {\n    var t1 = await promise1;\n    yield t1 + \' data-1\';\n    yield t1 + \' data-2\';\n    var t2 = await promise2;\n    yield t2 + \' data-3\';\n    yield t2 + \' data-4\';\n    return \'data-5\';\n};\n\nvar b = boo();\n\nb.next().then(fulfillSpy(logger));\nb.next().then(fulfillSpy(logger));\nb.next().then(fulfillSpy(logger));\nb.next().then(fulfillSpy(logger));\nb.next().then(fulfillSpy(logger));\nb.next().then(fulfillSpy(logger));\n\nassertLogger(logger)\n    .isFinal(\'async generator should not resolve any promise until await is no resolved\');\n\nholder1.resolve(\'abcd\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-1\')\n    .fullfilled(\'abcd data-2\')\n    .isFinal();\n\nholder2.resolve(\'efgh\');\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-1\')\n    .fullfilled(\'abcd data-2\')\n    .fullfilled(\'efgh data-3\')\n    .fullfilled(\'efgh data-4\')\n    .fullfilledDone(\'data-5\')\n    .fullfilledDone(undefined, error => print(error))\n    .isFinal();\n\nholder = {};\n\npromise = getPromise(holder);\n\nasync function *foo() {\n    var t = await \'abcd\';\n    yield t + \' data-5\';\n    var t2 = await promise;\n    yield t2 + \' data-6\';\n};\n\nlogger.clear();\n\nvar f = foo();\n\nf.next().then(fulfillSpy(logger));\nf.next().then(fulfillSpy(logger));\nf.next().then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-5\')\n    .isFinal(\'async generator should not resolve any promise until await is not resolved\');\n\nholder.resolve(\'xyz\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-5\')\n    .fullfilled(\'xyz data-6\')\n    .fullfilledDone(undefined)\n    .isFinal(\'async generator should not resolve any promise until await is not resolved\');\n\nholder = {};\npromise = getPromise(holder);\n\nasync function *goo() {\n    yield \'data-5\';\n    var t = await promise;\n    yield t + \' data-6\';\n    yield t + \' data-7\';\n};\n\nlogger.clear();\nvar errorText = \'error-reject\';\nvar g = goo();\n\ndrainMicrotasks();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'data-5\')\n    .isFinal(\'async generator should not resolve any promise until await is not resolved\');\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\nassertLogger(logger)\n    .fullfilled(\'data-5\')\n    .isFinal(\'async generator should not resolve any promise until await is not resolved\');\n\nholder.reject(errorText);\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'data-5\')\n    .rejected(errorText)\n    .fullfilledDone(undefined, \'After reject all resolved value have undefined\')\n    .isFinal();\n\n/* Method in class */\n\nconst someText = \'foo\';\nconst resolveText = \'bar\';\n\nlogger.clear();\n\nholder = {};\npromise = getPromise(holder);\n\nclass A { \n    async * foo() { yield someText; } \n    async * boo() { var text = await promise; yield text + someText; }\n}\nvar a = new A;\nvar gf = a.foo();\n\ngf.next().then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(someText)\n    .isFinal();\n\nconst gb = a.boo();\n\ngb.next().then(fulfillSpy(logger));\n\nassertLogger(logger)\n    .fullfilled(someText)\n    .isFinal();\n\nholder.resolve(resolveText);\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(someText)\n    .fullfilled(resolveText + someText)\n    .isFinal();\n\n/* Async generator function expression */\nlogger.clear();\nholder = {};\npromise = getPromise(holder);\n\nvar asyncGenExp = async function *() { var t = await promise; yield t + someText + someText; };\n\nvar gAsyncGenExp = asyncGenExp();\n\ngAsyncGenExp.next().then(fulfillSpy(logger));\n\nholder.resolve(resolveText);\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(resolveText + someText + someText)\n    .isFinal();\n\nlogger.clear();\n\n/*Test throw*/\nasync function *joo() {\n    yield \'data-1\';\n    yield \'data-2\';\n    yield \'data-3\';\n};\n\nvar j = joo();\nvar errorTextInFunction = "ErrorInFunction";\nconst errorWrongGenerator = "|this| should be an async generator";\nlet errorRaised = false;\n\nj.next()\n.then(function(value) {\n    fulfillSpy(logger)(value);\n    return j.throw(new Error(errorTextInFunction));\n})\n.then(function (value) {\n    fulfillSpy(logger)(value);\n}, function (error) {\n    rejectSpy(logger)(error);\n    return j.next();\n})\n.then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'data-1\')\n    .rejected((new Error(errorTextInFunction)).toString())\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nvar j1 = joo();\n\nj1.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));\nj1.next().then(fulfillSpy(logger), rejectSpy(logger));\nj1.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new Error(errorText))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nvar j2 = joo();\n\nconst returnValue = \'return-value\';\n\nj1.return(returnValue).then(fulfillSpy(logger), rejectSpy(logger));\nj1.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));\nj1.next().then(fulfillSpy(logger), rejectSpy(logger));\nj1.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilledDone(returnValue)\n    .rejected(new Error(errorText))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nlet j3 = joo();\n\nj3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new TypeError(errorWrongGenerator))\n    .isFinal();\n\nlogger.clear();\nj3 = joo();\n\nj3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new TypeError(errorWrongGenerator))\n    .fullfilled(\'data-1\')\n    .fullfilled(\'data-2\')\n    .fullfilled(\'data-3\')\n    .isFinal();\n\nlogger.clear();\nj3 = joo();\n\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\nj3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new TypeError(errorWrongGenerator))\n    .fullfilled(\'data-1\')\n    .fullfilled(\'data-2\')\n    .fullfilled(\'data-3\')\n    .isFinal();\n\nlogger.clear();\nj3 = joo();\n\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\nj3.next.call(undefined).then(fulfillSpy(logger), rejectSpy(logger));\nj3.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new TypeError(errorWrongGenerator))\n    .fullfilled(\'data-1\')\n    .fullfilled(\'data-2\')\n    .fullfilled(\'data-3\')\n    .isFinal();\n\nlogger.clear();\nj3 = joo();\n\nj3.next.call({}).catch(rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new TypeError(errorWrongGenerator))\n\nlogger.clear();\nj3 = joo();\nj3.next.call(\'string\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new TypeError(errorWrongGenerator))\n    .isFinal();\n\nlogger.clear();\nj3 = joo();\nlet gen = generator();\nj3.next.call(gen).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(42)\n    .isFinal();\n\nlogger.clear();\nholder = {};\npromise = getPromise(holder);\n\nasync function *koo() {\n    var t = await \'abcd\';\n    yield t + \' data-first\';\n    var t2 = await promise;\n    yield t2 + \' data-second\';\n    yield t2 + \' data-third\';\n};\n\nconst k1 = koo();\n\nk1.next().then(fulfillSpy(logger));\nk1.next().then(fulfillSpy(logger));\n\nk1.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));\nk1.next().then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-first\')\n    .isFinal();\n\nholder.resolve(\'xyz\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-first\')\n    .fullfilled(\'xyz data-second\')\n    .rejected(new Error(errorText))\n    .fullfilledDone(undefined)\n    .isFinal();\n\n\nlogger.clear();\nholder = {};\npromise = getPromise(holder);\n\nconst k2 = koo();\n\nk2.next().then(fulfillSpy(logger));\nk2.next().then(fulfillSpy(logger));\n\nk2.return(returnValue).then(fulfillSpy(logger));\n\nholder.resolve(\'xyz\');\n\nk2.throw(new Error(errorText)).then(fulfillSpy(logger), rejectSpy(logger));\nk2.next().then(fulfillSpy(logger));\nk2.next().then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abcd data-first\')\n    .fullfilled(\'xyz data-second\')\n    .fullfilledDone(returnValue)\n    .rejected(new Error(errorText))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\n\nlogger.clear();\nholder = {};\npromise = getPromise(holder);\n\nasync function *loo() {\n    var t = await promise;\n    throw new Error(errorText);\n    yield t + \'data-first\';\n    yield t + \'data-second\';\n};\n\nconst l1 = loo();\n\nl1.next().then(fulfillSpy(logger), rejectSpy(logger));\nl1.next().then(fulfillSpy(logger), rejectSpy(logger));\nl1.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .isFinal();\n\nholder.resolve(\'qwe\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new Error(errorText))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nholder = {};\npromise = getPromise(holder);\n\nconst l2 = loo();\n\nl2.throw(new Error(\'another error\')).then(fulfillSpy(logger), rejectSpy(logger));\nl2.next().then(fulfillSpy(logger), rejectSpy(logger));\nl2.next().then(fulfillSpy(logger), rejectSpy(logger));\n\nholder.resolve(\'abc\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new Error(\'another error\'))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nholder = {};\npromise = getPromise(holder);\n\nconst l3 = loo();\n\nl3.return(someText).then(fulfillSpy(logger), rejectSpy(logger));\nl3.next().then(fulfillSpy(logger), rejectSpy(logger));\nl3.next().then(fulfillSpy(logger), rejectSpy(logger));\n\nholder.resolve(resolveText);\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilledDone(someText)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nasync function *moo() {\n    throw new Error(errorText);\n    yield t + \'data-first\';\n    yield t + \'data-second\';\n};\n\nconst m1 = moo();\n\nm1.next().then(fulfillSpy(logger), rejectSpy(logger));\nm1.next().then(fulfillSpy(logger), rejectSpy(logger));\nm1.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new Error(errorText))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nconst m2 = moo();\n\nm2.throw(new Error(\'another error\')).then(fulfillSpy(logger), rejectSpy(logger));\nm2.next().then(fulfillSpy(logger), rejectSpy(logger));\nm2.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(new Error(\'another error\'))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nconst m3 = moo();\n\nm3.return(someText).then(fulfillSpy(logger), rejectSpy(logger));\nm3.next().then(fulfillSpy(logger), rejectSpy(logger));\nm3.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilledDone(someText)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nasync function* noo() {\n  const x = Promise.resolve(1);\n  const y = Promise.resolve(2);\n  \n  const fromX = yield x;\n  return y;\n}\n\nconst n1 = noo();\n\nlet value1 = Promise.resolve("a");\nlet value2 = Promise.resolve("b");\n\nn1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));\nn1.next(value2).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilledDone(2)\n    .isFinal();\n\nlogger.clear();\n\nconst n2 = noo();\n\nvalue1 = Promise.resolve("a");\nvalue2 = Promise.resolve("b");\n\nn2.return(value1).then(fulfillSpy(logger), rejectSpy(logger));\nn2.next(value2).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilledDone(\'a\')\n    .fullfilledDone()\n    .isFinal();\n\nlogger.clear();\n\npromise = getPromise(holder);\n\nasync function *ooo() {\n    yield promise; \n}\n\nconst o1 = ooo();\n\no1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));\n\nholder.reject("a");\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(\'a\')\n    .isFinal();\n\nlogger.clear();\n\npromise = getPromise(holder);\n\nasync function *roo() {\n    try {\n        yield promise; \n    } catch (e) {\n        yield e;\n    }\n}\n\nconst r1 = roo();\nvalue1 = \'value-1\';\nvalue2 = \'value-2\';\nvalue3 = \'value-3\';\n\nr1.next().then(fulfillSpy(logger), rejectSpy(logger));\nr1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));\nr1.next(value1).then(fulfillSpy(logger), rejectSpy(logger));\n\nholder.reject("abc");\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'abc\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nholder1 = {};\nholder2 = {};\npromise1 = getPromise(holder1);\npromise2 = getPromise(holder2);\n\nasync function *poo() {\n    try {\n        yield promise1; \n    } catch (e) {\n        yield promise2;\n    }\n}\n\nconst p1 = poo();\n\np1.next().then(fulfillSpy(logger), rejectSpy(logger));\np1.next(value3).then(fulfillSpy(logger), rejectSpy(logger));\np1.next(value3).then(fulfillSpy(logger), rejectSpy(logger));\n\nholder1.reject(value1);\nholder2.reject(value2);\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .rejected(value2)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nasync function *soo() {\n    yield 1;\n}\n\nconst endValue = \'end-value-1\';\n\nlogger.clear();\n\nconst s1 = soo();\n\ns1.next().then(fulfillSpy(logger), rejectSpy(logger));\ns1.next().then(fulfillSpy(logger), rejectSpy(logger));\ns1.return(Promise.resolve(endValue)).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilledDone()\n    .fullfilledDone(endValue)\n    .isFinal();\n\nlogger.clear();\n\nconst s2 = soo();\n\ns2.next().then(fulfillSpy(logger), rejectSpy(logger));\ns2.next().then(fulfillSpy(logger), rejectSpy(logger));\ns2.return(Promise.reject(endValue)).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilledDone()\n    .rejected(endValue)\n    .isFinal();\n\nlogger.clear();\nconst s3 = soo();\n\ns3.next().then(fulfillSpy(logger), rejectSpy(logger));\ns3.next().then(fulfillSpy(logger), rejectSpy(logger));\ns3.return(endValue).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilledDone()\n    .fullfilledDone(endValue)\n    .isFinal();\n\nlogger.clear();\n\nconst s4 = soo();\npromise1 = Promise.resolve(endValue);\n\ns4.next().then(fulfillSpy(logger), rejectSpy(logger));\ns4.next().then(fulfillSpy(logger), rejectSpy(logger));\ns4.throw(promise1).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilledDone()\n    .rejected(promise1)\n    .isFinal();\n\nlogger.clear();\n\nconst s5 = soo();\n\ns5.next().then(fulfillSpy(logger), rejectSpy(logger));\ns5.next().then(fulfillSpy(logger), rejectSpy(logger));\ns5.throw(endValue).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilledDone()\n    .rejected(endValue)\n    .isFinal();\n\nasync function *too() {\n    return Promise.resolve(\'abcd\');\n}\n\nlogger.clear();\n\nconst t = too();\n\nt.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilledDone(\'abcd\')\n    .isFinal();\n' }
async-iteration-for-await-of.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};
var result = 0;
async function * foo() { yield 1; yield Promise.resolve(2); return 3;};

async function boo () {
    for await (const value of foo()) {
        result = result + value;
    }
}

boo();

drainMicrotasks();

assert(result, 3);

result =  0;

{
    const boo =  async function () {
        for await (const val of foo()) {
            result = result + val;
        }
    }

    boo();

    drainMicrotasks();

    assert(result, 3);
}

{
    result =  0;
    const boo = async function () {
        for await (const val of [1, 2, 3]) {
            result = result + val;
        }
    }

    boo();

    drainMicrotasks();

    assert(result, 6);
}

{ 
    let error = false;

    const boo = async function () {
        for await (const val of 1) {
            result = result + val;
        }
    }

    boo().catch(raisedError => error = raisedError instanceof TypeError);

    drainMicrotasks();

    assert(error, true);
}

{
    let conter = 0;
    const o = {
        [Symbol.asyncIterator]() {
            return this
        },
        next(args) {
            return { done: true }
        }
    }

    result = -1;
    const boo = async function () {
        for await (const val of o) {
            conter++;
            result = val;
        }
    }

    boo();

    drainMicrotasks();

    assert(conter, 0);
    assert(result, -1);
}

{
    let conter = 0;
    const o = {
        [Symbol.asyncIterator]() {
            this.index = 0;
            return this
        },
        next(args) {
            this.index++;
            if (this.index <= 10)
                return { done: false, value: this.index };
            else 
                return { done: true, value: this.index };
        }
    }

    result = 0;
    const boo = async function () {
        for await (const val of o) {
            conter++;
            result += val;
        }
    }

    boo();

    drainMicrotasks();

    assert(conter, 10);
    assert(result, 55);
}

{
    let conter = 0;
    let error = false;

    const o = {
        [Symbol.asyncIterator]() {
            this.index = 0;
            return this
        },
        next(args) {
            this.index++;
            if (this.index <= 10)
                return { done: false, value: this.index };
            else 
                throw new Error('some error');
        }
    }

    result = 0;
    const boo = async function () {
        for await (const val of o) {
            conter++;
            result += val;
        }
    }

    boo().catch(e => { error = e instanceof Error && e.message === 'some error'; });

    drainMicrotasks();

    assert(conter, 10);
    assert(result, 55);
    assert(error, true);
}

{
    let conter = 0;
    let error = false;
    let emptyParam = false;

    const o = {
        [Symbol.asyncIterator]() {
            this.index = 0;
            return this
        },
        next(args) {
            emptyParam = args === undefined;
            this.index++;
            if (this.index <= 10)
                return { done: false, value: this.index };
            else 
                throw new Error('some error');
        }
    }

    result = 0;
    const boo = async function () {
        try {
            for await (const val of o) {
                conter++;
                result += val;
            }
        } catch (e) {
            error =  e instanceof Error && e.message === 'some error';
        }
    }

    boo();

    drainMicrotasks();

    assert(conter, 10);
    assert(result, 55);
    assert(error, true);
    assert(emptyParam, true);
}

{
    let conter = 0;
    let error = false;

    const o = {
        [Symbol.asyncIterator]() {
            this.index = 0;
            return this
        },
        next(args) {
            this.index++;
            if (this.index <= 10)
                return { done: false, value: this.index };
            else 
                return { done: true, value: this.index };
        }
    }

    result = 0;
    const boo = async function () {
        if (true) {
            for await (const val of o) {
                conter++;
                result += val;
            }
        }
    }

    boo();

    drainMicrotasks();

    assert(conter, 10);
    assert(result, 55);
}

{
    let conter = 0;
    let error = false;
    let emptyParam = false;

    const o = {
        [Symbol.iterator]() {
            this.index = 0;
            return this
        },
        next(args) {
            emptyParam = args === undefined;
            this.index++;
            if (this.index <= 10)
                return { done: false, value: this.index };
            else 
                throw new Error('some error');
        }
    }

    result = 0;
    const boo = async function () {
        try {
            for await (const val of o) {
                conter++;
                result += val;
            }
        } catch (e) {
            error =  e instanceof Error && e.message === 'some error';
        }
    }

    boo();

    drainMicrotasks();

    assert(conter, 10);
    assert(result, 55);
    assert(error, true);
    assert(emptyParam, true);
}
{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\nvar result = 0;\nasync function * foo() { yield 1; yield Promise.resolve(2); return 3;};\n\nasync function boo () {\n    for await (const value of foo()) {\n        result = result + value;\n    }\n}\n\nboo();\n\ndrainMicrotasks();\n\nassert(result, 3);\n\nresult =  0;\n\n{\n    const boo =  async function () {\n        for await (const val of foo()) {\n            result = result + val;\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(result, 3);\n}\n\n{\n    result =  0;\n    const boo = async function () {\n        for await (const val of [1, 2, 3]) {\n            result = result + val;\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(result, 6);\n}\n\n{ \n    let error = false;\n\n    const boo = async function () {\n        for await (const val of 1) {\n            result = result + val;\n        }\n    }\n\n    boo().catch(raisedError => error = raisedError instanceof TypeError);\n\n    drainMicrotasks();\n\n    assert(error, true);\n}\n\n{\n    let conter = 0;\n    const o = {\n        [Symbol.asyncIterator]() {\n            return this\n        },\n        next(args) {\n            return { done: true }\n        }\n    }\n\n    result = -1;\n    const boo = async function () {\n        for await (const val of o) {\n            conter++;\n            result = val;\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(conter, 0);\n    assert(result, -1);\n}\n\n{\n    let conter = 0;\n    const o = {\n        [Symbol.asyncIterator]() {\n            this.index = 0;\n            return this\n        },\n        next(args) {\n            this.index++;\n            if (this.index <= 10)\n                return { done: false, value: this.index };\n            else \n                return { done: true, value: this.index };\n        }\n    }\n\n    result = 0;\n    const boo = async function () {\n        for await (const val of o) {\n            conter++;\n            result += val;\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(conter, 10);\n    assert(result, 55);\n}\n\n{\n    let conter = 0;\n    let error = false;\n\n    const o = {\n        [Symbol.asyncIterator]() {\n            this.index = 0;\n            return this\n        },\n        next(args) {\n            this.index++;\n            if (this.index <= 10)\n                return { done: false, value: this.index };\n            else \n                throw new Error(\'some error\');\n        }\n    }\n\n    result = 0;\n    const boo = async function () {\n        for await (const val of o) {\n            conter++;\n            result += val;\n        }\n    }\n\n    boo().catch(e => { error = e instanceof Error && e.message === \'some error\'; });\n\n    drainMicrotasks();\n\n    assert(conter, 10);\n    assert(result, 55);\n    assert(error, true);\n}\n\n{\n    let conter = 0;\n    let error = false;\n    let emptyParam = false;\n\n    const o = {\n        [Symbol.asyncIterator]() {\n            this.index = 0;\n            return this\n        },\n        next(args) {\n            emptyParam = args === undefined;\n            this.index++;\n            if (this.index <= 10)\n                return { done: false, value: this.index };\n            else \n                throw new Error(\'some error\');\n        }\n    }\n\n    result = 0;\n    const boo = async function () {\n        try {\n            for await (const val of o) {\n                conter++;\n                result += val;\n            }\n        } catch (e) {\n            error =  e instanceof Error && e.message === \'some error\';\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(conter, 10);\n    assert(result, 55);\n    assert(error, true);\n    assert(emptyParam, true);\n}\n\n{\n    let conter = 0;\n    let error = false;\n\n    const o = {\n        [Symbol.asyncIterator]() {\n            this.index = 0;\n            return this\n        },\n        next(args) {\n            this.index++;\n            if (this.index <= 10)\n                return { done: false, value: this.index };\n            else \n                return { done: true, value: this.index };\n        }\n    }\n\n    result = 0;\n    const boo = async function () {\n        if (true) {\n            for await (const val of o) {\n                conter++;\n                result += val;\n            }\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(conter, 10);\n    assert(result, 55);\n}\n\n{\n    let conter = 0;\n    let error = false;\n    let emptyParam = false;\n\n    const o = {\n        [Symbol.iterator]() {\n            this.index = 0;\n            return this\n        },\n        next(args) {\n            emptyParam = args === undefined;\n            this.index++;\n            if (this.index <= 10)\n                return { done: false, value: this.index };\n            else \n                throw new Error(\'some error\');\n        }\n    }\n\n    result = 0;\n    const boo = async function () {\n        try {\n            for await (const val of o) {\n                conter++;\n                result += val;\n            }\n        } catch (e) {\n            error =  e instanceof Error && e.message === \'some error\';\n        }\n    }\n\n    boo();\n\n    drainMicrotasks();\n\n    assert(conter, 10);\n    assert(result, 55);\n    assert(error, true);\n    assert(emptyParam, true);\n}' }
async-iteration-yield-promise.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};

const Logger = function () {
    var log = [];

    this.logEvent = (type, value, done) => {
        log.push({ type, value, done});
    };
    this.logFulfilledEvent = (value, done) => {
        this.logEvent('fulfilled', value, done);
    };
    this.logRejectEvent = error => {
        this.logEvent('reject', error.toString(), true);
    };
    this.logCatchEvent = value => {
        this.logEvent('catch', value, true);
    };
    this.getLogger = () => log;

    this.clear = () => {
        log = [];
    }
};

const fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);
const rejectSpy = logger => error => logger.logRejectEvent(error);
const catchSpy = logger => error => logger.logCatchEvent(error);

const assertLogger = function (loggerObject) {
    const logger = loggerObject.getLogger();

    var _assertLogger = function () {
        let index = 0;

        const isNotOutOfLength = () => {
            assert(index < logger.length, true, `Index is greater then log length`);   
        }

        this.fullfilled = function (expectedValue, message = 'on fulfill') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.fullfilledDone = function (expectedValue, message = 'on fulfill with done true') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.rejected = function (error, message = 'on reject') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'reject', msg);
            assert(step.value, error.toString(), msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.catched = function (expectedError, message = 'on catch') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'catch', msg);
            assert(step.value, expectedError, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.isFinal = function (message = '') {
            assert(index, logger.length, `expected final step: ${message}`);
        }; 
    }; 
    
    return new _assertLogger();
};

const getPromise = promiseHolder => {
    return new Promise((resolve, reject) => {
        promiseHolder.resolve = resolve;
        promiseHolder.reject = reject;
    });
};

var logger = new Logger();
const someValue = 'some-value';
const errorMessage = 'error-message';
const promiseHolder = {};

async function * foo(val) {
    let reply = yield '0:' + val;
    reply = yield getPromise(promiseHolder);
    return 'end foo:' + reply;
}

let f = foo(someValue);

f.next(someValue + ':0').then(fulfillSpy(logger));
f.next(someValue + ':1').then(fulfillSpy(logger));
f.next(someValue + ':2').then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:' + someValue)
    .isFinal();

promiseHolder.resolve('1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:' + someValue)
    .fullfilled('1')
    .fullfilledDone('end foo:' +  someValue + ':2')
    .isFinal();

logger.clear();

f = foo('init');

f.next('0').then(fulfillSpy(logger), rejectSpy(logger));
f.next('1').then(fulfillSpy(logger), rejectSpy(logger));
f.next('2').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:init')
    .isFinal();

promiseHolder.reject('1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:init')
    .rejected('1')
    .fullfilledDone()
    .isFinal();

logger.clear();

f = foo('init');

f.next('0').then(fulfillSpy(logger)).catch(catchSpy(logger));
f.next('1').then(fulfillSpy(logger)).catch(catchSpy(logger));
f.next('2').then(fulfillSpy(logger)).catch(catchSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:init')
    .isFinal();

promiseHolder.reject('1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:init')
    .fullfilledDone(undefined)
    .catched('1')
    .isFinal();

logger.clear();

const promiseHolder1 = {};
const promiseHolder2 = {};

async function * boo() {
    const promise1 = getPromise(promiseHolder1);
    const promise2 = getPromise(promiseHolder2);
    yield '0';
    yield promise1;
    yield '1';
    yield promise2;
    return 'end foo';
}

let b = boo();

b.next().then(fulfillSpy(logger)).catch(catchSpy(logger));
b.next().then(fulfillSpy(logger)).catch(catchSpy(logger));
b.next().then(fulfillSpy(logger)).catch(catchSpy(logger));
b.next().then(fulfillSpy(logger)).catch(catchSpy(logger));
b.next().then(fulfillSpy(logger)).catch(catchSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder1.resolve('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('#1')
    .fullfilled('1')
    .isFinal();

promiseHolder2.resolve('#2');
drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('#1')
    .fullfilled('1')
    .fullfilled('#2')
    .fullfilledDone('end foo')
    .isFinal();


logger.clear();

b = boo();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder1.resolve('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('#1')
    .fullfilled('1')
    .isFinal();

promiseHolder2.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('#1')
    .fullfilled('1')
    .rejected('#2')
    .fullfilledDone()
    .isFinal();

logger.clear();

b = boo();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder1.reject('#1');
promiseHolder2.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .rejected('#1')
    .fullfilledDone()
    .fullfilledDone()
    .fullfilledDone()
    .isFinal();

logger.clear();

b = boo();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder2.reject('#2');
promiseHolder1.reject('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .rejected('#1')
    .fullfilledDone()
    .fullfilledDone()
    .fullfilledDone()
    .isFinal();

async function * bar() {
  yield '0';
  yield getPromise(promiseHolder1);
  throw new Error(errorMessage);
  yield getPromise(promiseHolder2);
  return 'end foo';
}

logger.clear();
b = bar();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();
 

promiseHolder1.resolve('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('#1')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
b = bar();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder1.reject('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .rejected('#1')
    .fullfilledDone()
    .fullfilledDone()
    .isFinal();

logger.clear();
b = bar();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .isFinal();

promiseHolder1.resolve('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
b = bar();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder1.resolve('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled("#1")
    .fullfilledDone(someValue)
    .isFinal();

logger.clear();
b = bar();

b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.next().then(fulfillSpy(logger), rejectSpy(logger));
b.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .isFinal();

promiseHolder1.reject('#1');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .rejected("#1")
    .fullfilledDone(someValue)
    .isFinal();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\n\nconst Logger = function () {\n    var log = [];\n\n    this.logEvent = (type, value, done) => {\n        log.push({ type, value, done});\n    };\n    this.logFulfilledEvent = (value, done) => {\n        this.logEvent(\'fulfilled\', value, done);\n    };\n    this.logRejectEvent = error => {\n        this.logEvent(\'reject\', error.toString(), true);\n    };\n    this.logCatchEvent = value => {\n        this.logEvent(\'catch\', value, true);\n    };\n    this.getLogger = () => log;\n\n    this.clear = () => {\n        log = [];\n    }\n};\n\nconst fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);\nconst rejectSpy = logger => error => logger.logRejectEvent(error);\nconst catchSpy = logger => error => logger.logCatchEvent(error);\n\nconst assertLogger = function (loggerObject) {\n    const logger = loggerObject.getLogger();\n\n    var _assertLogger = function () {\n        let index = 0;\n\n        const isNotOutOfLength = () => {\n            assert(index < logger.length, true, `Index is greater then log length`);   \n        }\n\n        this.fullfilled = function (expectedValue, message = \'on fulfill\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.fullfilledDone = function (expectedValue, message = \'on fulfill with done true\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.rejected = function (error, message = \'on reject\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'reject\', msg);\n            assert(step.value, error.toString(), msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.catched = function (expectedError, message = \'on catch\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'catch\', msg);\n            assert(step.value, expectedError, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.isFinal = function (message = \'\') {\n            assert(index, logger.length, `expected final step: ${message}`);\n        }; \n    }; \n    \n    return new _assertLogger();\n};\n\nconst getPromise = promiseHolder => {\n    return new Promise((resolve, reject) => {\n        promiseHolder.resolve = resolve;\n        promiseHolder.reject = reject;\n    });\n};\n\nvar logger = new Logger();\nconst someValue = \'some-value\';\nconst errorMessage = \'error-message\';\nconst promiseHolder = {};\n\nasync function * foo(val) {\n    let reply = yield \'0:\' + val;\n    reply = yield getPromise(promiseHolder);\n    return \'end foo:\' + reply;\n}\n\nlet f = foo(someValue);\n\nf.next(someValue + \':0\').then(fulfillSpy(logger));\nf.next(someValue + \':1\').then(fulfillSpy(logger));\nf.next(someValue + \':2\').then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:\' + someValue)\n    .isFinal();\n\npromiseHolder.resolve(\'1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:\' + someValue)\n    .fullfilled(\'1\')\n    .fullfilledDone(\'end foo:\' +  someValue + \':2\')\n    .isFinal();\n\nlogger.clear();\n\nf = foo(\'init\');\n\nf.next(\'0\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'1\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'2\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:init\')\n    .isFinal();\n\npromiseHolder.reject(\'1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:init\')\n    .rejected(\'1\')\n    .fullfilledDone()\n    .isFinal();\n\nlogger.clear();\n\nf = foo(\'init\');\n\nf.next(\'0\').then(fulfillSpy(logger)).catch(catchSpy(logger));\nf.next(\'1\').then(fulfillSpy(logger)).catch(catchSpy(logger));\nf.next(\'2\').then(fulfillSpy(logger)).catch(catchSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:init\')\n    .isFinal();\n\npromiseHolder.reject(\'1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:init\')\n    .fullfilledDone(undefined)\n    .catched(\'1\')\n    .isFinal();\n\nlogger.clear();\n\nconst promiseHolder1 = {};\nconst promiseHolder2 = {};\n\nasync function * boo() {\n    const promise1 = getPromise(promiseHolder1);\n    const promise2 = getPromise(promiseHolder2);\n    yield \'0\';\n    yield promise1;\n    yield \'1\';\n    yield promise2;\n    return \'end foo\';\n}\n\nlet b = boo();\n\nb.next().then(fulfillSpy(logger)).catch(catchSpy(logger));\nb.next().then(fulfillSpy(logger)).catch(catchSpy(logger));\nb.next().then(fulfillSpy(logger)).catch(catchSpy(logger));\nb.next().then(fulfillSpy(logger)).catch(catchSpy(logger));\nb.next().then(fulfillSpy(logger)).catch(catchSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder1.resolve(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'#1\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder2.resolve(\'#2\');\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'#1\')\n    .fullfilled(\'1\')\n    .fullfilled(\'#2\')\n    .fullfilledDone(\'end foo\')\n    .isFinal();\n\n\nlogger.clear();\n\nb = boo();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder1.resolve(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'#1\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder2.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'#1\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .fullfilledDone()\n    .isFinal();\n\nlogger.clear();\n\nb = boo();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder1.reject(\'#1\');\npromiseHolder2.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .rejected(\'#1\')\n    .fullfilledDone()\n    .fullfilledDone()\n    .fullfilledDone()\n    .isFinal();\n\nlogger.clear();\n\nb = boo();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder2.reject(\'#2\');\npromiseHolder1.reject(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .rejected(\'#1\')\n    .fullfilledDone()\n    .fullfilledDone()\n    .fullfilledDone()\n    .isFinal();\n\nasync function * bar() {\n  yield \'0\';\n  yield getPromise(promiseHolder1);\n  throw new Error(errorMessage);\n  yield getPromise(promiseHolder2);\n  return \'end foo\';\n}\n\nlogger.clear();\nb = bar();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n \n\npromiseHolder1.resolve(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'#1\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nb = bar();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder1.reject(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .rejected(\'#1\')\n    .fullfilledDone()\n    .fullfilledDone()\n    .isFinal();\n\nlogger.clear();\nb = bar();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .isFinal();\n\npromiseHolder1.resolve(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nb = bar();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder1.resolve(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled("#1")\n    .fullfilledDone(someValue)\n    .isFinal();\n\nlogger.clear();\nb = bar();\n\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.next().then(fulfillSpy(logger), rejectSpy(logger));\nb.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .isFinal();\n\npromiseHolder1.reject(\'#1\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .rejected("#1")\n    .fullfilledDone(someValue)\n    .isFinal();\n' }
async-iteration-yield-star-interface.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};

const getPromise = promiseHolder => {
    return new Promise((resolve, reject) => {
        promiseHolder.resolve = resolve;
        promiseHolder.reject = reject;
    });
};

const Logger = function () {
    var log = [];

    this.logEvent = (type, value, done) => {
        log.push({ type, value, done});
    };
    this.logFulfilledEvent = (value, done) => {
        this.logEvent('fulfilled', value, done);
    };
    this.logRejectEvent = error => {
        this.logEvent('reject', error.toString(), true);
    };
    this.logCatchEvent = value => {
        this.logEvent('catch', value, true);
    };
    this.logCustomEvent = event => {
        this.logEvent('custom', event, false);
    };
    this.getLogger = () => log;

    this.clear = () => {
        log = [];
    }
};

const fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);
const rejectSpy = logger => error => logger.logRejectEvent(error);
const catchSpy = logger => error => logger.logCatchEvent(error);
const customSpy = logger => event => logger.logCustomEvent(event);

const assertLogger = function (loggerObject) {
    const logger = loggerObject.getLogger();

    var _assertLogger = function () {
        let index = 0;

        const isNotOutOfLength = () => {
            assert(index < logger.length, true, `Index is greater then log length`);   
        }

        this.fullfilled = function (expectedValue, message = 'on fulfill') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];
            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.fullfilledDone = function (expectedValue, message = 'on fulfill with done true') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.rejected = function (error, message = 'on reject') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'reject', msg);
            assert(step.value, error.toString(), msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.catched = function (expectedError, message = 'on catch') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'catch', msg);
            assert(step.value, expectedError, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.custom = function (expectedValue, message = 'on custom event') {

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'custom', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.isFinal = function (message = '') {
            assert(index, logger.length, `expected final step: ${message}`);
        }; 
    }; 
    
    return new _assertLogger();
};

var logger = new Logger();
const someValue = 'some-value';
const errorMessage = 'error-message';

let asyncIter = {
    [Symbol.asyncIterator]() { return this; },
    next (value) {
        customSpy(logger)('next:' + value);
        return { value: value, done: 'iter:Finish' === value };
    },
    throw (error) {
        customSpy(logger)('throw:' + error);
        return error;
    },
    return(value) {
        customSpy(logger)('return:' + value);
        return { value: value, done: true };
    }
  };

async function *foo () {
    yield '0';
    yield* asyncIter;
    yield '3';
}

let f = foo('Init');

f.next('A').then(fulfillSpy(logger), rejectSpy(logger));
f.next('B').then(fulfillSpy(logger), rejectSpy(logger));
f.next('C').then(fulfillSpy(logger), rejectSpy(logger));
f.next('D').then(fulfillSpy(logger), rejectSpy(logger));
f.next('E').then(fulfillSpy(logger), rejectSpy(logger));
f.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
f.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('next:C')
    .fullfilled(undefined)
    .custom('next:D')
    .fullfilled("C")
    .custom('next:E')
    .fullfilled("D")
    .custom('next:iter:Finish')
    .fullfilled("E")
    .fullfilled("3")
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

f = foo('Init');

f.next('A').then(fulfillSpy(logger), rejectSpy(logger));
f.next('B').then(fulfillSpy(logger), rejectSpy(logger));
f.return('C').then(fulfillSpy(logger), rejectSpy(logger));
f.next('D').then(fulfillSpy(logger), rejectSpy(logger));
f.next('E').then(fulfillSpy(logger), rejectSpy(logger));
f.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
f.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:C')
    .fullfilled(undefined)
    .fullfilledDone("C")
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

f = foo('Init');

f.next('A').then(fulfillSpy(logger), rejectSpy(logger));
f.next('B').then(fulfillSpy(logger), rejectSpy(logger));
f.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
f.next('D').then(fulfillSpy(logger), rejectSpy(logger));
f.next('E').then(fulfillSpy(logger), rejectSpy(logger));
f.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
f.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('throw:' + new Error(errorMessage))
    .fullfilled(undefined)
    .custom('next:D')
    .fullfilled(undefined)
    .custom('next:E')
    .fullfilled('D')
    .custom('next:iter:Finish')
    .fullfilled('E')
    .fullfilled('3')
    .fullfilledDone(undefined)
    .isFinal();

asyncIter = {
    [Symbol.asyncIterator]() { return this; },
    next (value) {
        customSpy(logger)('next:' + value);
        return { value: value, done: 'iter:Finish' === value };
    }
  };

async function *boo () {
    yield '0';
    yield* asyncIter;
    yield '3';
}

let b = boo('Init');

logger.clear();

b.next('A').then(fulfillSpy(logger), rejectSpy(logger));
b.next('B').then(fulfillSpy(logger), rejectSpy(logger));
b.next('C').then(fulfillSpy(logger), rejectSpy(logger));
b.next('D').then(fulfillSpy(logger), rejectSpy(logger));
b.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
b.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('next:C')
    .fullfilled(undefined)
    .custom('next:D')
    .fullfilled("C")
    .custom("next:iter:Finish")
    .fullfilled("D")
    .fullfilled("3")
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

b = boo('Init');

b.next('A').then(fulfillSpy(logger), rejectSpy(logger));
b.next('B').then(fulfillSpy(logger), rejectSpy(logger));
b.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
b.next('D').then(fulfillSpy(logger), rejectSpy(logger));
b.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
b.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .fullfilled(undefined)
    .rejected('TypeError: Delegated generator does not have a \'throw\' method.')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

asyncIter = {
    [Symbol.asyncIterator]() { return this; },
    next (value) {
        customSpy(logger)('next:' + value);
        return { value: value, done: 'iter:Finish' === value };
    },
    return (value) {
        customSpy(logger)('return:' + value);
        return { value: value, done: true };
    }
  };

async function *bar () {
    yield '0';
    yield* asyncIter;
    yield '3';
}

b = bar('Init');

logger.clear();

b.next('A').then(fulfillSpy(logger), rejectSpy(logger));
b.next('B').then(fulfillSpy(logger), rejectSpy(logger));
b.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
b.next('D').then(fulfillSpy(logger), rejectSpy(logger));
b.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
b.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .rejected('TypeError: Delegated generator does not have a \'throw\' method.')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

let ph = {};

asyncIter = {
    [Symbol.asyncIterator]() { return this; },
    next (value) {
        customSpy(logger)('next:' + value);
        return { value: value, done: 'iter:Finish' === value };
    },
    return (value) {
        customSpy(logger)('return:' + value);
        return { value: getPromise(ph), done: true };
    }
  };

async function *baz () {
    yield '0';
    yield* asyncIter;
    yield '3';
}

b = baz('Init');

logger.clear();

b.next('A').then(fulfillSpy(logger), rejectSpy(logger));
b.next('B').then(fulfillSpy(logger), rejectSpy(logger));
b.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
b.next('D').then(fulfillSpy(logger), rejectSpy(logger));
b.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
b.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .rejected('TypeError: Delegated generator does not have a \'throw\' method.')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

ph.resolve('accept');

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .rejected('TypeError: Delegated generator does not have a \'throw\' method.')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

ph = {};

asyncIter = {
    [Symbol.asyncIterator]() { return this; },
    next (value) {
        customSpy(logger)('next:' + value);
        return { value: value, done: 'iter:Finish' === value };
    },
    return (value) {
        customSpy(logger)('return:' + value);
        return getPromise(ph);
    }
  };

async function *foobar () {
    yield '0';
    yield* asyncIter;
    yield '3';
}

fb = foobar('Init');

logger.clear();

fb.next('A').then(fulfillSpy(logger), rejectSpy(logger));
fb.next('B').then(fulfillSpy(logger), rejectSpy(logger));
fb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
fb.next('D').then(fulfillSpy(logger), rejectSpy(logger));
fb.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
fb.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .isFinal();

ph.resolve({ value: 'value', done: true });

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .rejected('TypeError: Delegated generator does not have a \'throw\' method.')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

fb = foobar('Init');

logger.clear();

fb.next('A').then(fulfillSpy(logger), rejectSpy(logger));
fb.next('B').then(fulfillSpy(logger), rejectSpy(logger));
fb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
fb.next('D').then(fulfillSpy(logger), rejectSpy(logger));
fb.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
fb.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .isFinal();

ph.resolve('X');

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:undefined')
    .fullfilled(undefined)
    .rejected('TypeError: Iterator result interface is not an object.')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\n\nconst getPromise = promiseHolder => {\n    return new Promise((resolve, reject) => {\n        promiseHolder.resolve = resolve;\n        promiseHolder.reject = reject;\n    });\n};\n\nconst Logger = function () {\n    var log = [];\n\n    this.logEvent = (type, value, done) => {\n        log.push({ type, value, done});\n    };\n    this.logFulfilledEvent = (value, done) => {\n        this.logEvent(\'fulfilled\', value, done);\n    };\n    this.logRejectEvent = error => {\n        this.logEvent(\'reject\', error.toString(), true);\n    };\n    this.logCatchEvent = value => {\n        this.logEvent(\'catch\', value, true);\n    };\n    this.logCustomEvent = event => {\n        this.logEvent(\'custom\', event, false);\n    };\n    this.getLogger = () => log;\n\n    this.clear = () => {\n        log = [];\n    }\n};\n\nconst fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);\nconst rejectSpy = logger => error => logger.logRejectEvent(error);\nconst catchSpy = logger => error => logger.logCatchEvent(error);\nconst customSpy = logger => event => logger.logCustomEvent(event);\n\nconst assertLogger = function (loggerObject) {\n    const logger = loggerObject.getLogger();\n\n    var _assertLogger = function () {\n        let index = 0;\n\n        const isNotOutOfLength = () => {\n            assert(index < logger.length, true, `Index is greater then log length`);   \n        }\n\n        this.fullfilled = function (expectedValue, message = \'on fulfill\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.fullfilledDone = function (expectedValue, message = \'on fulfill with done true\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.rejected = function (error, message = \'on reject\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'reject\', msg);\n            assert(step.value, error.toString(), msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.catched = function (expectedError, message = \'on catch\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'catch\', msg);\n            assert(step.value, expectedError, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.custom = function (expectedValue, message = \'on custom event\') {\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'custom\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.isFinal = function (message = \'\') {\n            assert(index, logger.length, `expected final step: ${message}`);\n        }; \n    }; \n    \n    return new _assertLogger();\n};\n\nvar logger = new Logger();\nconst someValue = \'some-value\';\nconst errorMessage = \'error-message\';\n\nlet asyncIter = {\n    [Symbol.asyncIterator]() { return this; },\n    next (value) {\n        customSpy(logger)(\'next:\' + value);\n        return { value: value, done: \'iter:Finish\' === value };\n    },\n    throw (error) {\n        customSpy(logger)(\'throw:\' + error);\n        return error;\n    },\n    return(value) {\n        customSpy(logger)(\'return:\' + value);\n        return { value: value, done: true };\n    }\n  };\n\nasync function *foo () {\n    yield \'0\';\n    yield* asyncIter;\n    yield \'3\';\n}\n\nlet f = foo(\'Init\');\n\nf.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'C\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'E\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'next:C\')\n    .fullfilled(undefined)\n    .custom(\'next:D\')\n    .fullfilled("C")\n    .custom(\'next:E\')\n    .fullfilled("D")\n    .custom(\'next:iter:Finish\')\n    .fullfilled("E")\n    .fullfilled("3")\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nf = foo(\'Init\');\n\nf.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nf.return(\'C\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'E\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:C\')\n    .fullfilled(undefined)\n    .fullfilledDone("C")\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nf = foo(\'Init\');\n\nf.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nf.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'E\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nf.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'throw:\' + new Error(errorMessage))\n    .fullfilled(undefined)\n    .custom(\'next:D\')\n    .fullfilled(undefined)\n    .custom(\'next:E\')\n    .fullfilled(\'D\')\n    .custom(\'next:iter:Finish\')\n    .fullfilled(\'E\')\n    .fullfilled(\'3\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nasyncIter = {\n    [Symbol.asyncIterator]() { return this; },\n    next (value) {\n        customSpy(logger)(\'next:\' + value);\n        return { value: value, done: \'iter:Finish\' === value };\n    }\n  };\n\nasync function *boo () {\n    yield \'0\';\n    yield* asyncIter;\n    yield \'3\';\n}\n\nlet b = boo(\'Init\');\n\nlogger.clear();\n\nb.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'C\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'next:C\')\n    .fullfilled(undefined)\n    .custom(\'next:D\')\n    .fullfilled("C")\n    .custom("next:iter:Finish")\n    .fullfilled("D")\n    .fullfilled("3")\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nb = boo(\'Init\');\n\nb.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .fullfilled(undefined)\n    .rejected(\'TypeError: Delegated generator does not have a \\\'throw\\\' method.\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nasyncIter = {\n    [Symbol.asyncIterator]() { return this; },\n    next (value) {\n        customSpy(logger)(\'next:\' + value);\n        return { value: value, done: \'iter:Finish\' === value };\n    },\n    return (value) {\n        customSpy(logger)(\'return:\' + value);\n        return { value: value, done: true };\n    }\n  };\n\nasync function *bar () {\n    yield \'0\';\n    yield* asyncIter;\n    yield \'3\';\n}\n\nb = bar(\'Init\');\n\nlogger.clear();\n\nb.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .rejected(\'TypeError: Delegated generator does not have a \\\'throw\\\' method.\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlet ph = {};\n\nasyncIter = {\n    [Symbol.asyncIterator]() { return this; },\n    next (value) {\n        customSpy(logger)(\'next:\' + value);\n        return { value: value, done: \'iter:Finish\' === value };\n    },\n    return (value) {\n        customSpy(logger)(\'return:\' + value);\n        return { value: getPromise(ph), done: true };\n    }\n  };\n\nasync function *baz () {\n    yield \'0\';\n    yield* asyncIter;\n    yield \'3\';\n}\n\nb = baz(\'Init\');\n\nlogger.clear();\n\nb.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nb.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .rejected(\'TypeError: Delegated generator does not have a \\\'throw\\\' method.\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nph.resolve(\'accept\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .rejected(\'TypeError: Delegated generator does not have a \\\'throw\\\' method.\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nph = {};\n\nasyncIter = {\n    [Symbol.asyncIterator]() { return this; },\n    next (value) {\n        customSpy(logger)(\'next:\' + value);\n        return { value: value, done: \'iter:Finish\' === value };\n    },\n    return (value) {\n        customSpy(logger)(\'return:\' + value);\n        return getPromise(ph);\n    }\n  };\n\nasync function *foobar () {\n    yield \'0\';\n    yield* asyncIter;\n    yield \'3\';\n}\n\nfb = foobar(\'Init\');\n\nlogger.clear();\n\nfb.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .isFinal();\n\nph.resolve({ value: \'value\', done: true });\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .rejected(\'TypeError: Delegated generator does not have a \\\'throw\\\' method.\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nfb = foobar(\'Init\');\n\nlogger.clear();\n\nfb.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nfb.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .isFinal();\n\nph.resolve(\'X\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:undefined\')\n    .fullfilled(undefined)\n    .rejected(\'TypeError: Iterator result interface is not an object.\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n' }
async-iteration-yield-star.js:SyntaxError: Unexpected token function
var assert = function (result, expected, message = "") {
  if (result !== expected) {
    throw new Error('Error in assert. Expected "' + expected + '" but was "' + result + '":' + message );
  }
};

const Logger = function () {
    var log = [];

    this.logEvent = (type, value, done) => {
        log.push({ type, value, done});
    };
    this.logFulfilledEvent = (value, done) => {
        this.logEvent('fulfilled', value, done);
    };
    this.logRejectEvent = error => {
        this.logEvent('reject', error.toString(), true);
    };
    this.logCatchEvent = value => {
        this.logEvent('catch', value, true);
    };
    this.logCustomEvent = event => {
        this.logEvent('custom', event, false);
    };
    this.getLogger = () => log;

    this.clear = () => {
        log = [];
    }
};

const fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);
const rejectSpy = logger => error => logger.logRejectEvent(error);
const catchSpy = logger => error => logger.logCatchEvent(error);
const customSpy = logger => event => logger.logCustomEvent(event);

const assertLogger = function (loggerObject) {
    const logger = loggerObject.getLogger();

    var _assertLogger = function () {
        let index = 0;

        const isNotOutOfLength = () => {
            assert(index < logger.length, true, `Index is greater then log length`);   
        }

        this.fullfilled = function (expectedValue, message = 'on fulfill') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];
            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.fullfilledDone = function (expectedValue, message = 'on fulfill with done true') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'fulfilled', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.rejected = function (error, message = 'on reject') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'reject', msg);
            assert(step.value, error.toString(), msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.catched = function (expectedError, message = 'on catch') {
            isNotOutOfLength();

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'catch', msg);
            assert(step.value, expectedError, msg);
            assert(step.done, true, msg);

            index++;
            return this;
        };

        this.custom = function (expectedValue, message = 'on custom event') {

            const msg = `step: ${index} - ${message}`;
            let step = logger[index];

            assert(step.type, 'custom', msg);
            assert(step.value, expectedValue, msg);
            assert(step.done, false, msg);

            index++;
            return this;
        };

        this.isFinal = function (message = '') {
            assert(index, logger.length, `expected final step: ${message}`);
        }; 
    }; 
    
    return new _assertLogger();
};

const getPromise = promiseHolder => {
    return new Promise((resolve, reject) => {
        promiseHolder.resolve = resolve;
        promiseHolder.reject = reject;
    });
};

var logger = new Logger();
const someValue = 'some-value';
const errorMessage = 'error-message';

async function * foo(value) {
  let re = yield '1:' + value;
  re = yield '2:' + re;
  re = yield '3:' + re;
  return 'end foo:' + re;
}

async function * boo(value) {
  let reply = yield '0:' + value;
  reply = yield* foo(reply);
  yield '4:' + reply;
}

var b = boo('init');

b.next('0').then(fulfillSpy(logger));
b.next('1').then(fulfillSpy(logger));
b.next('2').then(fulfillSpy(logger));
b.next('3').then(fulfillSpy(logger));
b.next('4').then(fulfillSpy(logger));
b.next('5').then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:init')
    .fullfilled('1:1')
    .fullfilled('2:2')
    .fullfilled('3:3')
    .fullfilled('4:end foo:4')
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
var b2 = boo(':value');

b2.next(':0').then(fulfillSpy(logger));
b2.next(':1').then(fulfillSpy(logger), rejectSpy(logger));
b2.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
b2.next(':2').then(fulfillSpy(logger));
b2.next(':3').then(fulfillSpy(logger));
b2.next(':4').then(fulfillSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0::value')
    .fullfilled('1::1')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
var b2 = boo('#value');

b2.next('#0').then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#1').then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#2').then(fulfillSpy(logger), rejectSpy(logger));
b2.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#3').then(fulfillSpy(logger), rejectSpy(logger));
b2.next('#4').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0:#value')
    .fullfilled('1:#1')
    .fullfilled('2:#2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

async function * bar() {
  yield '1';
  yield '2';
  throw new Error(errorMessage);
  yield '3';
  return 'end foo';
}

async function * baz() {
  yield '0';
  yield* bar();
  yield '4';
}

logger.clear();
var bz1 = baz();

bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));
bz1.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
let promiseHolder = {};

async function *joo() {
    yield '1';
    yield getPromise(promiseHolder);
}

async function *goo () {
    yield '0';
    yield* joo();
    yield '3';
}

let g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.resolve('2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('2')
    .fullfilled('3')
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('#2')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .fullfilledDone(someValue)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('#2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

g = goo();

g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));
g.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .rejected(new Error(errorMessage))
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

async function *koo() {
    yield '1';
    await getPromise(promiseHolder);
}

async function *loo () {
    yield '0';
    yield* joo();
    yield '3';
}

let l = loo();

l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

 assertLogger(logger)
    .fullfilled("0")
    .fullfilled("1")
    .isFinal();

promiseHolder.resolve('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .fullfilled('#2')
    .fullfilled("3")
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();
l = loo();

l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));
l.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled("0")
    .fullfilled("1")
    .isFinal();

promiseHolder.reject('#2');

drainMicrotasks();

assertLogger(logger)
    .fullfilled('0')
    .fullfilled('1')
    .rejected('#2')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

let asyncIter = {
    [Symbol.asyncIterator]() { return this; },
    next (value) {
        customSpy(logger)('next:' + value);
        return { value: value, done: 'iter:Finish' === value };
    },
    throw (error) {
        customSpy(logger)('throw:' + error);
        return error;
    },
    return(value) {
        customSpy(logger)('return:' + value);
        return { value: value, done: true };
    }
  };

async function *moo () {
    yield '0';
    yield* asyncIter;
    yield '3';
}

let m = moo('Init');

m.next('A').then(fulfillSpy(logger), rejectSpy(logger));
m.next('B').then(fulfillSpy(logger), rejectSpy(logger));
m.next('C').then(fulfillSpy(logger), rejectSpy(logger));
m.next('D').then(fulfillSpy(logger), rejectSpy(logger));
m.next('E').then(fulfillSpy(logger), rejectSpy(logger));
m.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
m.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('next:C')
    .fullfilled(undefined)
    .custom('next:D')
    .fullfilled('C')
    .custom('next:E')
    .fullfilled('D')
    .custom('next:iter:Finish')
    .fullfilled('E')
    .fullfilled('3')
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

m = moo('Init');

m.next('A').then(fulfillSpy(logger), rejectSpy(logger));
m.next('B').then(fulfillSpy(logger), rejectSpy(logger));
m.return('C').then(fulfillSpy(logger), rejectSpy(logger));
m.next('D').then(fulfillSpy(logger), rejectSpy(logger));
m.next('E').then(fulfillSpy(logger), rejectSpy(logger));
m.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
m.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('return:C')
    .fullfilled(undefined)
    .fullfilledDone('C')
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

m = moo('Init');

m.next('A').then(fulfillSpy(logger), rejectSpy(logger));
m.next('B').then(fulfillSpy(logger), rejectSpy(logger));
m.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));
m.next('D').then(fulfillSpy(logger), rejectSpy(logger));
m.next('E').then(fulfillSpy(logger), rejectSpy(logger));
m.next('iter:Finish').then(fulfillSpy(logger), rejectSpy(logger));
m.next('Finish').then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .custom('next:undefined')
    .fullfilled('0')
    .custom('throw:' + new Error(errorMessage))
    .fullfilled(undefined)
    .custom('next:D')
    .fullfilled(undefined)
    .custom('next:E')
    .fullfilled('D')
    .custom('next:iter:Finish')
    .fullfilled('E')
    .fullfilled('3')
    .fullfilledDone(undefined)
    .isFinal();

logger.clear();

async function* noo() {
  try {
    await Promise.reject("doop");
  } finally {
    yield* [1, 2, 3]; // Is this line reachable in this implementation?
  }
}

const n = noo();

n.next().then(fulfillSpy(logger), rejectSpy(logger));
n.next().then(fulfillSpy(logger), rejectSpy(logger));
n.next().then(fulfillSpy(logger), rejectSpy(logger));
n.next().then(fulfillSpy(logger), rejectSpy(logger));
n.next().then(fulfillSpy(logger), rejectSpy(logger));

drainMicrotasks();

assertLogger(logger)
    .fullfilled(1)
    .fullfilled(2)
    .fullfilled(3)
    .rejected('doop');
{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'var assert = function (result, expected, message = "") {',
       message: 'Parsing error: Unexpected token =',
       line: 1,
       column: 50 } ],
  output: 'var assert = function (result, expected, message = "") {\n  if (result !== expected) {\n    throw new Error(\'Error in assert. Expected "\' + expected + \'" but was "\' + result + \'":\' + message );\n  }\n};\n\nconst Logger = function () {\n    var log = [];\n\n    this.logEvent = (type, value, done) => {\n        log.push({ type, value, done});\n    };\n    this.logFulfilledEvent = (value, done) => {\n        this.logEvent(\'fulfilled\', value, done);\n    };\n    this.logRejectEvent = error => {\n        this.logEvent(\'reject\', error.toString(), true);\n    };\n    this.logCatchEvent = value => {\n        this.logEvent(\'catch\', value, true);\n    };\n    this.logCustomEvent = event => {\n        this.logEvent(\'custom\', event, false);\n    };\n    this.getLogger = () => log;\n\n    this.clear = () => {\n        log = [];\n    }\n};\n\nconst fulfillSpy = logger => result => logger.logFulfilledEvent(result.value, result.done);\nconst rejectSpy = logger => error => logger.logRejectEvent(error);\nconst catchSpy = logger => error => logger.logCatchEvent(error);\nconst customSpy = logger => event => logger.logCustomEvent(event);\n\nconst assertLogger = function (loggerObject) {\n    const logger = loggerObject.getLogger();\n\n    var _assertLogger = function () {\n        let index = 0;\n\n        const isNotOutOfLength = () => {\n            assert(index < logger.length, true, `Index is greater then log length`);   \n        }\n\n        this.fullfilled = function (expectedValue, message = \'on fulfill\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.fullfilledDone = function (expectedValue, message = \'on fulfill with done true\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'fulfilled\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.rejected = function (error, message = \'on reject\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'reject\', msg);\n            assert(step.value, error.toString(), msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.catched = function (expectedError, message = \'on catch\') {\n            isNotOutOfLength();\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'catch\', msg);\n            assert(step.value, expectedError, msg);\n            assert(step.done, true, msg);\n\n            index++;\n            return this;\n        };\n\n        this.custom = function (expectedValue, message = \'on custom event\') {\n\n            const msg = `step: ${index} - ${message}`;\n            let step = logger[index];\n\n            assert(step.type, \'custom\', msg);\n            assert(step.value, expectedValue, msg);\n            assert(step.done, false, msg);\n\n            index++;\n            return this;\n        };\n\n        this.isFinal = function (message = \'\') {\n            assert(index, logger.length, `expected final step: ${message}`);\n        }; \n    }; \n    \n    return new _assertLogger();\n};\n\nconst getPromise = promiseHolder => {\n    return new Promise((resolve, reject) => {\n        promiseHolder.resolve = resolve;\n        promiseHolder.reject = reject;\n    });\n};\n\nvar logger = new Logger();\nconst someValue = \'some-value\';\nconst errorMessage = \'error-message\';\n\nasync function * foo(value) {\n  let re = yield \'1:\' + value;\n  re = yield \'2:\' + re;\n  re = yield \'3:\' + re;\n  return \'end foo:\' + re;\n}\n\nasync function * boo(value) {\n  let reply = yield \'0:\' + value;\n  reply = yield* foo(reply);\n  yield \'4:\' + reply;\n}\n\nvar b = boo(\'init\');\n\nb.next(\'0\').then(fulfillSpy(logger));\nb.next(\'1\').then(fulfillSpy(logger));\nb.next(\'2\').then(fulfillSpy(logger));\nb.next(\'3\').then(fulfillSpy(logger));\nb.next(\'4\').then(fulfillSpy(logger));\nb.next(\'5\').then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:init\')\n    .fullfilled(\'1:1\')\n    .fullfilled(\'2:2\')\n    .fullfilled(\'3:3\')\n    .fullfilled(\'4:end foo:4\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nvar b2 = boo(\':value\');\n\nb2.next(\':0\').then(fulfillSpy(logger));\nb2.next(\':1\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\':2\').then(fulfillSpy(logger));\nb2.next(\':3\').then(fulfillSpy(logger));\nb2.next(\':4\').then(fulfillSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0::value\')\n    .fullfilled(\'1::1\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nvar b2 = boo(\'#value\');\n\nb2.next(\'#0\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#1\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#2\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#3\').then(fulfillSpy(logger), rejectSpy(logger));\nb2.next(\'#4\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0:#value\')\n    .fullfilled(\'1:#1\')\n    .fullfilled(\'2:#2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nasync function * bar() {\n  yield \'1\';\n  yield \'2\';\n  throw new Error(errorMessage);\n  yield \'3\';\n  return \'end foo\';\n}\n\nasync function * baz() {\n  yield \'0\';\n  yield* bar();\n  yield \'4\';\n}\n\nlogger.clear();\nvar bz1 = baz();\n\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\nbz1.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nlet promiseHolder = {};\n\nasync function *joo() {\n    yield \'1\';\n    yield getPromise(promiseHolder);\n}\n\nasync function *goo () {\n    yield \'0\';\n    yield* joo();\n    yield \'3\';\n}\n\nlet g = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.resolve(\'2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'2\')\n    .fullfilled(\'3\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'#2\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.return(someValue).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .fullfilledDone(someValue)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'#2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\ng = goo();\n\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\ng.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .rejected(new Error(errorMessage))\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nasync function *koo() {\n    yield \'1\';\n    await getPromise(promiseHolder);\n}\n\nasync function *loo () {\n    yield \'0\';\n    yield* joo();\n    yield \'3\';\n}\n\nlet l = loo();\n\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\n assertLogger(logger)\n    .fullfilled("0")\n    .fullfilled("1")\n    .isFinal();\n\npromiseHolder.resolve(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .fullfilled(\'#2\')\n    .fullfilled("3")\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\nl = loo();\n\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\nl.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled("0")\n    .fullfilled("1")\n    .isFinal();\n\npromiseHolder.reject(\'#2\');\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(\'0\')\n    .fullfilled(\'1\')\n    .rejected(\'#2\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nlet asyncIter = {\n    [Symbol.asyncIterator]() { return this; },\n    next (value) {\n        customSpy(logger)(\'next:\' + value);\n        return { value: value, done: \'iter:Finish\' === value };\n    },\n    throw (error) {\n        customSpy(logger)(\'throw:\' + error);\n        return error;\n    },\n    return(value) {\n        customSpy(logger)(\'return:\' + value);\n        return { value: value, done: true };\n    }\n  };\n\nasync function *moo () {\n    yield \'0\';\n    yield* asyncIter;\n    yield \'3\';\n}\n\nlet m = moo(\'Init\');\n\nm.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'C\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'E\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'next:C\')\n    .fullfilled(undefined)\n    .custom(\'next:D\')\n    .fullfilled(\'C\')\n    .custom(\'next:E\')\n    .fullfilled(\'D\')\n    .custom(\'next:iter:Finish\')\n    .fullfilled(\'E\')\n    .fullfilled(\'3\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nm = moo(\'Init\');\n\nm.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nm.return(\'C\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'E\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'return:C\')\n    .fullfilled(undefined)\n    .fullfilledDone(\'C\')\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nm = moo(\'Init\');\n\nm.next(\'A\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'B\').then(fulfillSpy(logger), rejectSpy(logger));\nm.throw(new Error(errorMessage)).then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'D\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'E\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'iter:Finish\').then(fulfillSpy(logger), rejectSpy(logger));\nm.next(\'Finish\').then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .custom(\'next:undefined\')\n    .fullfilled(\'0\')\n    .custom(\'throw:\' + new Error(errorMessage))\n    .fullfilled(undefined)\n    .custom(\'next:D\')\n    .fullfilled(undefined)\n    .custom(\'next:E\')\n    .fullfilled(\'D\')\n    .custom(\'next:iter:Finish\')\n    .fullfilled(\'E\')\n    .fullfilled(\'3\')\n    .fullfilledDone(undefined)\n    .isFinal();\n\nlogger.clear();\n\nasync function* noo() {\n  try {\n    await Promise.reject("doop");\n  } finally {\n    yield* [1, 2, 3]; // Is this line reachable in this implementation?\n  }\n}\n\nconst n = noo();\n\nn.next().then(fulfillSpy(logger), rejectSpy(logger));\nn.next().then(fulfillSpy(logger), rejectSpy(logger));\nn.next().then(fulfillSpy(logger), rejectSpy(logger));\nn.next().then(fulfillSpy(logger), rejectSpy(logger));\nn.next().then(fulfillSpy(logger), rejectSpy(logger));\n\ndrainMicrotasks();\n\nassertLogger(logger)\n    .fullfilled(1)\n    .fullfilled(2)\n    .fullfilled(3)\n    .rejected(\'doop\');' }
big-int-function-apply.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function foo() {
    return 0;
}

try {
    foo.apply({}, 2n);
    assert(false);
} catch(e) {
    assert(e.message == "second argument to Function.prototype.apply must be an Array-like object (evaluating 'foo.apply({}, 2n)')")
}


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    foo.apply({}, 2n);',
       message: 'Parsing error: Identifier directly after number',
       line: 13,
       column: 20 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction foo() {\n    return 0;\n}\n\ntry {\n    foo.apply({}, 2n);\n    assert(false);\n} catch(e) {\n    assert(e.message == "second argument to Function.prototype.apply must be an Array-like object (evaluating \'foo.apply({}, 2n)\')")\n}\n\n' }
big-int-literals.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function assertThrowSyntaxError(input) {
    try {
        eval(input);
        assert(false);
    } catch (e) {
        assert(e instanceof SyntaxError);
    }
}

// Test 0 conversions
let n = 0n;
assert(n === 0n);

n = 00n;
assert(n === 0n);

// Binary representation

n = 0b1111n;
assert(n === 15n);

n = 0b10n;
assert(n === 2n);

n = 0b010n;
assert(n === 2n);

let binaryString = "0b1";
for (let i = 0; i < 128; i++)
    binaryString += "0";

n = eval(binaryString + "n");
assert(n === 340282366920938463463374607431768211456n);

n = 0B1111n;
assert(n === 15n);

n = 0B10n;
assert(n === 2n);

binaryString = "0B1";
for (let i = 0; i < 128; i++)
    binaryString += "0";

n = eval(binaryString + "n");
assert(n === 340282366920938463463374607431768211456n);

// Octal representation

n = 0o7n;
assert(n === 7n);

n = 0o10n;
assert(n === 8n);

n = 0o20n;
assert(n === 16n);

n = 0o00020n;
assert(n === 16n);

n = 0O7n;
assert(n === 7n);

n = 0O10n;
assert(n === 8n);

n = 0O20n;
assert(n === 16n);

n = 0O20n;
assert(n === 16n);

// Hexadecimal representation

n = 0xan;
assert(n === 10n);

n = 0xffn;
assert(n === 255n);

n = 0x000ffn;
assert(n === 255n);

n = 0xfabcn;
assert(n === 64188n);

assertThrowSyntaxError("0b2n");
assertThrowSyntaxError("0b02n");
assertThrowSyntaxError("0b1nn");
assertThrowSyntaxError("0o89n");
assertThrowSyntaxError("0o08n");
assertThrowSyntaxError("0o7nn");
assertThrowSyntaxError("0xgn");
assertThrowSyntaxError("0x0gn");
assertThrowSyntaxError("0xfnn");
assertThrowSyntaxError("100nn");
assertThrowSyntaxError("1a0nn");
assertThrowSyntaxError("10E20n");

try {
    eval("--10n");
    assert(false);
} catch(e) {
    assert(e instanceof ReferenceError);
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let n = 0n;',
       message: 'Parsing error: Unexpected token n',
       line: 18,
       column: 5 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction assertThrowSyntaxError(input) {\n    try {\n        eval(input);\n        assert(false);\n    } catch (e) {\n        assert(e instanceof SyntaxError);\n    }\n}\n\n// Test 0 conversions\nlet n = 0n;\nassert(n === 0n);\n\nn = 00n;\nassert(n === 0n);\n\n// Binary representation\n\nn = 0b1111n;\nassert(n === 15n);\n\nn = 0b10n;\nassert(n === 2n);\n\nn = 0b010n;\nassert(n === 2n);\n\nlet binaryString = "0b1";\nfor (let i = 0; i < 128; i++)\n    binaryString += "0";\n\nn = eval(binaryString + "n");\nassert(n === 340282366920938463463374607431768211456n);\n\nn = 0B1111n;\nassert(n === 15n);\n\nn = 0B10n;\nassert(n === 2n);\n\nbinaryString = "0B1";\nfor (let i = 0; i < 128; i++)\n    binaryString += "0";\n\nn = eval(binaryString + "n");\nassert(n === 340282366920938463463374607431768211456n);\n\n// Octal representation\n\nn = 0o7n;\nassert(n === 7n);\n\nn = 0o10n;\nassert(n === 8n);\n\nn = 0o20n;\nassert(n === 16n);\n\nn = 0o00020n;\nassert(n === 16n);\n\nn = 0O7n;\nassert(n === 7n);\n\nn = 0O10n;\nassert(n === 8n);\n\nn = 0O20n;\nassert(n === 16n);\n\nn = 0O20n;\nassert(n === 16n);\n\n// Hexadecimal representation\n\nn = 0xan;\nassert(n === 10n);\n\nn = 0xffn;\nassert(n === 255n);\n\nn = 0x000ffn;\nassert(n === 255n);\n\nn = 0xfabcn;\nassert(n === 64188n);\n\nassertThrowSyntaxError("0b2n");\nassertThrowSyntaxError("0b02n");\nassertThrowSyntaxError("0b1nn");\nassertThrowSyntaxError("0o89n");\nassertThrowSyntaxError("0o08n");\nassertThrowSyntaxError("0o7nn");\nassertThrowSyntaxError("0xgn");\nassertThrowSyntaxError("0x0gn");\nassertThrowSyntaxError("0xfnn");\nassertThrowSyntaxError("100nn");\nassertThrowSyntaxError("1a0nn");\nassertThrowSyntaxError("10E20n");\n\ntry {\n    eval("--10n");\n    assert(false);\n} catch(e) {\n    assert(e instanceof ReferenceError);\n}\n' }
big-int-literal-line-terminator.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

var d;

assert(eval("d=5n\u000A") === 5n);
assert(d === 5n);

assert(eval("d=15n\u000D") === 15n);
assert(d === 15n);

assert(eval("d=19n\u2028;") === 19n);
assert(d === 19n);

assert(eval("d=95n\u2029;") === 95n);
assert(d === 95n);

assert(eval("d=\u000A5n") === 5n);
assert(d === 5n);

assert(eval("d=\u000D15n") === 15n);
assert(d === 15n);

assert(eval("d=\u202819n;") === 19n);
assert(d === 19n);

assert(eval("d=\u202995n;") === 95n);
assert(d === 95n);


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'assert(eval("d=5n\\u000A") === 5n);',
       message: 'Parsing error: Identifier directly after number',
       line: 10,
       column: 32 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nvar d;\n\nassert(eval("d=5n\\u000A") === 5n);\nassert(d === 5n);\n\nassert(eval("d=15n\\u000D") === 15n);\nassert(d === 15n);\n\nassert(eval("d=19n\\u2028;") === 19n);\nassert(d === 19n);\n\nassert(eval("d=95n\\u2029;") === 95n);\nassert(d === 95n);\n\nassert(eval("d=\\u000A5n") === 5n);\nassert(d === 5n);\n\nassert(eval("d=\\u000D15n") === 15n);\nassert(d === 15n);\n\nassert(eval("d=\\u202819n;") === 19n);\nassert(d === 19n);\n\nassert(eval("d=\\u202995n;") === 95n);\nassert(d === 95n);\n\n' }
big-int-operations-error.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function assertThrowTypeError(input) {
    try {
        eval(input);
        assert(false);
    } catch (e) {
        assert(e instanceof TypeError);
    }
}

assert("a" + 100n, "a100");
assert(128n + "baba", "128baba");

assertThrowTypeError("10n + 30");
assertThrowTypeError("36 + 15n");
assertThrowTypeError("120n + 30.5");
assertThrowTypeError("44.5 + 112034n");

assertThrowTypeError("10n - 30");
assertThrowTypeError("36 - 15n");
assertThrowTypeError("120n - 30.5");
assertThrowTypeError("44.5 - 112034n");

assertThrowTypeError("10n * 30");
assertThrowTypeError("36 * 15n");
assertThrowTypeError("120n * 30.5");
assertThrowTypeError("44.5 * 112034n");

assertThrowTypeError("10n / 30");
assertThrowTypeError("36 / 15n");
assertThrowTypeError("120n / 30.5");
assertThrowTypeError("44.5 / 112034n");

assertThrowTypeError("10n ** 30");
assertThrowTypeError("36 ** 15n");
assertThrowTypeError("120n ** 30.5");
assertThrowTypeError("44.5 ** 112034n");


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'assert("a" + 100n, "a100");',
       message: 'Parsing error: Identifier directly after number',
       line: 17,
       column: 17 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction assertThrowTypeError(input) {\n    try {\n        eval(input);\n        assert(false);\n    } catch (e) {\n        assert(e instanceof TypeError);\n    }\n}\n\nassert("a" + 100n, "a100");\nassert(128n + "baba", "128baba");\n\nassertThrowTypeError("10n + 30");\nassertThrowTypeError("36 + 15n");\nassertThrowTypeError("120n + 30.5");\nassertThrowTypeError("44.5 + 112034n");\n\nassertThrowTypeError("10n - 30");\nassertThrowTypeError("36 - 15n");\nassertThrowTypeError("120n - 30.5");\nassertThrowTypeError("44.5 - 112034n");\n\nassertThrowTypeError("10n * 30");\nassertThrowTypeError("36 * 15n");\nassertThrowTypeError("120n * 30.5");\nassertThrowTypeError("44.5 * 112034n");\n\nassertThrowTypeError("10n / 30");\nassertThrowTypeError("36 / 15n");\nassertThrowTypeError("120n / 30.5");\nassertThrowTypeError("44.5 / 112034n");\n\nassertThrowTypeError("10n ** 30");\nassertThrowTypeError("36 ** 15n");\nassertThrowTypeError("120n ** 30.5");\nassertThrowTypeError("44.5 ** 112034n");\n\n' }
big-int-prototype-symbol-to-string-tag.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled
// Original test from test262/test/built-ins/BigInt/prototype/Symbol.toStringTag.js

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

let p = Object.getOwnPropertyDescriptor(BigInt.prototype, Symbol.toStringTag);

assert(p.writable === false);
assert(p.enumerable === false);
assert(p.configurable === true);
assert(p.value === "BigInt");

assert(Object.prototype.toString.call(3n) === "[object BigInt]");
assert(Object.prototype.toString.call(Object(3n)) === "[object BigInt]");

// Verify that Object.prototype.toString does not have special casing for BigInt
// as it does for most other primitive types
Object.defineProperty(BigInt.prototype, Symbol.toStringTag, {
  value: "FooBar",
  writable: false,
  enumerable: false,
  configurable: true
});

assert(Object.prototype.toString.call(3n) === "[object FooBar]");
assert(Object.prototype.toString.call(Object(3n)) === "[object FooBar]");


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let p = Object.getOwnPropertyDescriptor(BigInt.prototype, Symbol.toStringTag);',
       message: 'Parsing error: Unexpected token p',
       line: 9,
       column: 5 } ],
  output: '//@ runBigIntEnabled\n// Original test from test262/test/built-ins/BigInt/prototype/Symbol.toStringTag.js\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nlet p = Object.getOwnPropertyDescriptor(BigInt.prototype, Symbol.toStringTag);\n\nassert(p.writable === false);\nassert(p.enumerable === false);\nassert(p.configurable === true);\nassert(p.value === "BigInt");\n\nassert(Object.prototype.toString.call(3n) === "[object BigInt]");\nassert(Object.prototype.toString.call(Object(3n)) === "[object BigInt]");\n\n// Verify that Object.prototype.toString does not have special casing for BigInt\n// as it does for most other primitive types\nObject.defineProperty(BigInt.prototype, Symbol.toStringTag, {\n  value: "FooBar",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nassert(Object.prototype.toString.call(3n) === "[object FooBar]");\nassert(Object.prototype.toString.call(Object(3n)) === "[object FooBar]");\n\n' }
big-int-prototype-to-string-cast-overflow.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function assertThrowRangeError(input) {
    try {
        let number = 3n;
        number.toString(input);
        assert(false);
    } catch (e) {
        assert(e instanceof RangeError);
    }
}

assertThrowRangeError(1e100);
assertThrowRangeError(-1e101);


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '        let number = 3n;',
       message: 'Parsing error: Unexpected token number',
       line: 10,
       column: 13 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction assertThrowRangeError(input) {\n    try {\n        let number = 3n;\n        number.toString(input);\n        assert(false);\n    } catch (e) {\n        assert(e instanceof RangeError);\n    }\n}\n\nassertThrowRangeError(1e100);\nassertThrowRangeError(-1e101);\n\n' }
big-int-prototype-to-string-apply.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function throwsTypeError(v) {
    try {
        BigInt.prototype.toString.apply(v);
        assert(false);
    } catch (e) {
        assert(e instanceof TypeError);
    }
}

throwsTypeError(3);
throwsTypeError(3.5);
throwsTypeError("ABC");
throwsTypeError(Symbol("test"));
throwsTypeError({});
throwsTypeError(true);
throwsTypeError([3n]);


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'throwsTypeError([3n]);',
       message: 'Parsing error: Identifier directly after number',
       line: 23,
       column: 19 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction throwsTypeError(v) {\n    try {\n        BigInt.prototype.toString.apply(v);\n        assert(false);\n    } catch (e) {\n        assert(e instanceof TypeError);\n    }\n}\n\nthrowsTypeError(3);\nthrowsTypeError(3.5);\nthrowsTypeError("ABC");\nthrowsTypeError(Symbol("test"));\nthrowsTypeError({});\nthrowsTypeError(true);\nthrowsTypeError([3n]);\n\n' }
big-int-prototype-to-string-wrong-values.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function assertRangeError(v) {
    let a = 456n;
    try {
        a.toString(v);
        assert(false);
    } catch (e) {
        assert(e instanceof RangeError);
    }
}

assertRangeError(1);
assertRangeError(37);
assertRangeError(37.1);
assertRangeError(37.2);
assertRangeError(0);
assertRangeError(-1);
assertRangeError(1.999999);
assertRangeError(37.00000000000000001);
assertRangeError(NaN);
assertRangeError(null);
assertRangeError(+Infinity);
assertRangeError(-Infinity);
assertRangeError(-0);


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let a = 456n;',
       message: 'Parsing error: Unexpected token a',
       line: 9,
       column: 9 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction assertRangeError(v) {\n    let a = 456n;\n    try {\n        a.toString(v);\n        assert(false);\n    } catch (e) {\n        assert(e instanceof RangeError);\n    }\n}\n\nassertRangeError(1);\nassertRangeError(37);\nassertRangeError(37.1);\nassertRangeError(37.2);\nassertRangeError(0);\nassertRangeError(-1);\nassertRangeError(1.999999);\nassertRangeError(37.00000000000000001);\nassertRangeError(NaN);\nassertRangeError(null);\nassertRangeError(+Infinity);\nassertRangeError(-Infinity);\nassertRangeError(-0);\n\n' }
big-int-prototype-to-string-exception.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

let o = {
    valueOf: () => {
        throw new Error("Bad");
        return 2;
    }
}

let a = 20n;
try {
    a.toString(o);
    assert(false);
} catch (e) {
    assert(e.message == "Bad");
}


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let o = {',
       message: 'Parsing error: Unexpected token o',
       line: 8,
       column: 5 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nlet o = {\n    valueOf: () => {\n        throw new Error("Bad");\n        return 2;\n    }\n}\n\nlet a = 20n;\ntry {\n    a.toString(o);\n    assert(false);\n} catch (e) {\n    assert(e.message == "Bad");\n}\n\n' }
big-int-to-string.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

let v = 10n;
assert(v.toString() === "10");
assert(v.toString(2) === "1010");
assert(v.toString(3) === "101");
assert(v.toString(8) === "12");
assert(v.toString(16) === "a");
assert(v.toString(32) === "a");

// Invaid radix

function testInvalidRadix(radix) {
    try {
        v.toString(radix);
        assert(false);
    } catch(e) {
        assert(e instanceof RangeError);
    }
}

testInvalidRadix(-10);
testInvalidRadix(-1);
testInvalidRadix(0);
testInvalidRadix(1);
testInvalidRadix(37);
testInvalidRadix(4294967312);


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let v = 10n;',
       message: 'Parsing error: Unexpected token v',
       line: 8,
       column: 5 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nlet v = 10n;\nassert(v.toString() === "10");\nassert(v.toString(2) === "1010");\nassert(v.toString(3) === "101");\nassert(v.toString(8) === "12");\nassert(v.toString(16) === "a");\nassert(v.toString(32) === "a");\n\n// Invaid radix\n\nfunction testInvalidRadix(radix) {\n    try {\n        v.toString(radix);\n        assert(false);\n    } catch(e) {\n        assert(e instanceof RangeError);\n    }\n}\n\ntestInvalidRadix(-10);\ntestInvalidRadix(-1);\ntestInvalidRadix(0);\ntestInvalidRadix(1);\ntestInvalidRadix(37);\ntestInvalidRadix(4294967312);\n\n' }
big-int-type-of.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

assert(typeof 0n === "bigint");
assert(typeof 1n !== "object");


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'assert(typeof 0n === "bigint");',
       message: 'Parsing error: Identifier directly after number',
       line: 8,
       column: 16 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nassert(typeof 0n === "bigint");\nassert(typeof 1n !== "object");\n\n' }
big-int-white-space-trailing-leading.js:SyntaxError: Identifier directly after number
//@ runBigIntEnabled

function assert(a) {
    if (!a)
        throw new Error("Bad assertion");
}

function assertThrowSyntaxError(input) {
    try {
        eval(input);
        assert(false);
    } catch (e) {
        assert(e instanceof SyntaxError);
    }
}

var d;

assert(eval("d=\u000C5n") === 5n);
assert(d === 5n);

assert(eval("d=\u000915n") === 15n);
assert(d === 15n);

assert(eval("d=\u000B19n\u000B;") === 19n);
assert(d === 19n);

assert(eval("d=\u000C119n;") === 119n);
assert(d === 119n);

assert(eval("d=\u002095n;") === 95n);
assert(d === 95n);

assert(eval("d=\u00A053n;") === 53n);
assert(d === 53n);

assert(eval("d=\uFEFF39n;") === 39n);
assert(d === 39n);

assert(eval("d=5n\u000C") === 5n);
assert(d === 5n);

assert(eval("d=15n\u0009") === 15n);
assert(d === 15n);

assert(eval("d=19n\u000B;") === 19n);
assert(d === 19n);

assert(eval("d=119n\u000C;") === 119n);
assert(d === 119n);

assert(eval("d=95n\u0020;") === 95n);
assert(d === 95n);

assert(eval("d=53n\u00A0;") === 53n);
assert(d === 53n);

assert(eval("d=39n\uFEFF;") === 39n);
assert(d === 39n);

assert(eval("\u000C\u000Cd\u000C\u000C=\u000C\u000C5n\u000C;\u000C") === 5n);
assert(d === 5n);

assert(eval("\u0009\u0009d\u0009\u0009=\u0009\u000915n\u0009;") === 15n);
assert(d === 15n);

assert(eval("\u000B\u000Bd\u000B\u000B=\u000B\u000B19n\u000B;") === 19n);
assert(d === 19n);

assert(eval("\u000C\u000Cd\u000C=\u000C\u000C119n;") === 119n);
assert(d === 119n);

assert(eval("\u0020d\u0020=\u0020\u002095n;") === 95n);
assert(d === 95n);

assert(eval("\u00A0d\u00A0=\u00A0\u00A053n;") === 53n);
assert(d === 53n);

assert(eval("\uFEFFd\uFEFF=\uFEFF\uFEFF39n;") === 39n);
assert(d === 39n);

// Assert errors

assertThrowSyntaxError("0b\u000C2n");
assertThrowSyntaxError("0b\u000B1101n");
assertThrowSyntaxError("0b\u0009111111n");
assertThrowSyntaxError("0b\u002010101n");
assertThrowSyntaxError("0b\u00A01011n");
assertThrowSyntaxError("0b\uFEFF111000n");

assertThrowSyntaxError("0o\u000C2n");
assertThrowSyntaxError("0o\u000B45n");
assertThrowSyntaxError("0o\u000977n");
assertThrowSyntaxError("0o\u0020777n");
assertThrowSyntaxError("0o\u00A01777n");
assertThrowSyntaxError("0o\uFEFF17361n");

assertThrowSyntaxError("0x\u000C2n");
assertThrowSyntaxError("0x\u000B45n");
assertThrowSyntaxError("0x\u000977n");
assertThrowSyntaxError("0x\u0020777n");
assertThrowSyntaxError("0x\u00A01777n");
assertThrowSyntaxError("0x\uFEFF17361n");

assertThrowSyntaxError("2\u000Cn");
assertThrowSyntaxError("45\u000Bn");
assertThrowSyntaxError("77\u0009n");
assertThrowSyntaxError("777\u0020n");
assertThrowSyntaxError("1777\u00A0n");
assertThrowSyntaxError("17361\uFEFFn");


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'assert(eval("d=\\u000C5n") === 5n);',
       message: 'Parsing error: Identifier directly after number',
       line: 19,
       column: 32 } ],
  output: '//@ runBigIntEnabled\n\nfunction assert(a) {\n    if (!a)\n        throw new Error("Bad assertion");\n}\n\nfunction assertThrowSyntaxError(input) {\n    try {\n        eval(input);\n        assert(false);\n    } catch (e) {\n        assert(e instanceof SyntaxError);\n    }\n}\n\nvar d;\n\nassert(eval("d=\\u000C5n") === 5n);\nassert(d === 5n);\n\nassert(eval("d=\\u000915n") === 15n);\nassert(d === 15n);\n\nassert(eval("d=\\u000B19n\\u000B;") === 19n);\nassert(d === 19n);\n\nassert(eval("d=\\u000C119n;") === 119n);\nassert(d === 119n);\n\nassert(eval("d=\\u002095n;") === 95n);\nassert(d === 95n);\n\nassert(eval("d=\\u00A053n;") === 53n);\nassert(d === 53n);\n\nassert(eval("d=\\uFEFF39n;") === 39n);\nassert(d === 39n);\n\nassert(eval("d=5n\\u000C") === 5n);\nassert(d === 5n);\n\nassert(eval("d=15n\\u0009") === 15n);\nassert(d === 15n);\n\nassert(eval("d=19n\\u000B;") === 19n);\nassert(d === 19n);\n\nassert(eval("d=119n\\u000C;") === 119n);\nassert(d === 119n);\n\nassert(eval("d=95n\\u0020;") === 95n);\nassert(d === 95n);\n\nassert(eval("d=53n\\u00A0;") === 53n);\nassert(d === 53n);\n\nassert(eval("d=39n\\uFEFF;") === 39n);\nassert(d === 39n);\n\nassert(eval("\\u000C\\u000Cd\\u000C\\u000C=\\u000C\\u000C5n\\u000C;\\u000C") === 5n);\nassert(d === 5n);\n\nassert(eval("\\u0009\\u0009d\\u0009\\u0009=\\u0009\\u000915n\\u0009;") === 15n);\nassert(d === 15n);\n\nassert(eval("\\u000B\\u000Bd\\u000B\\u000B=\\u000B\\u000B19n\\u000B;") === 19n);\nassert(d === 19n);\n\nassert(eval("\\u000C\\u000Cd\\u000C=\\u000C\\u000C119n;") === 119n);\nassert(d === 119n);\n\nassert(eval("\\u0020d\\u0020=\\u0020\\u002095n;") === 95n);\nassert(d === 95n);\n\nassert(eval("\\u00A0d\\u00A0=\\u00A0\\u00A053n;") === 53n);\nassert(d === 53n);\n\nassert(eval("\\uFEFFd\\uFEFF=\\uFEFF\\uFEFF39n;") === 39n);\nassert(d === 39n);\n\n// Assert errors\n\nassertThrowSyntaxError("0b\\u000C2n");\nassertThrowSyntaxError("0b\\u000B1101n");\nassertThrowSyntaxError("0b\\u0009111111n");\nassertThrowSyntaxError("0b\\u002010101n");\nassertThrowSyntaxError("0b\\u00A01011n");\nassertThrowSyntaxError("0b\\uFEFF111000n");\n\nassertThrowSyntaxError("0o\\u000C2n");\nassertThrowSyntaxError("0o\\u000B45n");\nassertThrowSyntaxError("0o\\u000977n");\nassertThrowSyntaxError("0o\\u0020777n");\nassertThrowSyntaxError("0o\\u00A01777n");\nassertThrowSyntaxError("0o\\uFEFF17361n");\n\nassertThrowSyntaxError("0x\\u000C2n");\nassertThrowSyntaxError("0x\\u000B45n");\nassertThrowSyntaxError("0x\\u000977n");\nassertThrowSyntaxError("0x\\u0020777n");\nassertThrowSyntaxError("0x\\u00A01777n");\nassertThrowSyntaxError("0x\\uFEFF17361n");\n\nassertThrowSyntaxError("2\\u000Cn");\nassertThrowSyntaxError("45\\u000Bn");\nassertThrowSyntaxError("77\\u0009n");\nassertThrowSyntaxError("777\\u0020n");\nassertThrowSyntaxError("1777\\u00A0n");\nassertThrowSyntaxError("17361\\uFEFFn");\n\n' }
caller-and-arguments-properties-for-functions-that-dont-have-them.js:SyntaxError: Unexpected token function
function assert(b) {
    if (!b)
        throw new Error;
}

function test1(f) {
    f.__proto__ = {};
    Object.defineProperty(f, "caller", {value:42});
    assert(f.caller === 42);
    Object.defineProperty(f, "arguments", {value:32});
    assert(f.arguments === 32);
}
for (let i = 0; i < 1000; ++i) {
    test1(function () { "use strict"; });
    test1(class C { });
    test1(() => undefined);
    test1(async function foo(){});
    test1(function* foo() { });
}

function test2(f, p = {}) {
    f.__proto__ = p;
    f.caller = 42;
    assert(f.caller === 42);
    f.arguments = 44;
    assert(f.arguments === 44);
}

{
    let proxy = new Proxy({}, {
        has(...args) {
            throw new Error("Should not be called!");
        }
    });
    for (let i = 0; i < 1000; ++i) {
        test2(function () { "use strict"; }, proxy);
        test2(class C { }, proxy);
        test2(() => undefined, proxy);
        test2(async function foo(){}, proxy);
        test2(function* foo() { }, proxy);
    }
}

for (let i = 0; i < 1000; ++i) {
    test2(function () { "use strict"; });
    test2(class C { });
    test2(() => undefined);
    test2(async function foo(){});
    test2(function* foo() { });
}

function test3(f) {
    f.__proto__ = {};
    f.caller = 42;
    assert(f.caller === 42);
    assert(f.hasOwnProperty("caller"));
    assert(delete f.caller === true);
    assert(f.caller === undefined);
    assert(!f.hasOwnProperty("caller"));

    f.arguments = 44;
    assert(f.arguments === 44);
    assert(f.hasOwnProperty("arguments"));
    assert(delete f.arguments === true);
    assert(f.arguments === undefined);
    assert(!f.hasOwnProperty("arguments"));
}
for (let i = 0; i < 1000; ++i) {
    test3(function () { "use strict"; });
    test3(class C { });
    test3(() => undefined);
    test3(async function foo(){});
    test3(function* foo() { });
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'for (let i = 0; i < 1000; ++i) {',
       message: 'Parsing error: Unexpected token i',
       line: 13,
       column: 10 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error;\n}\n\nfunction test1(f) {\n    f.__proto__ = {};\n    Object.defineProperty(f, "caller", {value:42});\n    assert(f.caller === 42);\n    Object.defineProperty(f, "arguments", {value:32});\n    assert(f.arguments === 32);\n}\nfor (let i = 0; i < 1000; ++i) {\n    test1(function () { "use strict"; });\n    test1(class C { });\n    test1(() => undefined);\n    test1(async function foo(){});\n    test1(function* foo() { });\n}\n\nfunction test2(f, p = {}) {\n    f.__proto__ = p;\n    f.caller = 42;\n    assert(f.caller === 42);\n    f.arguments = 44;\n    assert(f.arguments === 44);\n}\n\n{\n    let proxy = new Proxy({}, {\n        has(...args) {\n            throw new Error("Should not be called!");\n        }\n    });\n    for (let i = 0; i < 1000; ++i) {\n        test2(function () { "use strict"; }, proxy);\n        test2(class C { }, proxy);\n        test2(() => undefined, proxy);\n        test2(async function foo(){}, proxy);\n        test2(function* foo() { }, proxy);\n    }\n}\n\nfor (let i = 0; i < 1000; ++i) {\n    test2(function () { "use strict"; });\n    test2(class C { });\n    test2(() => undefined);\n    test2(async function foo(){});\n    test2(function* foo() { });\n}\n\nfunction test3(f) {\n    f.__proto__ = {};\n    f.caller = 42;\n    assert(f.caller === 42);\n    assert(f.hasOwnProperty("caller"));\n    assert(delete f.caller === true);\n    assert(f.caller === undefined);\n    assert(!f.hasOwnProperty("caller"));\n\n    f.arguments = 44;\n    assert(f.arguments === 44);\n    assert(f.hasOwnProperty("arguments"));\n    assert(delete f.arguments === true);\n    assert(f.arguments === undefined);\n    assert(!f.hasOwnProperty("arguments"));\n}\nfor (let i = 0; i < 1000; ++i) {\n    test3(function () { "use strict"; });\n    test3(class C { });\n    test3(() => undefined);\n    test3(async function foo(){});\n    test3(function* foo() { });\n}\n' }
catch-set-argument-speculation-failure.js:SyntaxError: Unexpected token {
"use strict";

let flag = true;
function o() {
    if (flag)
        return {x:20};
    return {y:20, x:20};
}
noInline(o);

let counter = 0;
function e() {
    if ((++counter) % 50 === 0)
        throw new Error;
}
noInline(e);

let counter2 = 0;
function e2() {
    if ((++counter2) % 2 === 0)
        throw new Error;
}
noInline(e2);

function escape(){ }
noInline(escape);

function baz(o) {
    try {
        e();
        escape(o.x);
    } catch(e) {
        escape(o.x);
        e2();
    } finally {
        o.x;
    }
}
noInline(baz);

{
    let o = {x:20};
    function run() {
        for (let i = 0; i < 1000; ++i) {
            try {
                baz(o);
            } catch { }
        }
    }
    run();
    o = {y:40, x:20};
    run();
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let flag = true;',
       message: 'Parsing error: The keyword \'let\' is reserved',
       line: 3,
       column: 1 } ],
  output: '"use strict";\n\nlet flag = true;\nfunction o() {\n    if (flag)\n        return {x:20};\n    return {y:20, x:20};\n}\nnoInline(o);\n\nlet counter = 0;\nfunction e() {\n    if ((++counter) % 50 === 0)\n        throw new Error;\n}\nnoInline(e);\n\nlet counter2 = 0;\nfunction e2() {\n    if ((++counter2) % 2 === 0)\n        throw new Error;\n}\nnoInline(e2);\n\nfunction escape(){ }\nnoInline(escape);\n\nfunction baz(o) {\n    try {\n        e();\n        escape(o.x);\n    } catch(e) {\n        escape(o.x);\n        e2();\n    } finally {\n        o.x;\n    }\n}\nnoInline(baz);\n\n{\n    let o = {x:20};\n    function run() {\n        for (let i = 0; i < 1000; ++i) {\n            try {\n                baz(o);\n            } catch { }\n        }\n    }\n    run();\n    o = {y:40, x:20};\n    run();\n}\n' }
destructuring-rest-element.js:SyntaxError: Unexpected token [
function assert(b) {
    if (!b)
        throw new Error("Bad assertion")
}
noInline(assert);

function test(f, count = 1000) {
    for (let i = 0; i < count; i++)
        f();
}

function arr() {
    return [10, 20, 30, 40];
}
noInline(arr);

let o = {};
function arr2() {
    return [10, 20, 30, [40, 50, o]];
}
noInline(arr);

function eq(a, b) {
    // This only works for arrays with nested arrays in them, and numbers or anything else strict equal to each other. 
    if (!(a instanceof Array))
        return a === b;

    if (a.length !== b.length)
        return false;

    for (let i = 0; i < a.length; i++) {
        let e1 = a[i];
        let e2 = b[i];
        if (!eq(e1, e2))
            return false;
    }

    return true;
}

test(function() {
    let [...[...x]] = arr();
    assert(eq(x, arr()));
});

test(function() {
    let [ , , , [...e]] = arr2();
    assert(eq(e, [40, 50, o]));
});

test(function() {
    let [ , , , ...e] = arr2();
    assert(eq(e[0], [40, 50, o]));
});

test(function() {
    let [ , , , ...e] = arr2();
    assert(eq(e[0], [40, 50, o]));
});

function* gen() {
    yield [1,2,3];
    yield 20;
    yield 30;
    yield 40;
}

test(function() {
    let [a, b, ...[...c]] = gen();
    assert(eq(a, [1,2,3]));
    assert(b === 20);
    assert(eq(c, [30, 40]));
});

test(function() {
    let [[a, ...d], b, ...[...c]] = gen();
    assert(a === 1);
    assert(eq(d, [2,3]));
    assert(b === 20);
    assert(eq(c, [30, 40]));
});

let called = false;
function fakeGen() { 
    return {
        [Symbol.iterator]: function() {
            let count = 0;
            return {
                next() {
                    called = true;
                    count++;
                    if (count === 1)
                        return {done: false, value: 50};
                    return {done: true};
                }
            };
        }
    };
}

test(function() {
    called = false;
    let [...x] = fakeGen();
    assert(eq(x, [50]));
    assert(called);
    called = false;
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function test(f, count = 1000) {',
       message: 'Parsing error: Unexpected token =',
       line: 7,
       column: 24 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad assertion")\n}\nnoInline(assert);\n\nfunction test(f, count = 1000) {\n    for (let i = 0; i < count; i++)\n        f();\n}\n\nfunction arr() {\n    return [10, 20, 30, 40];\n}\nnoInline(arr);\n\nlet o = {};\nfunction arr2() {\n    return [10, 20, 30, [40, 50, o]];\n}\nnoInline(arr);\n\nfunction eq(a, b) {\n    // This only works for arrays with nested arrays in them, and numbers or anything else strict equal to each other. \n    if (!(a instanceof Array))\n        return a === b;\n\n    if (a.length !== b.length)\n        return false;\n\n    for (let i = 0; i < a.length; i++) {\n        let e1 = a[i];\n        let e2 = b[i];\n        if (!eq(e1, e2))\n            return false;\n    }\n\n    return true;\n}\n\ntest(function() {\n    let [...[...x]] = arr();\n    assert(eq(x, arr()));\n});\n\ntest(function() {\n    let [ , , , [...e]] = arr2();\n    assert(eq(e, [40, 50, o]));\n});\n\ntest(function() {\n    let [ , , , ...e] = arr2();\n    assert(eq(e[0], [40, 50, o]));\n});\n\ntest(function() {\n    let [ , , , ...e] = arr2();\n    assert(eq(e[0], [40, 50, o]));\n});\n\nfunction* gen() {\n    yield [1,2,3];\n    yield 20;\n    yield 30;\n    yield 40;\n}\n\ntest(function() {\n    let [a, b, ...[...c]] = gen();\n    assert(eq(a, [1,2,3]));\n    assert(b === 20);\n    assert(eq(c, [30, 40]));\n});\n\ntest(function() {\n    let [[a, ...d], b, ...[...c]] = gen();\n    assert(a === 1);\n    assert(eq(d, [2,3]));\n    assert(b === 20);\n    assert(eq(c, [30, 40]));\n});\n\nlet called = false;\nfunction fakeGen() { \n    return {\n        [Symbol.iterator]: function() {\n            let count = 0;\n            return {\n                next() {\n                    called = true;\n                    count++;\n                    if (count === 1)\n                        return {done: false, value: 50};\n                    return {done: true};\n                }\n            };\n        }\n    };\n}\n\ntest(function() {\n    called = false;\n    let [...x] = fakeGen();\n    assert(eq(x, [50]));\n    assert(called);\n    called = false;\n});\n' }
dont-crash-when-hoist-check-structure-on-tdz.js:SyntaxError: Unexpected token {
class Foo extends Object {
    constructor(c1, c2) {
        if (c1)
            super();
        let arrow = () => {
            if (c2)
                this.foo = 20;
            else
                this.foo = 40;
        };
        noInline(arrow);
        arrow();
    }
}
noInline(Foo);

for (let i = 0; i < 1000; ++i)
    new Foo(true, !!(i%2));

let threw = false;
try {
    new Foo(false, true);
} catch {
    threw = true;
} finally {
    if (!threw)
        throw new Error("Bad")
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'class Foo extends Object {',
       message: 'Parsing error: The keyword \'class\' is reserved',
       line: 1,
       column: 1 } ],
  output: 'class Foo extends Object {\n    constructor(c1, c2) {\n        if (c1)\n            super();\n        let arrow = () => {\n            if (c2)\n                this.foo = 20;\n            else\n                this.foo = 40;\n        };\n        noInline(arrow);\n        arrow();\n    }\n}\nnoInline(Foo);\n\nfor (let i = 0; i < 1000; ++i)\n    new Foo(true, !!(i%2));\n\nlet threw = false;\ntry {\n    new Foo(false, true);\n} catch {\n    threw = true;\n} finally {\n    if (!threw)\n        throw new Error("Bad")\n}\n' }
dont-strength-reduce-valuerep-of-doublerep.js:SyntaxError: Unexpected token *
let a2 = [];
let thingy = {length: 2**55, __proto__: []};
let func = (x) => x;

noInline(Array.prototype.map);

// This test should not crash.
for (let i = 0; i < 100000; ++i) {
    try {
        if (i > 0 && (i % 1000) === 0)
            thingy.map(func)
        a2.map(func);
    } catch(e) {
    }
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let a2 = [];',
       message: 'Parsing error: Unexpected token a2',
       line: 1,
       column: 5 } ],
  output: 'let a2 = [];\nlet thingy = {length: 2**55, __proto__: []};\nlet func = (x) => x;\n\nnoInline(Array.prototype.map);\n\n// This test should not crash.\nfor (let i = 0; i < 100000; ++i) {\n    try {\n        if (i > 0 && (i % 1000) === 0)\n            thingy.map(func)\n        a2.map(func);\n    } catch(e) {\n    }\n}\n' }
flush-after-force-exit-in-bytecodeparser-needs-to-update-argument-positions.js:SyntaxError: Unexpected token {
//@ runDefault("--useConcurrentGC=0", "--thresholdForJITAfterWarmUp=10", "--thresholdForJITSoon=10", "--thresholdForOptimizeAfterWarmUp=20", "--thresholdForOptimizeAfterLongWarmUp=20", "--thresholdForOptimizeSoon=20", "--thresholdForFTLOptimizeAfterWarmUp=20", "--thresholdForFTLOptimizeSoon=20", "--maximumEvalCacheableSourceLength=150000", "--maxPerThreadStackUsage=1048576")

function runNearStackLimit(f) {
    function t() {
        try {
            return t();
        } catch (e) {
            return f();
        }
    }
    return t();
};

runNearStackLimit(() => { });
runNearStackLimit(() => { });

function f2(a, b) {
    'use strict';
    try {
        a.push(arguments[0] + arguments[2] + a + undefinedVariable);
    } catch (e) { }
}

try {
    runNearStackLimit(() => {
        return f2(1, 2, 3);
    });
} catch (e) {}

try {
    runNearStackLimit();
} catch { }

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'runNearStackLimit(() => { });',
       message: 'Parsing error: Unexpected token )',
       line: 14,
       column: 20 } ],
  output: '//@ runDefault("--useConcurrentGC=0", "--thresholdForJITAfterWarmUp=10", "--thresholdForJITSoon=10", "--thresholdForOptimizeAfterWarmUp=20", "--thresholdForOptimizeAfterLongWarmUp=20", "--thresholdForOptimizeSoon=20", "--thresholdForFTLOptimizeAfterWarmUp=20", "--thresholdForFTLOptimizeSoon=20", "--maximumEvalCacheableSourceLength=150000", "--maxPerThreadStackUsage=1048576")\n\nfunction runNearStackLimit(f) {\n    function t() {\n        try {\n            return t();\n        } catch (e) {\n            return f();\n        }\n    }\n    return t();\n};\n\nrunNearStackLimit(() => { });\nrunNearStackLimit(() => { });\n\nfunction f2(a, b) {\n    \'use strict\';\n    try {\n        a.push(arguments[0] + arguments[2] + a + undefinedVariable);\n    } catch (e) { }\n}\n\ntry {\n    runNearStackLimit(() => {\n        return f2(1, 2, 3);\n    });\n} catch (e) {}\n\ntry {\n    runNearStackLimit();\n} catch { }\n' }
for-in-invalidate-context-weird-assignments.js:SyntaxError: Unexpected token ...
function assert(b) {
    if (!b)
        throw new Error("Bad");
}

function test(f) {
    noInline(f);
    for (let i = 0; i < 1000; ++i)
        f();
}

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        for (i in [0, 1, 2]) { }
        assert(typeof i === "string");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        for (var i of [0]) { }
        assert(typeof i === "number");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        for ({i} of [{i: 0}]) { }
        assert(typeof i === "number");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        ;({i} = {i: 0});
        assert(typeof i === "number");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        ;([i] = [0]);
        assert(typeof i === "number");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        ;({...i} = {a:20, b:30});
        assert(typeof i === "object");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        eval("i = 0;");
        assert(typeof i === "number");
        assert(o[i] === undefined);
    }
});

test(function() {
    let o = {xx: 0};
    for (let i in o) {
        var i = 0;
        assert(typeof i === "number");
        assert(o[i] === undefined);
    }
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    for (let i = 0; i < 1000; ++i)',
       message: 'Parsing error: Unexpected token i',
       line: 8,
       column: 14 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad");\n}\n\nfunction test(f) {\n    noInline(f);\n    for (let i = 0; i < 1000; ++i)\n        f();\n}\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        for (i in [0, 1, 2]) { }\n        assert(typeof i === "string");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        for (var i of [0]) { }\n        assert(typeof i === "number");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        for ({i} of [{i: 0}]) { }\n        assert(typeof i === "number");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        ;({i} = {i: 0});\n        assert(typeof i === "number");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        ;([i] = [0]);\n        assert(typeof i === "number");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        ;({...i} = {a:20, b:30});\n        assert(typeof i === "object");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        eval("i = 0;");\n        assert(typeof i === "number");\n        assert(o[i] === undefined);\n    }\n});\n\ntest(function() {\n    let o = {xx: 0};\n    for (let i in o) {\n        var i = 0;\n        assert(typeof i === "number");\n        assert(o[i] === undefined);\n    }\n});\n' }
for-in-tests.js:SyntaxError: Identifier 'p' has already been declared
(function() {
    // Iterate over an array with normal indexed properties.
    var foo = function() {
        var a = [1, 2, 3, 4, 5];
        var sum = 0;
        var result = "";
        for (var p in a)
            result += a[p];
        return result;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        if (foo() !== "12345")
            throw new Error("bad result");
    }
    foo(null);
})();
(function() {
    // Iterate over an object with normal non-indexed properties.
    var foo = function() {
        var o = {};
        o.x = 1;
        o.y = 2;
        o.z = 3;
        var result = "";
        for (var p in o)
            result += o[p];
        return result;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        if (foo() !== "123")
            throw new Error("bad result");
    }
    foo(null);
})();
(function() {
    // Iterate over an object with both indexed and non-indexed properties.
    var foo = function() {
        var o = {};
        o.x = 1;
        o.y = 2;
        o.z = 3;
        o[0] = 4;
        o[1] = 5;
        o[2] = 6;
        var result = "";
        for (var p in o)
            result += o[p];
        return result;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        if (foo() != "456123")
            throw new Error("bad result");
    }
    foo(null);
})();
(function() {
    // Iterate over an array with both indexed and non-indexed properties.
    var foo = function() {
        var a = [4, 5, 6];
        a.x = 1;
        a.y = 2;
        a.z = 3;
        var result = "";
        for (var p in a)
            result += a[p];
        return result;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        if (foo() !== "456123")
            throw new Error("bad result");
    }
    foo(null);
})();
(function() {
    var foo = function(a, b) {
        for (var p in b) {
            var f1 = a[p];
            var f2 = b[p];
            if (f1 === f2)
                continue;
            a[p] = b[p];
        }
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        var o1 = {};
        var o2 = {};
        o2.x = 42;
        o2.y = 53;
        foo(o1, o2);
        if (o1.x !== o2.x)
            throw new Error("bad result: " + o1.x + "!==" + o2.x);
        if (o1.y !== o2.y)
            throw new Error("bad result: " + o1.y + "!==" + o2.y);
    }
})();

(function() {
    var foo = function(a, b) {
        for (var p = b in a) {}
        return p;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        var expected = 'expected-result';
        var result = foo({}, expected);
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }
    for (var i = 0; i < 10000; ++i) {
        var expected = 'a';
        var result = foo({a:'abcd'}, expected);
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }
    for (var i = 0; i < 10000; ++i) {
        var expected = 'b';
        var result = foo({a:'abcd', b: 'bcde'}, expected);
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }

    for (var i = 0; i < 10000; ++i) {
        var expected = 'c';
        var o = {a:'abcd', b: 'bcde'};
        o.c = 'cdef';
        var result = foo(o, expected);
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }
})();

(function() {
    var boo = function () { return 'expected-result'; };
    var foo = function(a) {
        for (var p = boo() in a) {}
        return p;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        var expected = 'expected-result';
        var result = foo({});
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }
})();

(function() {
    var foo = function(a, b, first) {
        {   
            let p = 'some-value';
            for (var p = b in a) {}
            if (first)
                return p;
        }
        return p;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        var expected = 'expected-result';
        var result = foo({}, expected, true);
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }
    for (var i = 0; i < 10000; ++i) {
        var expected = 'expected-result';
        var result = foo({}, expected, false);
        if (typeof result !== 'undefined')
            throw new Error("bad result: " + result + "!== undefined");
    }
})();

(function() {
    var foo = function(a, b, c) {
        for (var p = b + c in a) {}
        return p;
    };
    noInline(foo);
    for (var i = 0; i < 10000; ++i) {
        var expected = 'expected-result';
        var result = foo({}, 'expected', '-result');
        if (expected !== result)
            throw new Error("bad result: " + result + "!==" + expected);
    }
})();

(function() {
    var error = false;
    try {
        eval("(function() { 'use strict'; for (var i = 0 in {}) {}})()");
    } catch(e) {
        error = e instanceof SyntaxError;
    }
    if (!error)
        throw new Error("Expected SyntaxError error");
})();

(function() {
    var error = false;
    try {
        eval("(function() { const i = 10; for (var i = 0 in {}) {}})()");
    } catch(e) {
        error = e instanceof SyntaxError;
    }
    if (!error)
        throw new Error("Expected SyntaxError error");
})();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '            let p = \'some-value\';',
       message: 'Parsing error: Unexpected token p',
       line: 155,
       column: 17 } ],
  output: '(function() {\n    // Iterate over an array with normal indexed properties.\n    var foo = function() {\n        var a = [1, 2, 3, 4, 5];\n        var sum = 0;\n        var result = "";\n        for (var p in a)\n            result += a[p];\n        return result;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        if (foo() !== "12345")\n            throw new Error("bad result");\n    }\n    foo(null);\n})();\n(function() {\n    // Iterate over an object with normal non-indexed properties.\n    var foo = function() {\n        var o = {};\n        o.x = 1;\n        o.y = 2;\n        o.z = 3;\n        var result = "";\n        for (var p in o)\n            result += o[p];\n        return result;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        if (foo() !== "123")\n            throw new Error("bad result");\n    }\n    foo(null);\n})();\n(function() {\n    // Iterate over an object with both indexed and non-indexed properties.\n    var foo = function() {\n        var o = {};\n        o.x = 1;\n        o.y = 2;\n        o.z = 3;\n        o[0] = 4;\n        o[1] = 5;\n        o[2] = 6;\n        var result = "";\n        for (var p in o)\n            result += o[p];\n        return result;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        if (foo() != "456123")\n            throw new Error("bad result");\n    }\n    foo(null);\n})();\n(function() {\n    // Iterate over an array with both indexed and non-indexed properties.\n    var foo = function() {\n        var a = [4, 5, 6];\n        a.x = 1;\n        a.y = 2;\n        a.z = 3;\n        var result = "";\n        for (var p in a)\n            result += a[p];\n        return result;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        if (foo() !== "456123")\n            throw new Error("bad result");\n    }\n    foo(null);\n})();\n(function() {\n    var foo = function(a, b) {\n        for (var p in b) {\n            var f1 = a[p];\n            var f2 = b[p];\n            if (f1 === f2)\n                continue;\n            a[p] = b[p];\n        }\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        var o1 = {};\n        var o2 = {};\n        o2.x = 42;\n        o2.y = 53;\n        foo(o1, o2);\n        if (o1.x !== o2.x)\n            throw new Error("bad result: " + o1.x + "!==" + o2.x);\n        if (o1.y !== o2.y)\n            throw new Error("bad result: " + o1.y + "!==" + o2.y);\n    }\n})();\n\n(function() {\n    var foo = function(a, b) {\n        for (var p = b in a) {}\n        return p;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'expected-result\';\n        var result = foo({}, expected);\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'a\';\n        var result = foo({a:\'abcd\'}, expected);\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'b\';\n        var result = foo({a:\'abcd\', b: \'bcde\'}, expected);\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'c\';\n        var o = {a:\'abcd\', b: \'bcde\'};\n        o.c = \'cdef\';\n        var result = foo(o, expected);\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n})();\n\n(function() {\n    var boo = function () { return \'expected-result\'; };\n    var foo = function(a) {\n        for (var p = boo() in a) {}\n        return p;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'expected-result\';\n        var result = foo({});\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n})();\n\n(function() {\n    var foo = function(a, b, first) {\n        {   \n            let p = \'some-value\';\n            for (var p = b in a) {}\n            if (first)\n                return p;\n        }\n        return p;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'expected-result\';\n        var result = foo({}, expected, true);\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'expected-result\';\n        var result = foo({}, expected, false);\n        if (typeof result !== \'undefined\')\n            throw new Error("bad result: " + result + "!== undefined");\n    }\n})();\n\n(function() {\n    var foo = function(a, b, c) {\n        for (var p = b + c in a) {}\n        return p;\n    };\n    noInline(foo);\n    for (var i = 0; i < 10000; ++i) {\n        var expected = \'expected-result\';\n        var result = foo({}, \'expected\', \'-result\');\n        if (expected !== result)\n            throw new Error("bad result: " + result + "!==" + expected);\n    }\n})();\n\n(function() {\n    var error = false;\n    try {\n        eval("(function() { \'use strict\'; for (var i = 0 in {}) {}})()");\n    } catch(e) {\n        error = e instanceof SyntaxError;\n    }\n    if (!error)\n        throw new Error("Expected SyntaxError error");\n})();\n\n(function() {\n    var error = false;\n    try {\n        eval("(function() { const i = 10; for (var i = 0 in {}) {}})()");\n    } catch(e) {\n        error = e instanceof SyntaxError;\n    }\n    if (!error)\n        throw new Error("Expected SyntaxError error");\n})();\n' }
for-let-comma.js:SyntaxError: Complex binding patterns require an initialization value
function foo() {
    var array = [];
    for (let x = 0, []; x < 10; ++x) { array.push(x); }
    return array;
}

var result = foo();
if (result.length != 10)
    throw "Error: bad length: " + result.length;
for (var i = 0; i < 10; ++i) {
    if (result[i] != i)
        throw "Error: bad entry at i = " + i + ": " + result[i];
}
if (result.length != 10)
    throw "Error: bad length: " + result.length;


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    for (let x = 0, []; x < 10; ++x) { array.push(x); }',
       message: 'Parsing error: Unexpected token x',
       line: 3,
       column: 14 } ],
  output: 'function foo() {\n    var array = [];\n    for (let x = 0, []; x < 10; ++x) { array.push(x); }\n    return array;\n}\n\nvar result = foo();\nif (result.length != 10)\n    throw "Error: bad length: " + result.length;\nfor (var i = 0; i < 10; ++i) {\n    if (result[i] != i)\n        throw "Error: bad entry at i = " + i + ": " + result[i];\n}\nif (result.length != 10)\n    throw "Error: bad length: " + result.length;\n\n' }
function-constructor-semantics.js:SyntaxError: Unexpected token function
function assert(b) {
    if (!b)
        throw new Error("Bad");
}

function hasSyntaxError(f) {
    let threw = false;
    try {
        f();
    } catch(e) {
        threw = e instanceof SyntaxError;
    }
    return threw;
}

let functions = [
    Function,
    (function*foo(){}).__proto__.constructor,
    (async function foo(){}).__proto__.constructor,
];

function testError(...args) {
    for (let f of functions) {
        assert(hasSyntaxError(() => (f(...args))));
    }
}

function testOK(...args) {
    for (let f of functions) {
        assert(!hasSyntaxError(() => (f(...args))));
    }
}

testError("a", "b", "/*", "");
testError("/*", "*/){");
testError("a=super()", "body;");
testError("a=super.foo", "body;");
testError("super();");
testError("super.foo;");
testError("a", "b", "/*", "");
testError("a", "'use strict'; let a;");
testError("/*", "*/");
testError("/*", "*/");
testError("a=20", "'use strict';");
testError("{a}", "'use strict';");
testError("...args", "'use strict';");
testError("...args", "b", "");
testError("//", "b", "");

testOK("/*", "*/", "");
testOK("a", "/*b", "*/", "'use strict'; let b");
testOK("{a}", "return a;");
testOK("a", "...args", "");
testOK("");
testOK("let a");
testOK(undefined);
testOK("//");

let str = "";
testOK({toString() { str += "1"; return "a"}}, {toString() { str += "2"; return "b"}}, {toString() { str += "3"; return "body;"}});
let target = "";
for (let i = 0; i < functions.length; ++i)
    target += "123";
assert(str === target);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let threw = false;',
       message: 'Parsing error: Unexpected token threw',
       line: 7,
       column: 9 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad");\n}\n\nfunction hasSyntaxError(f) {\n    let threw = false;\n    try {\n        f();\n    } catch(e) {\n        threw = e instanceof SyntaxError;\n    }\n    return threw;\n}\n\nlet functions = [\n    Function,\n    (function*foo(){}).__proto__.constructor,\n    (async function foo(){}).__proto__.constructor,\n];\n\nfunction testError(...args) {\n    for (let f of functions) {\n        assert(hasSyntaxError(() => (f(...args))));\n    }\n}\n\nfunction testOK(...args) {\n    for (let f of functions) {\n        assert(!hasSyntaxError(() => (f(...args))));\n    }\n}\n\ntestError("a", "b", "/*", "");\ntestError("/*", "*/){");\ntestError("a=super()", "body;");\ntestError("a=super.foo", "body;");\ntestError("super();");\ntestError("super.foo;");\ntestError("a", "b", "/*", "");\ntestError("a", "\'use strict\'; let a;");\ntestError("/*", "*/");\ntestError("/*", "*/");\ntestError("a=20", "\'use strict\';");\ntestError("{a}", "\'use strict\';");\ntestError("...args", "\'use strict\';");\ntestError("...args", "b", "");\ntestError("//", "b", "");\n\ntestOK("/*", "*/", "");\ntestOK("a", "/*b", "*/", "\'use strict\'; let b");\ntestOK("{a}", "return a;");\ntestOK("a", "...args", "");\ntestOK("");\ntestOK("let a");\ntestOK(undefined);\ntestOK("//");\n\nlet str = "";\ntestOK({toString() { str += "1"; return "a"}}, {toString() { str += "2"; return "b"}}, {toString() { str += "3"; return "body;"}});\nlet target = "";\nfor (let i = 0; i < functions.length; ++i)\n    target += "123";\nassert(str === target);\n' }
import-from-eval.js:SyntaxError: Unexpected token function
var abort = $vm.abort;

(async function () {
    const { shouldBe, shouldThrow } = await import("./import-tests/should.js");

    {
        let cocoa = await eval(`import("./import-tests/cocoa.js")`);
        shouldBe(cocoa.hello(), 42);
    }

    {
        let cocoa = await (0, eval)(`import("./import-tests/cocoa.js")`);
        shouldBe(cocoa.hello(), 42);
    }

    {
        let cocoa = await eval(`eval('import("./import-tests/cocoa.js")')`);
        shouldBe(cocoa.hello(), 42);
    }

    {
        let cocoa = await ((new Function(`return eval('import("./import-tests/cocoa.js")')`))());
        shouldBe(cocoa.hello(), 42);
    }

    {
        let cocoa = await eval(`(new Function('return import("./import-tests/cocoa.js")'))()`);
        shouldBe(cocoa.hello(), 42);
    }

    {
        let cocoa = await [`import("./import-tests/cocoa.js")`].map(eval)[0];
        shouldBe(cocoa.hello(), 42);
    }
}()).catch((error) => {
    print(String(error));
    abort();
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '(async function () {',
       message: 'Parsing error: Unexpected token function',
       line: 3,
       column: 8 } ],
  output: 'var abort = $vm.abort;\n\n(async function () {\n    const { shouldBe, shouldThrow } = await import("./import-tests/should.js");\n\n    {\n        let cocoa = await eval(`import("./import-tests/cocoa.js")`);\n        shouldBe(cocoa.hello(), 42);\n    }\n\n    {\n        let cocoa = await (0, eval)(`import("./import-tests/cocoa.js")`);\n        shouldBe(cocoa.hello(), 42);\n    }\n\n    {\n        let cocoa = await eval(`eval(\'import("./import-tests/cocoa.js")\')`);\n        shouldBe(cocoa.hello(), 42);\n    }\n\n    {\n        let cocoa = await ((new Function(`return eval(\'import("./import-tests/cocoa.js")\')`))());\n        shouldBe(cocoa.hello(), 42);\n    }\n\n    {\n        let cocoa = await eval(`(new Function(\'return import("./import-tests/cocoa.js")\'))()`);\n        shouldBe(cocoa.hello(), 42);\n    }\n\n    {\n        let cocoa = await [`import("./import-tests/cocoa.js")`].map(eval)[0];\n        shouldBe(cocoa.hello(), 42);\n    }\n}()).catch((error) => {\n    print(String(error));\n    abort();\n});\n' }
import-reject-with-exception.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
var abort = $vm.abort;

function shouldBe(actual, expected)
{
    if (actual !== expected)
        abort();
}

let x = {
    get toString() {
        throw new Error('bad');
    }
};

import(x).then(abort, function (error) {
    shouldBe(String(error), `Error: bad`);
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let x = {',
       message: 'Parsing error: Unexpected token x',
       line: 9,
       column: 5 } ],
  output: 'var abort = $vm.abort;\n\nfunction shouldBe(actual, expected)\n{\n    if (actual !== expected)\n        abort();\n}\n\nlet x = {\n    get toString() {\n        throw new Error(\'bad\');\n    }\n};\n\nimport(x).then(abort, function (error) {\n    shouldBe(String(error), `Error: bad`);\n});\n' }
import-basic.js:SyntaxError: Unexpected token function
var abort = $vm.abort;

(async function () {
    const { shouldBe } = await import('./import-tests/should.js');
    {
        let a = await import('./import-tests/cocoa.js');
        let b = await import('./import-tests/cocoa.js');
        shouldBe(a, b);
        shouldBe(a.hello(), 42);
    }

    {
        let a = await import('./import-tests/multiple.js');
        let a2 = await a.result();
        shouldBe(a !== a2, true);
        shouldBe(a2.ok(), 42);
        let a3 = await a.result();
        shouldBe(a2, a3);
    }

    {
        let error = null;
        try {
            let a = await import({ toString() { throw new Error('out'); } });
        } catch (e) {
            error = e;
        }
        shouldBe(error !== null, true);
        shouldBe(String(error), `Error: out`);
    }

    {
        async function load(cond) {
            if (cond)
                return import('./import-tests/cocoa.js');
            return undefined;
        }

        let v = await load(false);
        shouldBe(v, undefined);
        let v2 = await load(true);
        let v3 = await import('./import-tests/cocoa.js');
        shouldBe(v2, v2);
    }

    {
        let value = './import-tests/cocoa.js';
        let v = await import(value);
        let v2 = await import('./import-tests/cocoa.js');
        shouldBe(v, v2);
    }
}()).catch((error) => {
    print(String(error));
    abort();
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '(async function () {',
       message: 'Parsing error: Unexpected token function',
       line: 3,
       column: 8 } ],
  output: 'var abort = $vm.abort;\n\n(async function () {\n    const { shouldBe } = await import(\'./import-tests/should.js\');\n    {\n        let a = await import(\'./import-tests/cocoa.js\');\n        let b = await import(\'./import-tests/cocoa.js\');\n        shouldBe(a, b);\n        shouldBe(a.hello(), 42);\n    }\n\n    {\n        let a = await import(\'./import-tests/multiple.js\');\n        let a2 = await a.result();\n        shouldBe(a !== a2, true);\n        shouldBe(a2.ok(), 42);\n        let a3 = await a.result();\n        shouldBe(a2, a3);\n    }\n\n    {\n        let error = null;\n        try {\n            let a = await import({ toString() { throw new Error(\'out\'); } });\n        } catch (e) {\n            error = e;\n        }\n        shouldBe(error !== null, true);\n        shouldBe(String(error), `Error: out`);\n    }\n\n    {\n        async function load(cond) {\n            if (cond)\n                return import(\'./import-tests/cocoa.js\');\n            return undefined;\n        }\n\n        let v = await load(false);\n        shouldBe(v, undefined);\n        let v2 = await load(true);\n        let v3 = await import(\'./import-tests/cocoa.js\');\n        shouldBe(v2, v2);\n    }\n\n    {\n        let value = \'./import-tests/cocoa.js\';\n        let v = await import(value);\n        let v2 = await import(\'./import-tests/cocoa.js\');\n        shouldBe(v, v2);\n    }\n}()).catch((error) => {\n    print(String(error));\n    abort();\n});\n' }
import-with-empty-string.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
import("").then($vm.abort, function () {
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'import("").then($vm.abort, function () {',
       message: 'Parsing error: The keyword \'import\' is reserved',
       line: 1,
       column: 1 } ],
  output: 'import("").then($vm.abort, function () {\n});\n' }
import-syntax.js:SyntaxError: Unexpected token function
var abort = $vm.abort;

function testSyntaxError(script, message) {
    var error = null;
    try {
        eval(script);
    } catch (e) {
        error = e;
    }
    if (!error)
        throw new Error("Expected syntax error not thrown");

    if (String(error) !== message)
        throw new Error(`Bad error: ${String(error)}`);
}

async function testSyntax(script, message) {
    var error = null;
    try {
        await eval(script);
    } catch (e) {
        error = e;
    }
    if (error) {
        if (error instanceof SyntaxError)
            throw new Error("Syntax error thrown");
    }
}

testSyntaxError(`import)`, `SyntaxError: Unexpected token ')'. import call expects exactly one argument.`);
testSyntaxError(`new import(`, `SyntaxError: Cannot use new with import.`);
testSyntaxError(`import.hello()`, `SyntaxError: Unexpected identifier 'hello'. "import." can only followed with meta.`);
testSyntaxError(`import[`, `SyntaxError: Unexpected token '['. import call expects exactly one argument.`);
testSyntaxError(`import<`, `SyntaxError: Unexpected token '<'. import call expects exactly one argument.`);

testSyntaxError(`import()`, `SyntaxError: Unexpected token ')'`);
testSyntaxError(`import(a, b)`, `SyntaxError: Unexpected token ','. import call expects exactly one argument.`);
testSyntaxError(`import(a, b, c)`, `SyntaxError: Unexpected token ','. import call expects exactly one argument.`);
testSyntaxError(`import(...a)`, `SyntaxError: Unexpected token '...'`);
testSyntaxError(`import(,a)`, `SyntaxError: Unexpected token ','`);
testSyntaxError(`import(,)`, `SyntaxError: Unexpected token ','`);
testSyntaxError(`import("Hello";`, `SyntaxError: Unexpected token ';'. import call expects exactly one argument.`);
testSyntaxError(`import("Hello"];`, `SyntaxError: Unexpected token ']'. import call expects exactly one argument.`);
testSyntaxError(`import("Hello",;`, `SyntaxError: Unexpected token ','. import call expects exactly one argument.`);
testSyntaxError(`import("Hello", "Hello2";`, `SyntaxError: Unexpected token ','. import call expects exactly one argument.`);


testSyntaxError(`import = 42`, `SyntaxError: Unexpected token '='. import call expects exactly one argument.`);
testSyntaxError(`[import] = 42`, `SyntaxError: Unexpected token ']'. import call expects exactly one argument.`);
testSyntaxError(`{import} = 42`, `SyntaxError: Unexpected token '}'. import call expects exactly one argument.`);
testSyntaxError(`let import = 42`, `SyntaxError: Unexpected keyword 'import'`);
testSyntaxError(`var import = 42`, `SyntaxError: Cannot use the keyword 'import' as a variable name.`);
testSyntaxError(`const import = 42`, `SyntaxError: Cannot use the keyword 'import' as a lexical variable name.`);

(async function () {
    await testSyntax(`import("./import-tests/cocoa.js")`);
    await testSyntax(`import("./import-tests/../import-tests/cocoa.js")`);
    await testSyntax(`import("./import-tests/../import-tests/cocoa.js").then(() => { })`);
    await testSyntax(`(import("./import-tests/../import-tests/cocoa.js").then(() => { }))`);
    await testSyntax(`(import("./import-tests/../import-tests/cocoa.js"))`);
    await testSyntax(`import("./import-tests/../import-tests/cocoa.js").catch(() => { })`);
    await testSyntax(`(import("./import-tests/../import-tests/cocoa.js").catch(() => { }))`);
}()).catch((error) => {
    print(String(error));
    abort();
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '        throw new Error(`Bad error: ${String(error)}`);',
       message: 'Parsing error: Unexpected character \'`\'',
       line: 14,
       column: 25 } ],
  output: 'var abort = $vm.abort;\n\nfunction testSyntaxError(script, message) {\n    var error = null;\n    try {\n        eval(script);\n    } catch (e) {\n        error = e;\n    }\n    if (!error)\n        throw new Error("Expected syntax error not thrown");\n\n    if (String(error) !== message)\n        throw new Error(`Bad error: ${String(error)}`);\n}\n\nasync function testSyntax(script, message) {\n    var error = null;\n    try {\n        await eval(script);\n    } catch (e) {\n        error = e;\n    }\n    if (error) {\n        if (error instanceof SyntaxError)\n            throw new Error("Syntax error thrown");\n    }\n}\n\ntestSyntaxError(`import)`, `SyntaxError: Unexpected token \')\'. import call expects exactly one argument.`);\ntestSyntaxError(`new import(`, `SyntaxError: Cannot use new with import.`);\ntestSyntaxError(`import.hello()`, `SyntaxError: Unexpected identifier \'hello\'. "import." can only followed with meta.`);\ntestSyntaxError(`import[`, `SyntaxError: Unexpected token \'[\'. import call expects exactly one argument.`);\ntestSyntaxError(`import<`, `SyntaxError: Unexpected token \'<\'. import call expects exactly one argument.`);\n\ntestSyntaxError(`import()`, `SyntaxError: Unexpected token \')\'`);\ntestSyntaxError(`import(a, b)`, `SyntaxError: Unexpected token \',\'. import call expects exactly one argument.`);\ntestSyntaxError(`import(a, b, c)`, `SyntaxError: Unexpected token \',\'. import call expects exactly one argument.`);\ntestSyntaxError(`import(...a)`, `SyntaxError: Unexpected token \'...\'`);\ntestSyntaxError(`import(,a)`, `SyntaxError: Unexpected token \',\'`);\ntestSyntaxError(`import(,)`, `SyntaxError: Unexpected token \',\'`);\ntestSyntaxError(`import("Hello";`, `SyntaxError: Unexpected token \';\'. import call expects exactly one argument.`);\ntestSyntaxError(`import("Hello"];`, `SyntaxError: Unexpected token \']\'. import call expects exactly one argument.`);\ntestSyntaxError(`import("Hello",;`, `SyntaxError: Unexpected token \',\'. import call expects exactly one argument.`);\ntestSyntaxError(`import("Hello", "Hello2";`, `SyntaxError: Unexpected token \',\'. import call expects exactly one argument.`);\n\n\ntestSyntaxError(`import = 42`, `SyntaxError: Unexpected token \'=\'. import call expects exactly one argument.`);\ntestSyntaxError(`[import] = 42`, `SyntaxError: Unexpected token \']\'. import call expects exactly one argument.`);\ntestSyntaxError(`{import} = 42`, `SyntaxError: Unexpected token \'}\'. import call expects exactly one argument.`);\ntestSyntaxError(`let import = 42`, `SyntaxError: Unexpected keyword \'import\'`);\ntestSyntaxError(`var import = 42`, `SyntaxError: Cannot use the keyword \'import\' as a variable name.`);\ntestSyntaxError(`const import = 42`, `SyntaxError: Cannot use the keyword \'import\' as a lexical variable name.`);\n\n(async function () {\n    await testSyntax(`import("./import-tests/cocoa.js")`);\n    await testSyntax(`import("./import-tests/../import-tests/cocoa.js")`);\n    await testSyntax(`import("./import-tests/../import-tests/cocoa.js").then(() => { })`);\n    await testSyntax(`(import("./import-tests/../import-tests/cocoa.js").then(() => { }))`);\n    await testSyntax(`(import("./import-tests/../import-tests/cocoa.js"))`);\n    await testSyntax(`import("./import-tests/../import-tests/cocoa.js").catch(() => { })`);\n    await testSyntax(`(import("./import-tests/../import-tests/cocoa.js").catch(() => { }))`);\n}()).catch((error) => {\n    print(String(error));\n    abort();\n});\n' }
lift-template-literal.js:SyntaxError: Bad character escape sequence
function dump(callSite)
{
    return JSON.stringify({ cooked: callSite, raw: callSite.raw });
}

function shouldBe(actual, expected)
{
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

shouldBe(dump`\newcommand{\fun}{\textbf{Fun!}}`, `{"cooked":["\\newcommand{\\fun}{\\textbf{Fun!}}"],"raw":["\\\\newcommand{\\\\fun}{\\\\textbf{Fun!}}"]}`);
shouldBe(dump`\newcommand{\unicode}{\textbf{Unicode!}}`, `{"cooked":[null],"raw":["\\\\newcommand{\\\\unicode}{\\\\textbf{Unicode!}}"]}`);
shouldBe(dump`\newcommand{\xerxes}{\textbf{King!}}`, `{"cooked":[null],"raw":["\\\\newcommand{\\\\xerxes}{\\\\textbf{King!}}"]}`);
shouldBe(dump`Breve over the h goes \u{h}ere`, `{"cooked":[null],"raw":["Breve over the h goes \\\\u{h}ere"]}`);

function testTag(expected) {
    return function tag(callSite) {
        shouldBe(callSite.length, expected.cooked.length);
        shouldBe(callSite.raw.length, expected.raw.length);
        expected.cooked.forEach((value, index) => shouldBe(callSite[index], value));
        expected.raw.forEach((value, index) => shouldBe(callSite.raw[index], value));
    }
}

testTag({
    cooked: [ undefined ],
    raw: [ "\\unicode and \\u{55}" ],
})`\unicode and \u{55}`;

testTag({
    cooked: [ undefined, "test" ],
    raw: [ "\\unicode and \\u{55}", "test" ],
})`\unicode and \u{55}${42}test`;

testTag({
    cooked: [ undefined, undefined, "Cocoa" ],
    raw: [ "\\unicode and \\u{55}", "\\uhello", "Cocoa" ],
})`\unicode and \u{55}${42}\uhello${42}Cocoa`;

testTag({
    cooked: [ "Cocoa", undefined, undefined, "Cocoa" ],
    raw: [ "Cocoa", "\\unicode and \\u{55}", "\\uhello", "Cocoa" ],
})`Cocoa${42}\unicode and \u{55}${42}\uhello${42}Cocoa`;

testTag({
    cooked: [ "Cocoa", undefined, undefined, "Cocoa" ],
    raw: [ "Cocoa", "\\unicode and \\u{55}", "\\uhello", "Cocoa" ],
})`Cocoa${42}\unicode and \u{55}${42}\uhello${42}Cocoa`;

testTag({
    cooked: [ undefined, undefined, undefined ],
    raw: [ "\\00", "\\01", "\\1" ]
})`\00${42}\01${42}\1`;

testTag({
    cooked: [ undefined, undefined ],
    raw: [ "\\xo", "\\x0o" ]
})`\xo${42}\x0o`;

testTag({
    cooked: [ undefined, undefined, undefined, undefined ],
    raw: [ "\\uo", "\\u0o", "\\u00o", "\\u000o" ]
})`\uo${42}\u0o${42}\u00o${42}\u000o`;

testTag({
    cooked: [ undefined, undefined, undefined ],
    raw: [ "\\u{o", "\\u{0o", "\\u{110000o" ]
})`\u{o${42}\u{0o${42}\u{110000o`;

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'shouldBe(dump`\\newcommand{\\fun}{\\textbf{Fun!}}`, `{"cooked":["\\\\newcommand{\\\\fun}{\\\\textbf{Fun!}}"],"raw":["\\\\\\\\newcommand{\\\\\\\\fun}{\\\\\\\\textbf{Fun!}}"]}`);',
       message: 'Parsing error: Unexpected character \'`\'',
       line: 12,
       column: 14 } ],
  output: 'function dump(callSite)\n{\n    return JSON.stringify({ cooked: callSite, raw: callSite.raw });\n}\n\nfunction shouldBe(actual, expected)\n{\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nshouldBe(dump`\\newcommand{\\fun}{\\textbf{Fun!}}`, `{"cooked":["\\\\newcommand{\\\\fun}{\\\\textbf{Fun!}}"],"raw":["\\\\\\\\newcommand{\\\\\\\\fun}{\\\\\\\\textbf{Fun!}}"]}`);\nshouldBe(dump`\\newcommand{\\unicode}{\\textbf{Unicode!}}`, `{"cooked":[null],"raw":["\\\\\\\\newcommand{\\\\\\\\unicode}{\\\\\\\\textbf{Unicode!}}"]}`);\nshouldBe(dump`\\newcommand{\\xerxes}{\\textbf{King!}}`, `{"cooked":[null],"raw":["\\\\\\\\newcommand{\\\\\\\\xerxes}{\\\\\\\\textbf{King!}}"]}`);\nshouldBe(dump`Breve over the h goes \\u{h}ere`, `{"cooked":[null],"raw":["Breve over the h goes \\\\\\\\u{h}ere"]}`);\n\nfunction testTag(expected) {\n    return function tag(callSite) {\n        shouldBe(callSite.length, expected.cooked.length);\n        shouldBe(callSite.raw.length, expected.raw.length);\n        expected.cooked.forEach((value, index) => shouldBe(callSite[index], value));\n        expected.raw.forEach((value, index) => shouldBe(callSite.raw[index], value));\n    }\n}\n\ntestTag({\n    cooked: [ undefined ],\n    raw: [ "\\\\unicode and \\\\u{55}" ],\n})`\\unicode and \\u{55}`;\n\ntestTag({\n    cooked: [ undefined, "test" ],\n    raw: [ "\\\\unicode and \\\\u{55}", "test" ],\n})`\\unicode and \\u{55}${42}test`;\n\ntestTag({\n    cooked: [ undefined, undefined, "Cocoa" ],\n    raw: [ "\\\\unicode and \\\\u{55}", "\\\\uhello", "Cocoa" ],\n})`\\unicode and \\u{55}${42}\\uhello${42}Cocoa`;\n\ntestTag({\n    cooked: [ "Cocoa", undefined, undefined, "Cocoa" ],\n    raw: [ "Cocoa", "\\\\unicode and \\\\u{55}", "\\\\uhello", "Cocoa" ],\n})`Cocoa${42}\\unicode and \\u{55}${42}\\uhello${42}Cocoa`;\n\ntestTag({\n    cooked: [ "Cocoa", undefined, undefined, "Cocoa" ],\n    raw: [ "Cocoa", "\\\\unicode and \\\\u{55}", "\\\\uhello", "Cocoa" ],\n})`Cocoa${42}\\unicode and \\u{55}${42}\\uhello${42}Cocoa`;\n\ntestTag({\n    cooked: [ undefined, undefined, undefined ],\n    raw: [ "\\\\00", "\\\\01", "\\\\1" ]\n})`\\00${42}\\01${42}\\1`;\n\ntestTag({\n    cooked: [ undefined, undefined ],\n    raw: [ "\\\\xo", "\\\\x0o" ]\n})`\\xo${42}\\x0o`;\n\ntestTag({\n    cooked: [ undefined, undefined, undefined, undefined ],\n    raw: [ "\\\\uo", "\\\\u0o", "\\\\u00o", "\\\\u000o" ]\n})`\\uo${42}\\u0o${42}\\u00o${42}\\u000o`;\n\ntestTag({\n    cooked: [ undefined, undefined, undefined ],\n    raw: [ "\\\\u{o", "\\\\u{0o", "\\\\u{110000o" ]\n})`\\u{o${42}\\u{0o${42}\\u{110000o`;\n' }
module-namespace-access-change.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

function access(namespace)
{
    return namespace.test;
}
noInline(access);

import("./resources/module-namespace-access.js").then((ns) => {
    for (var i = 0; i < 1e4; ++i)
        shouldBe(access(ns), 42)
    ns.change();
    for (var i = 0; i < 1e4; ++i)
        shouldBe(access(ns), 55)
});
drainMicrotasks();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'import("./resources/module-namespace-access.js").then((ns) => {',
       message: 'Parsing error: The keyword \'import\' is reserved',
       line: 12,
       column: 1 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nfunction access(namespace)\n{\n    return namespace.test;\n}\nnoInline(access);\n\nimport("./resources/module-namespace-access.js").then((ns) => {\n    for (var i = 0; i < 1e4; ++i)\n        shouldBe(access(ns), 42)\n    ns.change();\n    for (var i = 0; i < 1e4; ++i)\n        shouldBe(access(ns), 55)\n});\ndrainMicrotasks();\n' }
module-namespace-access-non-constant.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

import("./resources/module-namespace-access.js").then((ns) => {
    ns.change();
    for (var i = 0; i < 1e6; ++i) {
        shouldBe(ns.test, 55);
        shouldBe(ns.cocoa(), 55);
    }
});
drainMicrotasks();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'import("./resources/module-namespace-access.js").then((ns) => {',
       message: 'Parsing error: The keyword \'import\' is reserved',
       line: 6,
       column: 1 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nimport("./resources/module-namespace-access.js").then((ns) => {\n    ns.change();\n    for (var i = 0; i < 1e6; ++i) {\n        shouldBe(ns.test, 55);\n        shouldBe(ns.cocoa(), 55);\n    }\n});\ndrainMicrotasks();\n' }
module-namespace-access-poly.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

function access(ns)
{
    return ns.test;
}
noInline(access);

import("./resources/module-namespace-access.js").then((ns) => {
    for (var i = 0; i < 1e4; ++i) {
        shouldBe(access(ns), 42);
    }
    let nonNS = { test: 50 };
    let nonNS2 = { ok: 22, test: 52 };
    for (var i = 0; i < 1e4; ++i) {
        shouldBe(access(ns), 42);
        shouldBe(access(nonNS), 50);
        shouldBe(access(nonNS2), 52);
    }
});
drainMicrotasks();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'import("./resources/module-namespace-access.js").then((ns) => {',
       message: 'Parsing error: The keyword \'import\' is reserved',
       line: 12,
       column: 1 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nfunction access(ns)\n{\n    return ns.test;\n}\nnoInline(access);\n\nimport("./resources/module-namespace-access.js").then((ns) => {\n    for (var i = 0; i < 1e4; ++i) {\n        shouldBe(access(ns), 42);\n    }\n    let nonNS = { test: 50 };\n    let nonNS2 = { ok: 22, test: 52 };\n    for (var i = 0; i < 1e4; ++i) {\n        shouldBe(access(ns), 42);\n        shouldBe(access(nonNS), 50);\n        shouldBe(access(nonNS2), 52);\n    }\n});\ndrainMicrotasks();\n' }
module-namespace-access-transitive-exports.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

import("./resources/module-namespace-access-transitive-exports.js").then((ns) => {
    for (var i = 0; i < 1e6; ++i) {
        shouldBe(ns.test, 42);
        shouldBe(ns.cocoa(), 42);
    }
});
drainMicrotasks();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'import("./resources/module-namespace-access-transitive-exports.js").then((ns) => {',
       message: 'Parsing error: The keyword \'import\' is reserved',
       line: 6,
       column: 1 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nimport("./resources/module-namespace-access-transitive-exports.js").then((ns) => {\n    for (var i = 0; i < 1e6; ++i) {\n        shouldBe(ns.test, 42);\n        shouldBe(ns.cocoa(), 42);\n    }\n});\ndrainMicrotasks();\n' }
module-namespace-access.js:SyntaxError: 'import' and 'export' may appear only with 'sourceType: module'
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

import("./resources/module-namespace-access.js").then((ns) => {
    for (var i = 0; i < 1e6; ++i) {
        shouldBe(ns.test, 42);
        shouldBe(ns.cocoa(), 42);
    }
});
drainMicrotasks();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'import("./resources/module-namespace-access.js").then((ns) => {',
       message: 'Parsing error: The keyword \'import\' is reserved',
       line: 6,
       column: 1 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nimport("./resources/module-namespace-access.js").then((ns) => {\n    for (var i = 0; i < 1e6; ++i) {\n        shouldBe(ns.test, 42);\n        shouldBe(ns.cocoa(), 42);\n    }\n});\ndrainMicrotasks();\n' }
new-target-syntax-errors.js:SyntaxError: Unexpected token =>
function assert(b) {
    if (!b)
        throw new Error("Bad assertion")
}

function shouldBeSyntaxError(str) {
    let failed = true;
    try {
        new Function(str);
    } catch(e) {
        if (e instanceof SyntaxError)
            failed = false;
    }
    
    if (failed)
        throw new Error("Did not throw syntax error: " + str);
}

function shouldNotBeSyntaxError(str) {
    let failed = false;
    try {
        new Function(str);
    } catch(e) {
        if (e instanceof SyntaxError && e.message.indexOf("new.target") !== -1)
            failed = true;
    }
    
    if (failed)
        throw new Error("Did throw a syntax error: " + str);
}


let operators = ["=", "+=", "-=", "*=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "%="];
for (let operator of operators) {
    let functionBody = `new.target ${operator} 20`;
    shouldBeSyntaxError(functionBody);

    functionBody = `foo = new.target ${operator} 20`;
    shouldBeSyntaxError(functionBody);

    functionBody = `foo ${operator} new.target ${operator} 20`;
    shouldBeSyntaxError(functionBody);

    functionBody = `new.target ${operator} foo *= 40`;
    shouldBeSyntaxError(functionBody);


    // Make sure our tests cases our sound and they should not be syntax errors if new.target is replaced by foo
    functionBody = `foo ${operator} 20`;
    shouldNotBeSyntaxError(functionBody);

    functionBody = `foo = foo ${operator} 20`;
    shouldNotBeSyntaxError(functionBody);

    functionBody = `foo ${operator} foo ${operator} 20`;
    shouldNotBeSyntaxError(functionBody);

    functionBody = `foo ${operator} foo *= 40`;
    shouldNotBeSyntaxError(functionBody);
}

let prePostFixOperators = ["++", "--"];
for (let operator of prePostFixOperators) {
    let functionBody = `${operator}new.target`;
    shouldBeSyntaxError(functionBody);

    functionBody = `foo = ${operator}new.target`;
    shouldBeSyntaxError(functionBody);

    functionBody = `${operator}foo`;
    shouldNotBeSyntaxError(functionBody);

    functionBody = `foo = ${operator}foo`;
    shouldNotBeSyntaxError(functionBody);
}

for (let operator of prePostFixOperators) {
    let functionBody = `new.target${operator}`;
    shouldBeSyntaxError(functionBody);

    functionBody = `foo = new.target${operator}`;
    shouldBeSyntaxError(functionBody);

    functionBody = `foo${operator}`;
    shouldNotBeSyntaxError(functionBody);

    functionBody = `foo = foo${operator}`;
    shouldNotBeSyntaxError(functionBody);
}

let otherUnaryOperators = ["!", "~", "+", "-", "typeof ", "void ", "delete "];
for (let operator of otherUnaryOperators) {
    function strict(body) { return `"use strict" ${body}`; }
    let functionBody = `${operator}new.target`;
    shouldNotBeSyntaxError(functionBody);
    shouldNotBeSyntaxError(strict(functionBody));
}

shouldBeSyntaxError(`({foo: new.target} = {foo:20})`);

// Scripts - 15.1.1 Static Semantics: Early Errors
// https://tc39.github.io/ecma262/#sec-scripts-static-semantics-early-errors
//
// Modules - 15.2.1.1 Static Semantics: Early Errors
// https://tc39.github.io/ecma262/#sec-module-semantics-static-semantics-early-errors
//
// new.target is not allowed in arrow functions in global scope.

let sawSyntaxError;

sawSyntaxError = false;
try {
    eval(`() => new.target`);
} catch(e) {
    sawSyntaxError = e instanceof SyntaxError;
}
assert(sawSyntaxError);

sawSyntaxError = false;
try {
    eval(`() => { new.target }`);
} catch(e) {
    sawSyntaxError = e instanceof SyntaxError;
}
assert(sawSyntaxError);

sawSyntaxError = false;
try {
    eval(`async () => new.target`);
} catch(e) {
    sawSyntaxError = e instanceof SyntaxError;
}
assert(sawSyntaxError);

sawSyntaxError = false;
try {
    eval(`async () => { new.target }`);
} catch(e) {
    sawSyntaxError = e instanceof SyntaxError;
}
assert(sawSyntaxError);

sawSyntaxError = false;
try {
    eval(`async () => await new.target`);
} catch(e) {
    sawSyntaxError = e instanceof SyntaxError;
}
assert(sawSyntaxError);

sawSyntaxError = false;
try {
    eval(`async () => { await new.target }`);
} catch(e) {
    sawSyntaxError = e instanceof SyntaxError;
}
assert(sawSyntaxError);

let sawError = false;
try {
    new Function(`() => new.target`);
    new Function(`() => { new.target }`);
    new Function(`async () => new.target`);
    new Function(`async () => { new.target }`);
    new Function(`async () => await new.target`);
    new Function(`async () => { await new.target }`);

    function f() { () => new.target };
    function f() { () => { new.target } };
    function f() { async () => new.target };
    function f() { async () => { new.target } };
    function f() { async () => await new.target };
    function f() { async () => { await new.target } };

    (function() { eval(`() => new.target`) })();
    (function() { eval(`() => { new.target }`) })();
    (function() { eval(`async () => new.target`) })();
    (function() { eval(`async () => { new.target }`) })();
    (function() { eval(`async () => await new.target`) })();
    (function() { eval(`async () => { await new.target }`) })();
} catch (e) {
    sawError = true;
}
assert(!sawError);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let failed = true;',
       message: 'Parsing error: Unexpected token failed',
       line: 7,
       column: 9 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad assertion")\n}\n\nfunction shouldBeSyntaxError(str) {\n    let failed = true;\n    try {\n        new Function(str);\n    } catch(e) {\n        if (e instanceof SyntaxError)\n            failed = false;\n    }\n    \n    if (failed)\n        throw new Error("Did not throw syntax error: " + str);\n}\n\nfunction shouldNotBeSyntaxError(str) {\n    let failed = false;\n    try {\n        new Function(str);\n    } catch(e) {\n        if (e instanceof SyntaxError && e.message.indexOf("new.target") !== -1)\n            failed = true;\n    }\n    \n    if (failed)\n        throw new Error("Did throw a syntax error: " + str);\n}\n\n\nlet operators = ["=", "+=", "-=", "*=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "%="];\nfor (let operator of operators) {\n    let functionBody = `new.target ${operator} 20`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `foo = new.target ${operator} 20`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `foo ${operator} new.target ${operator} 20`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `new.target ${operator} foo *= 40`;\n    shouldBeSyntaxError(functionBody);\n\n\n    // Make sure our tests cases our sound and they should not be syntax errors if new.target is replaced by foo\n    functionBody = `foo ${operator} 20`;\n    shouldNotBeSyntaxError(functionBody);\n\n    functionBody = `foo = foo ${operator} 20`;\n    shouldNotBeSyntaxError(functionBody);\n\n    functionBody = `foo ${operator} foo ${operator} 20`;\n    shouldNotBeSyntaxError(functionBody);\n\n    functionBody = `foo ${operator} foo *= 40`;\n    shouldNotBeSyntaxError(functionBody);\n}\n\nlet prePostFixOperators = ["++", "--"];\nfor (let operator of prePostFixOperators) {\n    let functionBody = `${operator}new.target`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `foo = ${operator}new.target`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `${operator}foo`;\n    shouldNotBeSyntaxError(functionBody);\n\n    functionBody = `foo = ${operator}foo`;\n    shouldNotBeSyntaxError(functionBody);\n}\n\nfor (let operator of prePostFixOperators) {\n    let functionBody = `new.target${operator}`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `foo = new.target${operator}`;\n    shouldBeSyntaxError(functionBody);\n\n    functionBody = `foo${operator}`;\n    shouldNotBeSyntaxError(functionBody);\n\n    functionBody = `foo = foo${operator}`;\n    shouldNotBeSyntaxError(functionBody);\n}\n\nlet otherUnaryOperators = ["!", "~", "+", "-", "typeof ", "void ", "delete "];\nfor (let operator of otherUnaryOperators) {\n    function strict(body) { return `"use strict" ${body}`; }\n    let functionBody = `${operator}new.target`;\n    shouldNotBeSyntaxError(functionBody);\n    shouldNotBeSyntaxError(strict(functionBody));\n}\n\nshouldBeSyntaxError(`({foo: new.target} = {foo:20})`);\n\n// Scripts - 15.1.1 Static Semantics: Early Errors\n// https://tc39.github.io/ecma262/#sec-scripts-static-semantics-early-errors\n//\n// Modules - 15.2.1.1 Static Semantics: Early Errors\n// https://tc39.github.io/ecma262/#sec-module-semantics-static-semantics-early-errors\n//\n// new.target is not allowed in arrow functions in global scope.\n\nlet sawSyntaxError;\n\nsawSyntaxError = false;\ntry {\n    eval(`() => new.target`);\n} catch(e) {\n    sawSyntaxError = e instanceof SyntaxError;\n}\nassert(sawSyntaxError);\n\nsawSyntaxError = false;\ntry {\n    eval(`() => { new.target }`);\n} catch(e) {\n    sawSyntaxError = e instanceof SyntaxError;\n}\nassert(sawSyntaxError);\n\nsawSyntaxError = false;\ntry {\n    eval(`async () => new.target`);\n} catch(e) {\n    sawSyntaxError = e instanceof SyntaxError;\n}\nassert(sawSyntaxError);\n\nsawSyntaxError = false;\ntry {\n    eval(`async () => { new.target }`);\n} catch(e) {\n    sawSyntaxError = e instanceof SyntaxError;\n}\nassert(sawSyntaxError);\n\nsawSyntaxError = false;\ntry {\n    eval(`async () => await new.target`);\n} catch(e) {\n    sawSyntaxError = e instanceof SyntaxError;\n}\nassert(sawSyntaxError);\n\nsawSyntaxError = false;\ntry {\n    eval(`async () => { await new.target }`);\n} catch(e) {\n    sawSyntaxError = e instanceof SyntaxError;\n}\nassert(sawSyntaxError);\n\nlet sawError = false;\ntry {\n    new Function(`() => new.target`);\n    new Function(`() => { new.target }`);\n    new Function(`async () => new.target`);\n    new Function(`async () => { new.target }`);\n    new Function(`async () => await new.target`);\n    new Function(`async () => { await new.target }`);\n\n    function f() { () => new.target };\n    function f() { () => { new.target } };\n    function f() { async () => new.target };\n    function f() { async () => { new.target } };\n    function f() { async () => await new.target };\n    function f() { async () => { await new.target } };\n\n    (function() { eval(`() => new.target`) })();\n    (function() { eval(`() => { new.target }`) })();\n    (function() { eval(`async () => new.target`) })();\n    (function() { eval(`async () => { new.target }`) })();\n    (function() { eval(`async () => await new.target`) })();\n    (function() { eval(`async () => { await new.target }`) })();\n} catch (e) {\n    sawError = true;\n}\nassert(!sawError);\n' }
number-is-integer-intrinsic.js:SyntaxError: Unexpected token )
function assert(b) {
    if (!b)
        throw new Error;
}

function onlyDouble(x) {
    return Number.isInteger(x);
}
noInline(onlyDouble);

let interestingValues = [
    [Infinity, false],
    [-Infinity, false],
    [NaN, false],
    [0.0, true],
    [-0.0, true],
    [90071992547490009021129120, true],
    [9007199254749001000, true],
    [Number.MAX_SAFE_INTEGER, true],
    [Number.MIN_SAFE_INTEGER, true],
    [0.5, false],
    [Math.PI, false],
    [42, true],
    [0, true],
    [-10, true],
    [2147483647, true],
    [-2147483648, true],
    [Number.MIN_VALUE, false],
    [Number.MAX_VALUE, true],
    [-Number.MAX_VALUE, true],
];

for (let i = 0; i < 10000; ++i) {
    for (let [value, result] of interestingValues) {
        assert(onlyDouble(value) === result);
    }
}

interestingValues.push(
    [true, false],
    [false, false],
    [undefined, false],
    [null, false],
    [{}, false],
    [{valueOf() { throw new Error("Should not be called"); }}, false],
    [function(){}, false],
);

function generic(x) {
    return Number.isInteger(x);
}
noInline(generic);

for (let i = 0; i < 10000; ++i) {
    for (let [value, result] of interestingValues) {
        assert(generic(value) === result);
    }
}

function onlyInts(x) {
    return Number.isInteger(x);
}
noInline(onlyInts);

for (let i = 0; i < 10000; ++i) {
    assert(onlyInts(i) === true);
}
for (let i = 0; i < 10000; ++i) {
    for (let [value, result] of interestingValues) {
        assert(onlyInts(value) === result);
    }
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let interestingValues = [',
       message: 'Parsing error: Unexpected token interestingValues',
       line: 11,
       column: 5 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error;\n}\n\nfunction onlyDouble(x) {\n    return Number.isInteger(x);\n}\nnoInline(onlyDouble);\n\nlet interestingValues = [\n    [Infinity, false],\n    [-Infinity, false],\n    [NaN, false],\n    [0.0, true],\n    [-0.0, true],\n    [90071992547490009021129120, true],\n    [9007199254749001000, true],\n    [Number.MAX_SAFE_INTEGER, true],\n    [Number.MIN_SAFE_INTEGER, true],\n    [0.5, false],\n    [Math.PI, false],\n    [42, true],\n    [0, true],\n    [-10, true],\n    [2147483647, true],\n    [-2147483648, true],\n    [Number.MIN_VALUE, false],\n    [Number.MAX_VALUE, true],\n    [-Number.MAX_VALUE, true],\n];\n\nfor (let i = 0; i < 10000; ++i) {\n    for (let [value, result] of interestingValues) {\n        assert(onlyDouble(value) === result);\n    }\n}\n\ninterestingValues.push(\n    [true, false],\n    [false, false],\n    [undefined, false],\n    [null, false],\n    [{}, false],\n    [{valueOf() { throw new Error("Should not be called"); }}, false],\n    [function(){}, false],\n);\n\nfunction generic(x) {\n    return Number.isInteger(x);\n}\nnoInline(generic);\n\nfor (let i = 0; i < 10000; ++i) {\n    for (let [value, result] of interestingValues) {\n        assert(generic(value) === result);\n    }\n}\n\nfunction onlyInts(x) {\n    return Number.isInteger(x);\n}\nnoInline(onlyInts);\n\nfor (let i = 0; i < 10000; ++i) {\n    assert(onlyInts(i) === true);\n}\nfor (let i = 0; i < 10000; ++i) {\n    for (let [value, result] of interestingValues) {\n        assert(onlyInts(value) === result);\n    }\n}\n' }
obj-rest-destructuring-order.js:SyntaxError: Unexpected token ...
function assert(a) {
    if (!a)
        throw new Error('Bad assertion');
}

// Check rest ordering without Proxy
(function () {
    var calls = [];
    var o = { get z() { calls.push('z') }, get a() { calls.push('a') } };
    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });
    Object.defineProperty(o, Symbol('foo'), { get: () => { calls.push('Symbol(foo)') }, enumerable: true });

    var {...r} = o;

    assert(calls[0] === 1);
    assert(calls[1] === 'z');
    assert(calls[2] === 'a');
    assert(calls[3] === 'Symbol(foo)');
    assert(Object.keys(r).length === 3);
})();

// Check spread ordering with Proxy
(function () {
    var calls = [];
    var o = { z: 2, a: 3 };
    var fooSymbol = Symbol('foo');
    Object.defineProperty(o, 1, { value: 4, enumerable: true });
    Object.defineProperty(o, fooSymbol, { value: 5, enumerable: true });

    var p = new Proxy(o, {
        get: function(target, property, receiver) {
            calls.push(property);
            return target[property];
        }
    });

    var {...r} = p;

    assert(calls[0] == 1);
    assert(calls[1] == 'z');
    assert(calls[2] == 'a');
    assert(calls[3] === fooSymbol);
    assert(Object.keys(r).length === 3);
})();


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });',
       message: 'Parsing error: Unexpected token )',
       line: 10,
       column: 41 } ],
  output: 'function assert(a) {\n    if (!a)\n        throw new Error(\'Bad assertion\');\n}\n\n// Check rest ordering without Proxy\n(function () {\n    var calls = [];\n    var o = { get z() { calls.push(\'z\') }, get a() { calls.push(\'a\') } };\n    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });\n    Object.defineProperty(o, Symbol(\'foo\'), { get: () => { calls.push(\'Symbol(foo)\') }, enumerable: true });\n\n    var {...r} = o;\n\n    assert(calls[0] === 1);\n    assert(calls[1] === \'z\');\n    assert(calls[2] === \'a\');\n    assert(calls[3] === \'Symbol(foo)\');\n    assert(Object.keys(r).length === 3);\n})();\n\n// Check spread ordering with Proxy\n(function () {\n    var calls = [];\n    var o = { z: 2, a: 3 };\n    var fooSymbol = Symbol(\'foo\');\n    Object.defineProperty(o, 1, { value: 4, enumerable: true });\n    Object.defineProperty(o, fooSymbol, { value: 5, enumerable: true });\n\n    var p = new Proxy(o, {\n        get: function(target, property, receiver) {\n            calls.push(property);\n            return target[property];\n        }\n    });\n\n    var {...r} = p;\n\n    assert(calls[0] == 1);\n    assert(calls[1] == \'z\');\n    assert(calls[2] == \'a\');\n    assert(calls[3] === fooSymbol);\n    assert(Object.keys(r).length === 3);\n})();\n\n' }
obj-spread-order.js:SyntaxError: Unexpected token ...
function assert(a) {
    if (!a)
        throw new Error('Bad assertion');
}

// Check spread ordering without Proxy
(function () {
    var calls = [];
    var o = { get z() { calls.push('z') }, get a() { calls.push('a') } };
    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });
    Object.defineProperty(o, Symbol('foo'), { get: () => { calls.push('Symbol(foo)') }, enumerable: true });

    var obj = {...o};

    assert(calls[0] === 1);
    assert(calls[1] === 'z');
    assert(calls[2] === 'a');
    assert(calls[3] === 'Symbol(foo)');
    assert(Object.keys(obj).length === 3);
})();

// Check spread ordering with Proxy
(function () {
    var calls = [];
    var o = { z: 2, a: 3 };
    var fooSymbol = Symbol('foo');
    Object.defineProperty(o, 1, { value: 4, enumerable: true });
    Object.defineProperty(o, fooSymbol, { value: 5, enumerable: true });

    var p = new Proxy(o, {
        get: function(target, property, receiver) {
            calls.push(property);
            return target[property];
        }
    });

    var obj = {...p};

    assert(calls[0] == 1);
    assert(calls[1] == 'z');
    assert(calls[2] == 'a');
    assert(calls[3] === fooSymbol);
    assert(Object.keys(obj).length === 3);
})();


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });',
       message: 'Parsing error: Unexpected token )',
       line: 10,
       column: 41 } ],
  output: 'function assert(a) {\n    if (!a)\n        throw new Error(\'Bad assertion\');\n}\n\n// Check spread ordering without Proxy\n(function () {\n    var calls = [];\n    var o = { get z() { calls.push(\'z\') }, get a() { calls.push(\'a\') } };\n    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });\n    Object.defineProperty(o, Symbol(\'foo\'), { get: () => { calls.push(\'Symbol(foo)\') }, enumerable: true });\n\n    var obj = {...o};\n\n    assert(calls[0] === 1);\n    assert(calls[1] === \'z\');\n    assert(calls[2] === \'a\');\n    assert(calls[3] === \'Symbol(foo)\');\n    assert(Object.keys(obj).length === 3);\n})();\n\n// Check spread ordering with Proxy\n(function () {\n    var calls = [];\n    var o = { z: 2, a: 3 };\n    var fooSymbol = Symbol(\'foo\');\n    Object.defineProperty(o, 1, { value: 4, enumerable: true });\n    Object.defineProperty(o, fooSymbol, { value: 5, enumerable: true });\n\n    var p = new Proxy(o, {\n        get: function(target, property, receiver) {\n            calls.push(property);\n            return target[property];\n        }\n    });\n\n    var obj = {...p};\n\n    assert(calls[0] == 1);\n    assert(calls[1] == \'z\');\n    assert(calls[2] == \'a\');\n    assert(calls[3] === fooSymbol);\n    assert(Object.keys(obj).length === 3);\n})();\n\n' }
object-rest-deconstruct.js:SyntaxError: Unexpected token ...
let assert = (e) => {
    if (!e)
        throw Error("Bad assertion!");
}

let assertPropDescriptor = (restObj, prop) => {
    let desc = Object.getOwnPropertyDescriptor(restObj, prop);
    assert(desc.enumerable);
    assert(desc.writable);
    assert(desc.configurable);
}

// Base Case
(() => {
    let obj = {x: 1, y: 2, a: 5, b: 3}

    let {a, b, ...rest} = obj;

    assert(a === 5);
    assert(b === 3);

    assert(rest.x === 1);
    assert(rest.y === 2);

    assertPropDescriptor(rest, 'x');
    assertPropDescriptor(rest, 'y');
})();

// Empty Object
(() => {
    let obj = {}

    let {a, b, ...rest} = obj;

    assert(a === undefined);
    assert(b === undefined);

    assert(typeof rest === "object");
})();

// Number case
(() => {
    let obj = 3;

    let {...rest} = obj;

    assert(typeof rest === "object");
})();

// String case
(() => {
    let obj = "foo";

    let {...rest} = obj;

    assert(typeof rest === "object");
})();

// Symbol case
(() => {
    let obj = Symbol("foo");

    let {...rest} = obj;

    assert(typeof rest === "object");
})();

// null case
(() => {
    let obj = null;

    try {
        let {...rest} = obj;
        assert(false);
    } catch (e) {
        assert(e.message == "Right side of assignment cannot be destructured");
    }

})();

// undefined case
(() => {
    let obj = undefined;

    try {
        let {...rest} = obj;
        assert(false);
    } catch (e) {
        assert(e.message == "Right side of assignment cannot be destructured");
    }

})();

// getter case
(() => {
    let obj = {a: 3, b: 4};
    Object.defineProperty(obj, "x", { get: () => 3, enumerable: true });

    let {a, b, ...rest} = obj;

    assert(a === 3);
    assert(b === 4);

    assert(rest.x === 3);
    assertPropDescriptor(rest, 'x');
})();

// Skip non-enumerable case
(() => {
    let obj = {a: 3, b: 4};
    Object.defineProperty(obj, "x", { value: 4, enumerable: false });

    let {...rest} = obj;

    assert(rest.a === 3);
    assert(rest.b === 4);
    assert(rest.x === undefined);
})();

// Don't copy descriptor case
(() => {
    let obj = {};
    Object.defineProperty(obj, "a", { value: 3, configurable: false, enumerable: true });
    Object.defineProperty(obj, "b", { value: 4, writable: false, enumerable: true });

    let {...rest} = obj;

    assert(rest.a === 3);
    assert(rest.b === 4);

    assertPropDescriptor(rest, 'a');
    assertPropDescriptor(rest, 'b');
})();

// Destructuring function parameter

(() => {

    var o = { x: 1, y: 2, w: 3, z: 4 };
    
    function foo({ x, y, ...rest }) {
        assert(x === 1);
        assert(y === 2);
        assert(rest.w === 3);
        assert(rest.z === 4);
    }
    foo(o);
})();

// Destructuring arrow function parameter

(() => {

    var o = { x: 1, y: 2, w: 3, z: 4 };
    
    (({ x, y, ...rest }) => {
        assert(x === 1);
        assert(y === 2);
        assert(rest.w === 3);
        assert(rest.z === 4);
    })(o);
})();

// Destructuring to a property
(() => {

    var o = { x: 1, y: 2};
    
    let settedValue;
    let src = {};
    ({...src.y} = o);
    assert(src.y.x === 1);
    assert(src.y.y === 2);
})();

// Destructuring with setter
(() => {

    var o = { x: 1, y: 2};
    
    let settedValue;
    let src = {
        get y() { throw Error("The property should not be accessed"); },
        set y(v) {
            settedValue = v;
        }
    }
    src.y = undefined;
    ({...src.y} = o);
    assert(settedValue.x === 1);
    assert(settedValue.y === 2);
})();

// Destructuring computed property
(() => {

    var a = "foo";
    
    var {[a]: b, ...r} = {foo: 1, bar: 2, baz: 3};
    assert(b === 1);
    assert(r.bar === 2);
    assert(r.baz === 3);
})();

// Catch case

(() => {
    try {
        throw {foo: 1, bar: 2, baz: 3};
    } catch({foo, ...rest}) {
        assert(foo === 1);
        assert(rest.bar === 2);
        assert(rest.baz === 3);
    }
})();


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let assert = (e) => {',
       message: 'Parsing error: Unexpected token assert',
       line: 1,
       column: 5 } ],
  output: 'let assert = (e) => {\n    if (!e)\n        throw Error("Bad assertion!");\n}\n\nlet assertPropDescriptor = (restObj, prop) => {\n    let desc = Object.getOwnPropertyDescriptor(restObj, prop);\n    assert(desc.enumerable);\n    assert(desc.writable);\n    assert(desc.configurable);\n}\n\n// Base Case\n(() => {\n    let obj = {x: 1, y: 2, a: 5, b: 3}\n\n    let {a, b, ...rest} = obj;\n\n    assert(a === 5);\n    assert(b === 3);\n\n    assert(rest.x === 1);\n    assert(rest.y === 2);\n\n    assertPropDescriptor(rest, \'x\');\n    assertPropDescriptor(rest, \'y\');\n})();\n\n// Empty Object\n(() => {\n    let obj = {}\n\n    let {a, b, ...rest} = obj;\n\n    assert(a === undefined);\n    assert(b === undefined);\n\n    assert(typeof rest === "object");\n})();\n\n// Number case\n(() => {\n    let obj = 3;\n\n    let {...rest} = obj;\n\n    assert(typeof rest === "object");\n})();\n\n// String case\n(() => {\n    let obj = "foo";\n\n    let {...rest} = obj;\n\n    assert(typeof rest === "object");\n})();\n\n// Symbol case\n(() => {\n    let obj = Symbol("foo");\n\n    let {...rest} = obj;\n\n    assert(typeof rest === "object");\n})();\n\n// null case\n(() => {\n    let obj = null;\n\n    try {\n        let {...rest} = obj;\n        assert(false);\n    } catch (e) {\n        assert(e.message == "Right side of assignment cannot be destructured");\n    }\n\n})();\n\n// undefined case\n(() => {\n    let obj = undefined;\n\n    try {\n        let {...rest} = obj;\n        assert(false);\n    } catch (e) {\n        assert(e.message == "Right side of assignment cannot be destructured");\n    }\n\n})();\n\n// getter case\n(() => {\n    let obj = {a: 3, b: 4};\n    Object.defineProperty(obj, "x", { get: () => 3, enumerable: true });\n\n    let {a, b, ...rest} = obj;\n\n    assert(a === 3);\n    assert(b === 4);\n\n    assert(rest.x === 3);\n    assertPropDescriptor(rest, \'x\');\n})();\n\n// Skip non-enumerable case\n(() => {\n    let obj = {a: 3, b: 4};\n    Object.defineProperty(obj, "x", { value: 4, enumerable: false });\n\n    let {...rest} = obj;\n\n    assert(rest.a === 3);\n    assert(rest.b === 4);\n    assert(rest.x === undefined);\n})();\n\n// Don\'t copy descriptor case\n(() => {\n    let obj = {};\n    Object.defineProperty(obj, "a", { value: 3, configurable: false, enumerable: true });\n    Object.defineProperty(obj, "b", { value: 4, writable: false, enumerable: true });\n\n    let {...rest} = obj;\n\n    assert(rest.a === 3);\n    assert(rest.b === 4);\n\n    assertPropDescriptor(rest, \'a\');\n    assertPropDescriptor(rest, \'b\');\n})();\n\n// Destructuring function parameter\n\n(() => {\n\n    var o = { x: 1, y: 2, w: 3, z: 4 };\n    \n    function foo({ x, y, ...rest }) {\n        assert(x === 1);\n        assert(y === 2);\n        assert(rest.w === 3);\n        assert(rest.z === 4);\n    }\n    foo(o);\n})();\n\n// Destructuring arrow function parameter\n\n(() => {\n\n    var o = { x: 1, y: 2, w: 3, z: 4 };\n    \n    (({ x, y, ...rest }) => {\n        assert(x === 1);\n        assert(y === 2);\n        assert(rest.w === 3);\n        assert(rest.z === 4);\n    })(o);\n})();\n\n// Destructuring to a property\n(() => {\n\n    var o = { x: 1, y: 2};\n    \n    let settedValue;\n    let src = {};\n    ({...src.y} = o);\n    assert(src.y.x === 1);\n    assert(src.y.y === 2);\n})();\n\n// Destructuring with setter\n(() => {\n\n    var o = { x: 1, y: 2};\n    \n    let settedValue;\n    let src = {\n        get y() { throw Error("The property should not be accessed"); },\n        set y(v) {\n            settedValue = v;\n        }\n    }\n    src.y = undefined;\n    ({...src.y} = o);\n    assert(settedValue.x === 1);\n    assert(settedValue.y === 2);\n})();\n\n// Destructuring computed property\n(() => {\n\n    var a = "foo";\n    \n    var {[a]: b, ...r} = {foo: 1, bar: 2, baz: 3};\n    assert(b === 1);\n    assert(r.bar === 2);\n    assert(r.baz === 3);\n})();\n\n// Catch case\n\n(() => {\n    try {\n        throw {foo: 1, bar: 2, baz: 3};\n    } catch({foo, ...rest}) {\n        assert(foo === 1);\n        assert(rest.bar === 2);\n        assert(rest.baz === 3);\n    }\n})();\n\n' }
object-spread.js:SyntaxError: Unexpected token ...
let assert = (a) => {
    if (!a)
        throw new Error("Bad Assertion");
}

assert.sameValue = (a, b) =>  {
    assert(a === b);
}

function validatePropertyDescriptor(o, p) {
    let desc = Object.getOwnPropertyDescriptor(o, p);

    assert(desc.enumerable);
    assert(desc.configurable);
    assert(desc.writable);
}

// Base cases

(() => {
    let obj = {a: 1, b: 2, ...{c: 3, d: 4}};

    assert.sameValue(obj.a, 1);
    assert(obj.b, 2);
    assert(obj.c, 3);
    assert(obj.d, 4);
    validatePropertyDescriptor(obj, "c");
    validatePropertyDescriptor(obj, "d");
    assert(Object.keys(obj), 2);
})();

(() => {
    let o = {c: 3, d: 4};
    let obj = {a: 1, b: 2, ...o};

    assert.sameValue(obj.a, 1);
    assert.sameValue(obj.b, 2);
    assert.sameValue(obj.c, 3);
    assert.sameValue(obj.d, 4);
    assert.sameValue(Object.keys(obj).length, 4);

    validatePropertyDescriptor(obj, "a");
    validatePropertyDescriptor(obj, "b");
    validatePropertyDescriptor(obj, "c");
    validatePropertyDescriptor(obj, "d");
})();

(() => {
    let o = {a: 2, b: 3};
    let o2 = {c: 4, d: 5};

    let obj = {...o, ...o2};

    assert.sameValue(obj.a, 2);
    assert.sameValue(obj.b, 3);
    assert.sameValue(obj.c, 4);
    assert.sameValue(obj.d, 5);
    assert.sameValue(Object.keys(obj).length, 4);
})();

// Empty case

(() => {
    let obj = {a: 1, b: 2, ...{}};

    assert.sameValue(obj.a, 1);
    assert.sameValue(obj.b, 2);
    assert.sameValue(Object.keys(obj).length, 2);
})();

// Ignoring cases

(() => {
    let obj = {a: 1, ...null, b: 2, ...undefined, c: 3, ...{}, ...{...{}}, d: 4};

    assert.sameValue(obj.a, 1);
    assert.sameValue(obj.b, 2);
    assert.sameValue(obj.c, 3);
    assert.sameValue(obj.d, 4);

    let keys = Object.keys(obj);
    assert.sameValue(keys[0], "a");
    assert.sameValue(keys[1], "b");
    assert.sameValue(keys[2], "c");
    assert.sameValue(keys[3], "d");
})();

// Null case

(() => {
    let obj = {a: 1, b: 2, ...null};

    assert.sameValue(obj.a, 1);
    assert.sameValue(obj.b, 2);
    assert.sameValue(Object.keys(obj).length, 2);
})();

(() => {
    let obj = {...null};

    assert.sameValue(Object.keys(obj).length, 0);
})();

// Undefined case

(() => {
    let obj = {a: 1, b: 2, ...undefined};

    assert.sameValue(obj.a, 1);
    assert.sameValue(obj.b, 2);
    assert.sameValue(Object.keys(obj).length, 2);
})();

(() => {
    let obj = {...undefined};

    assert.sameValue(Object.keys(obj).length, 0);
})();

// Getter case

(() => {
    let o = {
        get a() {
            return 42;
        }
    };

    let obj = {...o, c: 4, d: 5};

    assert.sameValue(Object.getOwnPropertyDescriptor(obj, "a").value, 42);
    assert.sameValue(obj.c, 4);
    assert.sameValue(obj.d, 5);
    assert.sameValue(Object.keys(obj).length, 3);

    validatePropertyDescriptor(obj, "a");
})();

(() => {
    let o = {a: 2, b: 3}
    let executedGetter = false;

    let obj = {...o, get c() { executedGetter = true; }};

    assert.sameValue(obj.a, 2);
    assert.sameValue(obj.b, 3);
    assert.sameValue(executedGetter, false)
    assert.sameValue(Object.keys(obj).length, 3);
})();

(() => {
    let getterCallCount = 0;
    let o = {
        get a() {
            return ++getterCallCount;
        }
    };

    let obj = {...o, c: 4, d: 5, a: 42, ...o};

    assert.sameValue(obj.a, 2);
    assert.sameValue(obj.c, 4);
    assert.sameValue(obj.d, 5);
    assert.sameValue(Object.keys(obj).length, 3);
})();

// Manipulate Object case

(() => {
    var o = { a: 0, b: 1 };
    var cthulhu = { get x() {
      delete o.a;
      o.b = 42;
      o.c = "ni";
    }};

    let obj = {...cthulhu, ...o};

    assert.sameValue(obj.hasOwnProperty("a"), false);
    assert.sameValue(obj.b, 42);
    assert.sameValue(obj.c, "ni");
    assert(obj.hasOwnProperty("x"));
    assert.sameValue(Object.keys(obj).length, 3);
})();

// Override

(() => {
    let o = {a: 2, b: 3};

    let obj = {a: 1, b: 7, ...o};

    assert.sameValue(obj.a, 2);
    assert.sameValue(obj.b, 3);
    assert.sameValue(Object.keys(obj).length, 2);
    assert.sameValue(o.a, 2);
    assert.sameValue(o.b, 3);
})();

(() => {
    let o = {a: 2, b: 3, c: 4, e: undefined, f: null, g: false};

    let obj = {...o, a: 1, b: 7, d: 5, h: -0, i: Symbol("foo"), j: o};

    assert.sameValue(obj.a, 1);
    assert.sameValue(obj.b, 7);
    assert.sameValue(obj.c, 4);
    assert.sameValue(obj.d, 5);
    assert(obj.hasOwnProperty("e"));
    assert.sameValue(obj.f, null);
    assert.sameValue(obj.g, false);
    assert.sameValue(obj.h, -0);
    assert.sameValue(obj.i.toString(), "Symbol(foo)");
    assert(Object.is(obj.j, o));
    assert.sameValue(Object.keys(obj).length, 10);
})();

// Override Immutable

(() => {
    let o = {b: 2};
    Object.defineProperty(o, "a", {value: 1, enumerable: true, writable: false, configurable: true});

    let obj = {...o, a: 3};

    assert.sameValue(obj.a, 3)
    assert.sameValue(obj.b, 2);
    validatePropertyDescriptor(obj, "a");
    validatePropertyDescriptor(obj, "b");
})();

// Setter

(() => {
    let executedSetter = false;

    let obj = {set c(v) { executedSetter = true; }, ...{c: 1}};

    assert.sameValue(obj.c, 1);
    assert.sameValue(executedSetter, false);
    assert.sameValue(Object.keys(obj).length, 1);
})();

// Skip non-enumerble

(() => {
    let o = {};
    Object.defineProperty(o, "b", {value: 3, enumerable: false});

    let obj = {...o};

    assert.sameValue(obj.hasOwnProperty("b"), false)
    assert.sameValue(Object.keys(obj).length, 0);
})();

// Spread order

(() => {
    var calls = []
    var o = { get z() { calls.push('z') }, get a() { calls.push('a') } };
    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });
    Object.defineProperty(o, Symbol('foo'), { get: () => { calls.push("Symbol(foo)") }, enumerable: true });

    let obj = {...o};

    assert.sameValue(calls[0], 1);
    assert.sameValue(calls[1], "z");
    assert.sameValue(calls[2], "a");
    assert.sameValue(calls[3], "Symbol(foo)");
    assert.sameValue(Object.keys(obj).length, 3);
})();

// Symbol property
(() => {
    let symbol = Symbol('foo');
    let o = {};
    o[symbol] = 1;

    let obj = {...o, c: 4, d: 5};

    assert.sameValue(obj[symbol], 1);
    assert.sameValue(obj.c, 4);
    assert.sameValue(obj.d, 5);
    assert.sameValue(Object.keys(obj).length, 2);
})();

// Getter throw

(() => {
    try {
        let obj = {...{ get foo() { throw new Error("Getter Exception"); } }};
        assert(false);
    } catch(e) {
        assert.sameValue(e.message, "Getter Exception");
    }
})();

// Spread overrides properties

(() => {
    var calls = []
    var o = { a: 1, b: 2 };

    let executedGetter = false;
    let executedSetter = false
    let obj = {get a() {executedGetter = true; return this_a;}, ...o, set a(v) { executedSetter = true; this._a = v}};

    obj.a = 3
    assert.sameValue(obj.a, undefined);
    assert(!executedGetter);
    assert(executedSetter);
})();


{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'let assert = (a) => {',
       message: 'Parsing error: Unexpected token assert',
       line: 1,
       column: 5 } ],
  output: 'let assert = (a) => {\n    if (!a)\n        throw new Error("Bad Assertion");\n}\n\nassert.sameValue = (a, b) =>  {\n    assert(a === b);\n}\n\nfunction validatePropertyDescriptor(o, p) {\n    let desc = Object.getOwnPropertyDescriptor(o, p);\n\n    assert(desc.enumerable);\n    assert(desc.configurable);\n    assert(desc.writable);\n}\n\n// Base cases\n\n(() => {\n    let obj = {a: 1, b: 2, ...{c: 3, d: 4}};\n\n    assert.sameValue(obj.a, 1);\n    assert(obj.b, 2);\n    assert(obj.c, 3);\n    assert(obj.d, 4);\n    validatePropertyDescriptor(obj, "c");\n    validatePropertyDescriptor(obj, "d");\n    assert(Object.keys(obj), 2);\n})();\n\n(() => {\n    let o = {c: 3, d: 4};\n    let obj = {a: 1, b: 2, ...o};\n\n    assert.sameValue(obj.a, 1);\n    assert.sameValue(obj.b, 2);\n    assert.sameValue(obj.c, 3);\n    assert.sameValue(obj.d, 4);\n    assert.sameValue(Object.keys(obj).length, 4);\n\n    validatePropertyDescriptor(obj, "a");\n    validatePropertyDescriptor(obj, "b");\n    validatePropertyDescriptor(obj, "c");\n    validatePropertyDescriptor(obj, "d");\n})();\n\n(() => {\n    let o = {a: 2, b: 3};\n    let o2 = {c: 4, d: 5};\n\n    let obj = {...o, ...o2};\n\n    assert.sameValue(obj.a, 2);\n    assert.sameValue(obj.b, 3);\n    assert.sameValue(obj.c, 4);\n    assert.sameValue(obj.d, 5);\n    assert.sameValue(Object.keys(obj).length, 4);\n})();\n\n// Empty case\n\n(() => {\n    let obj = {a: 1, b: 2, ...{}};\n\n    assert.sameValue(obj.a, 1);\n    assert.sameValue(obj.b, 2);\n    assert.sameValue(Object.keys(obj).length, 2);\n})();\n\n// Ignoring cases\n\n(() => {\n    let obj = {a: 1, ...null, b: 2, ...undefined, c: 3, ...{}, ...{...{}}, d: 4};\n\n    assert.sameValue(obj.a, 1);\n    assert.sameValue(obj.b, 2);\n    assert.sameValue(obj.c, 3);\n    assert.sameValue(obj.d, 4);\n\n    let keys = Object.keys(obj);\n    assert.sameValue(keys[0], "a");\n    assert.sameValue(keys[1], "b");\n    assert.sameValue(keys[2], "c");\n    assert.sameValue(keys[3], "d");\n})();\n\n// Null case\n\n(() => {\n    let obj = {a: 1, b: 2, ...null};\n\n    assert.sameValue(obj.a, 1);\n    assert.sameValue(obj.b, 2);\n    assert.sameValue(Object.keys(obj).length, 2);\n})();\n\n(() => {\n    let obj = {...null};\n\n    assert.sameValue(Object.keys(obj).length, 0);\n})();\n\n// Undefined case\n\n(() => {\n    let obj = {a: 1, b: 2, ...undefined};\n\n    assert.sameValue(obj.a, 1);\n    assert.sameValue(obj.b, 2);\n    assert.sameValue(Object.keys(obj).length, 2);\n})();\n\n(() => {\n    let obj = {...undefined};\n\n    assert.sameValue(Object.keys(obj).length, 0);\n})();\n\n// Getter case\n\n(() => {\n    let o = {\n        get a() {\n            return 42;\n        }\n    };\n\n    let obj = {...o, c: 4, d: 5};\n\n    assert.sameValue(Object.getOwnPropertyDescriptor(obj, "a").value, 42);\n    assert.sameValue(obj.c, 4);\n    assert.sameValue(obj.d, 5);\n    assert.sameValue(Object.keys(obj).length, 3);\n\n    validatePropertyDescriptor(obj, "a");\n})();\n\n(() => {\n    let o = {a: 2, b: 3}\n    let executedGetter = false;\n\n    let obj = {...o, get c() { executedGetter = true; }};\n\n    assert.sameValue(obj.a, 2);\n    assert.sameValue(obj.b, 3);\n    assert.sameValue(executedGetter, false)\n    assert.sameValue(Object.keys(obj).length, 3);\n})();\n\n(() => {\n    let getterCallCount = 0;\n    let o = {\n        get a() {\n            return ++getterCallCount;\n        }\n    };\n\n    let obj = {...o, c: 4, d: 5, a: 42, ...o};\n\n    assert.sameValue(obj.a, 2);\n    assert.sameValue(obj.c, 4);\n    assert.sameValue(obj.d, 5);\n    assert.sameValue(Object.keys(obj).length, 3);\n})();\n\n// Manipulate Object case\n\n(() => {\n    var o = { a: 0, b: 1 };\n    var cthulhu = { get x() {\n      delete o.a;\n      o.b = 42;\n      o.c = "ni";\n    }};\n\n    let obj = {...cthulhu, ...o};\n\n    assert.sameValue(obj.hasOwnProperty("a"), false);\n    assert.sameValue(obj.b, 42);\n    assert.sameValue(obj.c, "ni");\n    assert(obj.hasOwnProperty("x"));\n    assert.sameValue(Object.keys(obj).length, 3);\n})();\n\n// Override\n\n(() => {\n    let o = {a: 2, b: 3};\n\n    let obj = {a: 1, b: 7, ...o};\n\n    assert.sameValue(obj.a, 2);\n    assert.sameValue(obj.b, 3);\n    assert.sameValue(Object.keys(obj).length, 2);\n    assert.sameValue(o.a, 2);\n    assert.sameValue(o.b, 3);\n})();\n\n(() => {\n    let o = {a: 2, b: 3, c: 4, e: undefined, f: null, g: false};\n\n    let obj = {...o, a: 1, b: 7, d: 5, h: -0, i: Symbol("foo"), j: o};\n\n    assert.sameValue(obj.a, 1);\n    assert.sameValue(obj.b, 7);\n    assert.sameValue(obj.c, 4);\n    assert.sameValue(obj.d, 5);\n    assert(obj.hasOwnProperty("e"));\n    assert.sameValue(obj.f, null);\n    assert.sameValue(obj.g, false);\n    assert.sameValue(obj.h, -0);\n    assert.sameValue(obj.i.toString(), "Symbol(foo)");\n    assert(Object.is(obj.j, o));\n    assert.sameValue(Object.keys(obj).length, 10);\n})();\n\n// Override Immutable\n\n(() => {\n    let o = {b: 2};\n    Object.defineProperty(o, "a", {value: 1, enumerable: true, writable: false, configurable: true});\n\n    let obj = {...o, a: 3};\n\n    assert.sameValue(obj.a, 3)\n    assert.sameValue(obj.b, 2);\n    validatePropertyDescriptor(obj, "a");\n    validatePropertyDescriptor(obj, "b");\n})();\n\n// Setter\n\n(() => {\n    let executedSetter = false;\n\n    let obj = {set c(v) { executedSetter = true; }, ...{c: 1}};\n\n    assert.sameValue(obj.c, 1);\n    assert.sameValue(executedSetter, false);\n    assert.sameValue(Object.keys(obj).length, 1);\n})();\n\n// Skip non-enumerble\n\n(() => {\n    let o = {};\n    Object.defineProperty(o, "b", {value: 3, enumerable: false});\n\n    let obj = {...o};\n\n    assert.sameValue(obj.hasOwnProperty("b"), false)\n    assert.sameValue(Object.keys(obj).length, 0);\n})();\n\n// Spread order\n\n(() => {\n    var calls = []\n    var o = { get z() { calls.push(\'z\') }, get a() { calls.push(\'a\') } };\n    Object.defineProperty(o, 1, { get: () => { calls.push(1) }, enumerable: true });\n    Object.defineProperty(o, Symbol(\'foo\'), { get: () => { calls.push("Symbol(foo)") }, enumerable: true });\n\n    let obj = {...o};\n\n    assert.sameValue(calls[0], 1);\n    assert.sameValue(calls[1], "z");\n    assert.sameValue(calls[2], "a");\n    assert.sameValue(calls[3], "Symbol(foo)");\n    assert.sameValue(Object.keys(obj).length, 3);\n})();\n\n// Symbol property\n(() => {\n    let symbol = Symbol(\'foo\');\n    let o = {};\n    o[symbol] = 1;\n\n    let obj = {...o, c: 4, d: 5};\n\n    assert.sameValue(obj[symbol], 1);\n    assert.sameValue(obj.c, 4);\n    assert.sameValue(obj.d, 5);\n    assert.sameValue(Object.keys(obj).length, 2);\n})();\n\n// Getter throw\n\n(() => {\n    try {\n        let obj = {...{ get foo() { throw new Error("Getter Exception"); } }};\n        assert(false);\n    } catch(e) {\n        assert.sameValue(e.message, "Getter Exception");\n    }\n})();\n\n// Spread overrides properties\n\n(() => {\n    var calls = []\n    var o = { a: 1, b: 2 };\n\n    let executedGetter = false;\n    let executedSetter = false\n    let obj = {get a() {executedGetter = true; return this_a;}, ...o, set a(v) { executedSetter = true; this._a = v}};\n\n    obj.a = 3\n    assert.sameValue(obj.a, undefined);\n    assert(!executedGetter);\n    assert(executedSetter);\n})();\n\n' }
optional-catch-binding.js:SyntaxError: Unexpected token {
function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

function throwException() {
    throw new Error(`Cocoa`);
}

shouldBe(function () {
    try {
        throwException();
    } catch {
        return true;
    }
    return false;
}(), true);

shouldBe(function () {
    var ok = false;
    try {
        throwException();
    } catch {
        ok = true;
        return false;
    } finally {
        return ok;
    }
    return false;
}(), true);

shouldBe(function () {
    let value = 'Cocoa';
    try {
        throwException();
    } catch {
        let value = 'Cappuccino';
        return value;
    }
}(), 'Cappuccino');

shouldBe(function () {
    var value = 'Cocoa';
    try {
        throwException();
    } catch {
        let value = 'Cappuccino';
    }
    return value;
}(), 'Cocoa');

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    throw new Error(`Cocoa`);',
       message: 'Parsing error: Unexpected character \'`\'',
       line: 7,
       column: 21 } ],
  output: 'function shouldBe(actual, expected) {\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\nfunction throwException() {\n    throw new Error(`Cocoa`);\n}\n\nshouldBe(function () {\n    try {\n        throwException();\n    } catch {\n        return true;\n    }\n    return false;\n}(), true);\n\nshouldBe(function () {\n    var ok = false;\n    try {\n        throwException();\n    } catch {\n        ok = true;\n        return false;\n    } finally {\n        return ok;\n    }\n    return false;\n}(), true);\n\nshouldBe(function () {\n    let value = \'Cocoa\';\n    try {\n        throwException();\n    } catch {\n        let value = \'Cappuccino\';\n        return value;\n    }\n}(), \'Cappuccino\');\n\nshouldBe(function () {\n    var value = \'Cocoa\';\n    try {\n        throwException();\n    } catch {\n        let value = \'Cappuccino\';\n    }\n    return value;\n}(), \'Cocoa\');\n' }
pow-coherency.js:SyntaxError: Unexpected token *
//@ skip

// This test checks that the pow function returns coherent results:
// (a) Across different compilation tiers
// (b) With integer exponents represented as int32 or as double

function pow42() {
    return { value: 2.1 ** 42, ftl: isFinalTier() };
}

function build42AsDouble() {
    function opaqueAdd(x, y) { return x + y; }
    return opaqueAdd(42 - 0.123, 0.123);
}

var double42 = build42AsDouble();

if (double42 !== 42)
    throw new Error("42 (as double) should be === to 42 (as int)");

function powDouble42() {
    return { value: 2.1 ** double42, ftl: isFinalTier() };
}

function clobber() { }
noInline(clobber);

function pow42NoConstantFolding() {
    var obj = { x: 2.1, y: 42 };
    clobber(obj);
    return { value: obj.x ** obj.y, ftl: isFinalTier() };
}

function powDouble42NoConstantFolding() {
    var obj = { x: 2.1, y: double42 };
    clobber(obj);
    return { value: obj.x ** obj.y, ftl: isFinalTier() };
}

var results = { 'jit': {}, 'dfg': {}, 'ftl': {} };
var funs = [
    [ 'pow42', pow42 ],
    [ 'powDouble42', powDouble42 ],
    [ 'pow42NoConstantFolding', pow42NoConstantFolding ],
    [ 'powDouble42NoConstantFolding', powDouble42NoConstantFolding ]
];
var tiers = ['jit', 'dfg', 'ftl'];

for (var i = 0; i < 100000; ++i) {
    for (var j in funs) {
        var name = funs[j][0];
        var fun = funs[j][1];
        var result = fun();
        if (result.ftl)
            results['ftl'][name] = result.value;
        else if (numberOfDFGCompiles(fun) > 0)
            results['dfg'][name] = result.value;
        else
            results['jit'][name] = result.value;
    }
}

var errors = [];
var valuesFor = {};
for (var i in tiers) {
    var tier = tiers[i];
    var result = results[tier];
    // We don't have this tier
    if (Object.keys(result).length === 0)
        continue;

    for (var j in funs) {
        var name = funs[j][0];
        if (!(name in result))
            errors.push(name + " was not compiled to " + tier);
        else if (!(name in valuesFor))
            valuesFor[name] = { value: result[name], tiers: [tier] };
        else if (result[name] !== valuesFor[name].value)
            errors.push(name + " has different results in " + tier + " (" + result[name] + ") and " + valuesFor[name].tiers + " (" + valuesFor[name].value + ")");
        else
            valuesFor[name].tiers.push(tier);
    }
}

var reference = funs[0][0];
var result = valuesFor[reference].value;

for (var j in funs) {
    var name = funs[j][0];
    if (valuesFor[name].value !== result)
        errors.push(name + " (" + valuesFor[name].value + ") and " + reference + " (" + result + ") have different results");
}

if (errors.length > 0)
    throw new Error(errors.join('\n'));

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return { value: 2.1 ** 42, ftl: isFinalTier() };',
       message: 'Parsing error: Unexpected token *',
       line: 8,
       column: 26 } ],
  output: '//@ skip\n\n// This test checks that the pow function returns coherent results:\n// (a) Across different compilation tiers\n// (b) With integer exponents represented as int32 or as double\n\nfunction pow42() {\n    return { value: 2.1 ** 42, ftl: isFinalTier() };\n}\n\nfunction build42AsDouble() {\n    function opaqueAdd(x, y) { return x + y; }\n    return opaqueAdd(42 - 0.123, 0.123);\n}\n\nvar double42 = build42AsDouble();\n\nif (double42 !== 42)\n    throw new Error("42 (as double) should be === to 42 (as int)");\n\nfunction powDouble42() {\n    return { value: 2.1 ** double42, ftl: isFinalTier() };\n}\n\nfunction clobber() { }\nnoInline(clobber);\n\nfunction pow42NoConstantFolding() {\n    var obj = { x: 2.1, y: 42 };\n    clobber(obj);\n    return { value: obj.x ** obj.y, ftl: isFinalTier() };\n}\n\nfunction powDouble42NoConstantFolding() {\n    var obj = { x: 2.1, y: double42 };\n    clobber(obj);\n    return { value: obj.x ** obj.y, ftl: isFinalTier() };\n}\n\nvar results = { \'jit\': {}, \'dfg\': {}, \'ftl\': {} };\nvar funs = [\n    [ \'pow42\', pow42 ],\n    [ \'powDouble42\', powDouble42 ],\n    [ \'pow42NoConstantFolding\', pow42NoConstantFolding ],\n    [ \'powDouble42NoConstantFolding\', powDouble42NoConstantFolding ]\n];\nvar tiers = [\'jit\', \'dfg\', \'ftl\'];\n\nfor (var i = 0; i < 100000; ++i) {\n    for (var j in funs) {\n        var name = funs[j][0];\n        var fun = funs[j][1];\n        var result = fun();\n        if (result.ftl)\n            results[\'ftl\'][name] = result.value;\n        else if (numberOfDFGCompiles(fun) > 0)\n            results[\'dfg\'][name] = result.value;\n        else\n            results[\'jit\'][name] = result.value;\n    }\n}\n\nvar errors = [];\nvar valuesFor = {};\nfor (var i in tiers) {\n    var tier = tiers[i];\n    var result = results[tier];\n    // We don\'t have this tier\n    if (Object.keys(result).length === 0)\n        continue;\n\n    for (var j in funs) {\n        var name = funs[j][0];\n        if (!(name in result))\n            errors.push(name + " was not compiled to " + tier);\n        else if (!(name in valuesFor))\n            valuesFor[name] = { value: result[name], tiers: [tier] };\n        else if (result[name] !== valuesFor[name].value)\n            errors.push(name + " has different results in " + tier + " (" + result[name] + ") and " + valuesFor[name].tiers + " (" + valuesFor[name].value + ")");\n        else\n            valuesFor[name].tiers.push(tier);\n    }\n}\n\nvar reference = funs[0][0];\nvar result = valuesFor[reference].value;\n\nfor (var j in funs) {\n    var name = funs[j][0];\n    if (valuesFor[name].value !== result)\n        errors.push(name + " (" + valuesFor[name].value + ") and " + reference + " (" + result + ") have different results");\n}\n\nif (errors.length > 0)\n    throw new Error(errors.join(\'\\n\'));\n' }
pow-basics.js:SyntaxError: Unexpected token *
function valuesAreClose(a, b) {
    return Math.abs(a / b) - 1 < 1e-10;
}

// Some random values.
function mathPowDoubleDouble1(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble1);

function mathPowDoubleInt1(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt1);

function test1(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble1(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble1(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt1(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt1(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test1);
test1(376.76522764377296, 10.81699226051569, 7.333951929109252e+27, 5.76378989575089e+25);

function mathPowDoubleDouble2(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble2);

function mathPowDoubleInt2(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt2);
function test2(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble2(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble2(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt2(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt2(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test2);
test2(376.76522764377296, -5.81699226051569, 1.035180331187579e-15, 1.3171824310400265e-13);

function mathPowDoubleDouble3(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble3);

function mathPowDoubleInt3(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt3);
function test3(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble3(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble3(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt3(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt3(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test3);
test3(-37.676522764377296, 10.0, 5763789895750892, 5763789895750892);

// Exponent zero.
function mathPowDoubleDouble4(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble4);

function mathPowDoubleInt4(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt4);
function test4(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble4(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble4(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt4(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt4(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test4);
test4(-37.676522764377296, 0, 1, 1);

// Exponent minus zero.
function mathPowDoubleDouble5(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble5);

function mathPowDoubleInt5(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt5);
function test5(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble5(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble5(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt5(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test5);
test5(-37.676522764377296, -0, 1, 1);

// Exponent 1.
function mathPowDoubleDouble6(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble6);

function mathPowDoubleInt6(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt6);
function test6(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble6(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble6(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt6(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt6(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test6);
test6(-37.676522764377296, 1.0, -37.676522764377296, -37.676522764377296);

// Exponent -1.
function mathPowDoubleDouble7(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble7);

function mathPowDoubleInt7(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt7);
function test7(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble7(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble7(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble7(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleDouble7(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test7);
test7(-37.676522764377296, -1.0, -0.026541727490454296, -0.026541727490454296);

// Let's square things.
function mathPowDoubleDouble8(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble8);

function mathPowDoubleInt8(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt8);
function test8(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble8(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble8(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt8(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt8(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test8);
test8(-37.676522764377296, 2.0, 1419.5203676146407, 1419.5203676146407);

function mathPowDoubleDouble9(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble9);

function mathPowDoubleInt9(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt9);
function test9(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble9(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble9(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt9(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt9(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test9);
test9(37.676522764377296, 2.0, 1419.5203676146407, 1419.5203676146407);

// Let's cube things.
function mathPowDoubleDouble10(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble10);

function mathPowDoubleInt10(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt10);
function test10(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble10(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt10(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test10);
test10(-37.676522764377296, 3.0, -53482.591444930236, -53482.591444930236);

function mathPowDoubleDouble11(x, y) {
    return x ** y;
}
noInline(mathPowDoubleDouble11);

function mathPowDoubleInt11(x, y) {
    return x ** y;
}
noInline(mathPowDoubleInt11);
function test11(x, y, expected1, expected2) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDouble11(x, y);
        if (!valuesAreClose(result, expected1))
            throw "Error: bad result, mathPowDoubleDouble(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleInt11(x, integerY);
        if (!valuesAreClose(result, expected2))
            throw "Error: bad result, mathPowDoubleInt(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;
    }
}
noInline(test11);
test11(37.676522764377296, 3.0, 53482.591444930236, 53482.591444930236);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return x ** y;',
       message: 'Parsing error: Unexpected token *',
       line: 7,
       column: 15 } ],
  output: 'function valuesAreClose(a, b) {\n    return Math.abs(a / b) - 1 < 1e-10;\n}\n\n// Some random values.\nfunction mathPowDoubleDouble1(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble1);\n\nfunction mathPowDoubleInt1(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt1);\n\nfunction test1(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble1(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble1(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt1(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt1(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test1);\ntest1(376.76522764377296, 10.81699226051569, 7.333951929109252e+27, 5.76378989575089e+25);\n\nfunction mathPowDoubleDouble2(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble2);\n\nfunction mathPowDoubleInt2(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt2);\nfunction test2(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble2(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble2(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt2(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt2(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test2);\ntest2(376.76522764377296, -5.81699226051569, 1.035180331187579e-15, 1.3171824310400265e-13);\n\nfunction mathPowDoubleDouble3(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble3);\n\nfunction mathPowDoubleInt3(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt3);\nfunction test3(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble3(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble3(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt3(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt3(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test3);\ntest3(-37.676522764377296, 10.0, 5763789895750892, 5763789895750892);\n\n// Exponent zero.\nfunction mathPowDoubleDouble4(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble4);\n\nfunction mathPowDoubleInt4(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt4);\nfunction test4(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble4(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble4(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt4(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt4(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test4);\ntest4(-37.676522764377296, 0, 1, 1);\n\n// Exponent minus zero.\nfunction mathPowDoubleDouble5(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble5);\n\nfunction mathPowDoubleInt5(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt5);\nfunction test5(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble5(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble5(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt5(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test5);\ntest5(-37.676522764377296, -0, 1, 1);\n\n// Exponent 1.\nfunction mathPowDoubleDouble6(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble6);\n\nfunction mathPowDoubleInt6(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt6);\nfunction test6(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble6(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble6(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt6(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt6(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test6);\ntest6(-37.676522764377296, 1.0, -37.676522764377296, -37.676522764377296);\n\n// Exponent -1.\nfunction mathPowDoubleDouble7(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble7);\n\nfunction mathPowDoubleInt7(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt7);\nfunction test7(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble7(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble7(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble7(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleDouble7(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test7);\ntest7(-37.676522764377296, -1.0, -0.026541727490454296, -0.026541727490454296);\n\n// Let\'s square things.\nfunction mathPowDoubleDouble8(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble8);\n\nfunction mathPowDoubleInt8(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt8);\nfunction test8(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble8(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble8(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt8(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt8(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test8);\ntest8(-37.676522764377296, 2.0, 1419.5203676146407, 1419.5203676146407);\n\nfunction mathPowDoubleDouble9(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble9);\n\nfunction mathPowDoubleInt9(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt9);\nfunction test9(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble9(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble9(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt9(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt9(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test9);\ntest9(37.676522764377296, 2.0, 1419.5203676146407, 1419.5203676146407);\n\n// Let\'s cube things.\nfunction mathPowDoubleDouble10(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble10);\n\nfunction mathPowDoubleInt10(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt10);\nfunction test10(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble10(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt10(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test10);\ntest10(-37.676522764377296, 3.0, -53482.591444930236, -53482.591444930236);\n\nfunction mathPowDoubleDouble11(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleDouble11);\n\nfunction mathPowDoubleInt11(x, y) {\n    return x ** y;\n}\nnoInline(mathPowDoubleInt11);\nfunction test11(x, y, expected1, expected2) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDouble11(x, y);\n        if (!valuesAreClose(result, expected1))\n            throw "Error: bad result, mathPowDoubleDouble(" + x + ", " + y + ") = " + result + " expected a value close to " + expected1;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleInt11(x, integerY);\n        if (!valuesAreClose(result, expected2))\n            throw "Error: bad result, mathPowDoubleInt(" + x + ", " + integerY + ") = " + result + " expected a value close to " + expected2;\n    }\n}\nnoInline(test11);\ntest11(37.676522764377296, 3.0, 53482.591444930236, 53482.591444930236);\n' }
pow-evaluation-order.js:SyntaxError: Unexpected token *
// Copyright (C) 2016 Rick Waldron. All rights reserved.
// This code is governed by the BSD license found in the LICENSE file.

function shouldBe(actual, expected)
{
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

{
    let capture = [];
    let leftValue = { valueOf() { capture.push("leftValue"); return 3; }};
    let rightValue = { valueOf() { capture.push("rightValue"); return 2; }};

    (capture.push("left"), leftValue) ** +(capture.push("right"), rightValue);
//                                       ^
//                                Changes the order

    // Expected per operator evaluation order: "left", "right", "rightValue", "leftValue"
    shouldBe(capture[0], "left");
    shouldBe(capture[1], "right");
    shouldBe(capture[2], "rightValue");
    shouldBe(capture[3], "leftValue");
}

{
    let capture = [];
    let leftValue = { valueOf() { capture.push("leftValue"); return 3; }};
    let rightValue = { valueOf() { capture.push("rightValue"); return 2; }};

    (+(capture.push("left"), leftValue)) ** (capture.push("right"), rightValue);
//   ^
//   Changes the order

    // Expected per operator evaluation order: "left", "right", "rightValue", "leftValue"
    shouldBe(capture[0], "left");
    shouldBe(capture[1], "leftValue");
    shouldBe(capture[2], "right");
    shouldBe(capture[3], "rightValue");
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let capture = [];',
       message: 'Parsing error: Unexpected token capture',
       line: 11,
       column: 9 } ],
  output: '// Copyright (C) 2016 Rick Waldron. All rights reserved.\n// This code is governed by the BSD license found in the LICENSE file.\n\nfunction shouldBe(actual, expected)\n{\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\n{\n    let capture = [];\n    let leftValue = { valueOf() { capture.push("leftValue"); return 3; }};\n    let rightValue = { valueOf() { capture.push("rightValue"); return 2; }};\n\n    (capture.push("left"), leftValue) ** +(capture.push("right"), rightValue);\n//                                       ^\n//                                Changes the order\n\n    // Expected per operator evaluation order: "left", "right", "rightValue", "leftValue"\n    shouldBe(capture[0], "left");\n    shouldBe(capture[1], "right");\n    shouldBe(capture[2], "rightValue");\n    shouldBe(capture[3], "leftValue");\n}\n\n{\n    let capture = [];\n    let leftValue = { valueOf() { capture.push("leftValue"); return 3; }};\n    let rightValue = { valueOf() { capture.push("rightValue"); return 2; }};\n\n    (+(capture.push("left"), leftValue)) ** (capture.push("right"), rightValue);\n//   ^\n//   Changes the order\n\n    // Expected per operator evaluation order: "left", "right", "rightValue", "leftValue"\n    shouldBe(capture[0], "left");\n    shouldBe(capture[1], "leftValue");\n    shouldBe(capture[2], "right");\n    shouldBe(capture[3], "rightValue");\n}\n' }
pow-integer-exponent-fastpath.js:SyntaxError: Unexpected token *
function valuesAreClose(a, b) {
    return Math.abs(a / b) - 1 < 1e-10;
}

// Small exponent values are handled through a simpler inline loop. Test that it is not observable.
function mathPowDoubleDoubleTestExponentFifty(x, y) {
    return x ** y
}
noInline(mathPowDoubleDoubleTestExponentFifty);

function mathPowDoubleIntTestExponentFifty(x, y) {
    return x ** y
}
noInline(mathPowDoubleIntTestExponentFifty);
function testExponentFifty(x, y, expected) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDoubleTestExponentFifty(x, y);
        if (!valuesAreClose(result, expected))
            throw "Error: bad result, (" + x + ") ** (" + y + ") = " + result + " expected value close to " + expected;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleIntTestExponentFifty(x, integerY);
        if (!valuesAreClose(result, expected))
            throw "Error: bad result, (" + x + ") ** (" + integerY + ") = " + result + " expected value close to " + expected;
    }
}
noInline(testExponentFifty);
testExponentFifty(53.70901164133102, 50.0, 3.179494118120144e+86);
testExponentFifty(53.70901164133102, -10.0, 5.006432842621192e-18);

function mathPowDoubleDoubleTestExponentTenThousands(x, y) {
    return x ** y
}
noInline(mathPowDoubleDoubleTestExponentTenThousands);

function mathPowDoubleIntTestExponentTenThousands(x, y) {
    return x ** y
}
noInline(mathPowDoubleIntTestExponentTenThousands);
function testExponentTenThousands(x, y, expected) {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleDoubleTestExponentTenThousands(x, y);
        if (!valuesAreClose(result, expected))
            throw "Error: bad result, (" + x + ") ** (" + y + ") = " + result + " expected value close to " + expected;
    }
    var integerY = y | 0;
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowDoubleIntTestExponentTenThousands(x, integerY);
        if (!valuesAreClose(result, expected))
            throw "Error: bad result, (" + x + ") ** (" + integerY + ") = " + result + " expected value close to " + expected;
    }
}
noInline(testExponentTenThousands);
testExponentTenThousands(1.001, 10000.0, 21916.681339048373);
testExponentTenThousands(1.001, -1.0, 0.9990009990009991);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return x ** y',
       message: 'Parsing error: Unexpected token *',
       line: 7,
       column: 15 } ],
  output: 'function valuesAreClose(a, b) {\n    return Math.abs(a / b) - 1 < 1e-10;\n}\n\n// Small exponent values are handled through a simpler inline loop. Test that it is not observable.\nfunction mathPowDoubleDoubleTestExponentFifty(x, y) {\n    return x ** y\n}\nnoInline(mathPowDoubleDoubleTestExponentFifty);\n\nfunction mathPowDoubleIntTestExponentFifty(x, y) {\n    return x ** y\n}\nnoInline(mathPowDoubleIntTestExponentFifty);\nfunction testExponentFifty(x, y, expected) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDoubleTestExponentFifty(x, y);\n        if (!valuesAreClose(result, expected))\n            throw "Error: bad result, (" + x + ") ** (" + y + ") = " + result + " expected value close to " + expected;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleIntTestExponentFifty(x, integerY);\n        if (!valuesAreClose(result, expected))\n            throw "Error: bad result, (" + x + ") ** (" + integerY + ") = " + result + " expected value close to " + expected;\n    }\n}\nnoInline(testExponentFifty);\ntestExponentFifty(53.70901164133102, 50.0, 3.179494118120144e+86);\ntestExponentFifty(53.70901164133102, -10.0, 5.006432842621192e-18);\n\nfunction mathPowDoubleDoubleTestExponentTenThousands(x, y) {\n    return x ** y\n}\nnoInline(mathPowDoubleDoubleTestExponentTenThousands);\n\nfunction mathPowDoubleIntTestExponentTenThousands(x, y) {\n    return x ** y\n}\nnoInline(mathPowDoubleIntTestExponentTenThousands);\nfunction testExponentTenThousands(x, y, expected) {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleDoubleTestExponentTenThousands(x, y);\n        if (!valuesAreClose(result, expected))\n            throw "Error: bad result, (" + x + ") ** (" + y + ") = " + result + " expected value close to " + expected;\n    }\n    var integerY = y | 0;\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowDoubleIntTestExponentTenThousands(x, integerY);\n        if (!valuesAreClose(result, expected))\n            throw "Error: bad result, (" + x + ") ** (" + integerY + ") = " + result + " expected value close to " + expected;\n    }\n}\nnoInline(testExponentTenThousands);\ntestExponentTenThousands(1.001, 10000.0, 21916.681339048373);\ntestExponentTenThousands(1.001, -1.0, 0.9990009990009991);\n' }
pow-simple.js:SyntaxError: Unexpected token *
function shouldBe(actual, expected)
{
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

{
    let i = 2;
    let j = 3;
    shouldBe(2 ** 3, 8);
    shouldBe(i ** 3, 8);
    shouldBe(2 ** j, 8);
    shouldBe(i ** j, 8);
}

{
    shouldBe(2 ** 3 ** 3, 134217728);
    shouldBe(2 ** 3 + 3, 11);
    shouldBe(2 ** 3 + 3 ** 3, 35);
    shouldBe(2 ** 3 * 3, 24);
    shouldBe(2 ** 3 * 3 ** 3, 216);

    shouldBe(2 + 3 ** 3, 29);
    shouldBe(2 * 3 ** 3, 54);
}

{
    let i = 2;
    i **= 4;
    shouldBe(i, 16);
    i **= 1 + 1;
    shouldBe(i, 256);
}

for (let i = 0; i < 1e4; ++i) {
    let a = Math.random();
    let b = Math.random();
    shouldBe(a ** b, Math.pow(a, b));
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let i = 2;',
       message: 'Parsing error: Unexpected token i',
       line: 8,
       column: 9 } ],
  output: 'function shouldBe(actual, expected)\n{\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\n{\n    let i = 2;\n    let j = 3;\n    shouldBe(2 ** 3, 8);\n    shouldBe(i ** 3, 8);\n    shouldBe(2 ** j, 8);\n    shouldBe(i ** j, 8);\n}\n\n{\n    shouldBe(2 ** 3 ** 3, 134217728);\n    shouldBe(2 ** 3 + 3, 11);\n    shouldBe(2 ** 3 + 3 ** 3, 35);\n    shouldBe(2 ** 3 * 3, 24);\n    shouldBe(2 ** 3 * 3 ** 3, 216);\n\n    shouldBe(2 + 3 ** 3, 29);\n    shouldBe(2 * 3 ** 3, 54);\n}\n\n{\n    let i = 2;\n    i **= 4;\n    shouldBe(i, 16);\n    i **= 1 + 1;\n    shouldBe(i, 256);\n}\n\nfor (let i = 0; i < 1e4; ++i) {\n    let a = Math.random();\n    let b = Math.random();\n    shouldBe(a ** b, Math.pow(a, b));\n}\n' }
pow-nan-behaviors.js:SyntaxError: Unexpected token *
// If an argument is NaN, the result of x ** y is NaN.
function testIntegerBaseWithNaNExponentStatic() {
    for (var i = 0; i < 10000; ++i) {
        var result = 5 ** NaN;
        if (!isNaN(result))
            throw "Error: bad result, 5 ** NaN = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = i ** NaN;
        if (!isNaN(result))
            throw "Error: bad result, i ** NaN = " + result + " with i = " + i;
    }
}
noInline(testIntegerBaseWithNaNExponentStatic);
testIntegerBaseWithNaNExponentStatic();

function mathPowIntegerBaseWithNaNExponentDynamic(x, y) {
    return x ** y;
}
noInline(mathPowIntegerBaseWithNaNExponentDynamic);
function testIntegerBaseWithNaNExponentDynamic() {
    // Warm up with 2 integers.
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowIntegerBaseWithNaNExponentDynamic(2, 5);
        if (result !== 32)
            throw "Error: bad result, mathPowIntegerBaseWithNaNExponentDynamic(2, 5) = " + result + ", expected 32."
    }

    for (var i = 0; i < 10000; ++i) {
        var result = mathPowIntegerBaseWithNaNExponentDynamic(i, NaN);
        if (!isNaN(result))
            throw "Error: bad result, mathPowIntegerBaseWithNaNExponentDynamic(i, NaN) = " + result + " with i = " + i + ", expected NaN";
    }
}
noInline(testIntegerBaseWithNaNExponentDynamic);
testIntegerBaseWithNaNExponentDynamic();

function testFloatingPointBaseWithNaNExponentStatic() {
    for (var i = 0; i < 10000; ++i) {
        var result = 5.5 ** NaN;
        if (!isNaN(result))
            throw "Error: bad result, 5.5 ** NaN = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = (i + 0.5) ** NaN;
        if (!isNaN(result))
            throw "Error: bad result, (i + 0.5) ** NaN = " + result + " with i = " + i;
    }
}
noInline(testFloatingPointBaseWithNaNExponentStatic);
testFloatingPointBaseWithNaNExponentStatic();

function mathPowFloatingPointBaseWithNaNExponentDynamic(x, y) {
    return x ** y;
}
noInline(mathPowFloatingPointBaseWithNaNExponentDynamic);
function testFloatingPointBaseWithNaNExponentDynamic() {
    // Warm up with 2 double.
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowFloatingPointBaseWithNaNExponentDynamic(2.5, 5.1);
        if (result !== 107.02717054543135)
            throw "Error: bad result, mathPowFloatingPointBaseWithNaNExponentDynamic(2.5, 5.1) = " + result + ", expected 107.02717054543135."
    }

    for (var i = 0; i < 10000; ++i) {
        var result = mathPowFloatingPointBaseWithNaNExponentDynamic(i + 0.5, NaN);
        if (!isNaN(result))
            throw "Error: bad result, mathPowFloatingPointBaseWithNaNExponentDynamic(i + 0.5, NaN) = " + result + " with i = " + i + ", expected NaN";
    }
}
noInline(testFloatingPointBaseWithNaNExponentDynamic);
testFloatingPointBaseWithNaNExponentDynamic();

// If y is +0, the result is 1, even if x is NaN.
// If y is -0, the result is 1, even if x is NaN.
// If x is NaN and y is nonzero, the result is NaN.
function testNaNBaseStatic() {
    for (var i = 0; i < 10000; ++i) {
        var result = NaN ** (i + 1);
        if (!isNaN(result))
            throw "Error: bad result, NaN ** (i + 1) = " + result + " with i = " + i;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = NaN ** (i + 1.5);
        if (!isNaN(result))
            throw "Error: bad result, NaN ** (i + 1.5) = " + result + " with i = " + i;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = NaN ** 0;
        if (result !== 1)
            throw "Error: bad result, NaN ** 0 = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = NaN ** -0;
        if (result !== 1)
            throw "Error: bad result, NaN ** -0 = " + result;
    }
}
noInline(testNaNBaseStatic);
testNaNBaseStatic();

function mathPowNaNBaseDynamic1(x, y) {
    return x ** y;
}
function mathPowNaNBaseDynamic2(x, y) {
    return x ** y;
}
function mathPowNaNBaseDynamic3(x, y) {
    return x ** y;
}
function mathPowNaNBaseDynamic4(x, y) {
    return x ** y;
}
noInline(mathPowNaNBaseDynamic1);
noInline(mathPowNaNBaseDynamic2);
noInline(mathPowNaNBaseDynamic3);
noInline(mathPowNaNBaseDynamic4);
function testNaNBaseDynamic() {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowNaNBaseDynamic1(NaN, i + 1);
        if (!isNaN(result))
            throw "Error: bad result, mathPowNaNBaseDynamic1(NaN, i + 1) = " + result + " with i = " + i;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowNaNBaseDynamic2(NaN, i + 1.5);
        if (!isNaN(result))
            throw "Error: bad result, mathPowNaNBaseDynamic2(NaN, i + 1.5) = " + result + " with i = " + i;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowNaNBaseDynamic3(NaN, 0);
        if (result !== 1)
            throw "Error: bad result, mathPowNaNBaseDynamic3(NaN, 0) = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowNaNBaseDynamic4(NaN, -0);
        if (result !== 1)
            throw "Error: bad result, mathPowNaNBaseDynamic4(NaN, -0) = " + result;
    }
}
noInline(testNaNBaseDynamic);
testNaNBaseDynamic();

// If abs(x) is 1 and y is +Inf the result is NaN.
// If abs(x) is 1 and y is −Inf the result is NaN.
function infiniteExponentsStatic() {
    for (var i = 0; i < 10000; ++i) {
        var result = 1 ** Number.POSITIVE_INFINITY;
        if (!isNaN(result))
            throw "Error: bad result, 1 ** Number.POSITIVE_INFINITY = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = (-1) ** Number.POSITIVE_INFINITY;
        if (!isNaN(result))
            throw "Error: bad result, -1 ** Number.POSITIVE_INFINITY = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = 1 ** Number.NEGATIVE_INFINITY;
        if (!isNaN(result))
            throw "Error: bad result, 1 ** Number.NEGATIVE_INFINITY = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = (-1) ** Number.NEGATIVE_INFINITY;
        if (!isNaN(result))
            throw "Error: bad result, -1 ** Number.NEGATIVE_INFINITY = " + result;
    }
}
noInline(infiniteExponentsStatic);
infiniteExponentsStatic();

function mathPowInfiniteExponentsDynamic1(x, y) {
    return x ** y;
}
function mathPowInfiniteExponentsDynamic2(x, y) {
    return x ** y;
}
function mathPowInfiniteExponentsDynamic3(x, y) {
    return x ** y;
}
function mathPowInfiniteExponentsDynamic4(x, y) {
    return x ** y;
}
noInline(mathPowInfiniteExponentsDynamic1);
noInline(mathPowInfiniteExponentsDynamic2);
noInline(mathPowInfiniteExponentsDynamic3);
noInline(mathPowInfiniteExponentsDynamic4);
function infiniteExponentsDynamic() {
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowInfiniteExponentsDynamic1(1, Number.POSITIVE_INFINITY);
        if (!isNaN(result))
            throw "Error: bad result, mathPowInfiniteExponentsDynamic1(1, Number.POSITIVE_INFINITY) = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowInfiniteExponentsDynamic2(-1, Number.POSITIVE_INFINITY);
        if (!isNaN(result))
            throw "Error: bad result, mathPowInfiniteExponentsDynamic2(-1, Number.POSITIVE_INFINITY) = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowInfiniteExponentsDynamic3(1, Number.NEGATIVE_INFINITY);
        if (!isNaN(result))
            throw "Error: bad result, mathPowInfiniteExponentsDynamic3(1, Number.NEGATIVE_INFINITY) = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = mathPowInfiniteExponentsDynamic4(-1, Number.NEGATIVE_INFINITY);
        if (!isNaN(result))
            throw "Error: bad result, mathPowInfiniteExponentsDynamic4(-1, Number.NEGATIVE_INFINITY) = " + result;
    }
}
noInline(infiniteExponentsDynamic);
infiniteExponentsDynamic();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '        var result = 5 ** NaN;',
       message: 'Parsing error: Unexpected token *',
       line: 4,
       column: 25 } ],
  output: '// If an argument is NaN, the result of x ** y is NaN.\nfunction testIntegerBaseWithNaNExponentStatic() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = 5 ** NaN;\n        if (!isNaN(result))\n            throw "Error: bad result, 5 ** NaN = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = i ** NaN;\n        if (!isNaN(result))\n            throw "Error: bad result, i ** NaN = " + result + " with i = " + i;\n    }\n}\nnoInline(testIntegerBaseWithNaNExponentStatic);\ntestIntegerBaseWithNaNExponentStatic();\n\nfunction mathPowIntegerBaseWithNaNExponentDynamic(x, y) {\n    return x ** y;\n}\nnoInline(mathPowIntegerBaseWithNaNExponentDynamic);\nfunction testIntegerBaseWithNaNExponentDynamic() {\n    // Warm up with 2 integers.\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowIntegerBaseWithNaNExponentDynamic(2, 5);\n        if (result !== 32)\n            throw "Error: bad result, mathPowIntegerBaseWithNaNExponentDynamic(2, 5) = " + result + ", expected 32."\n    }\n\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowIntegerBaseWithNaNExponentDynamic(i, NaN);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowIntegerBaseWithNaNExponentDynamic(i, NaN) = " + result + " with i = " + i + ", expected NaN";\n    }\n}\nnoInline(testIntegerBaseWithNaNExponentDynamic);\ntestIntegerBaseWithNaNExponentDynamic();\n\nfunction testFloatingPointBaseWithNaNExponentStatic() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = 5.5 ** NaN;\n        if (!isNaN(result))\n            throw "Error: bad result, 5.5 ** NaN = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = (i + 0.5) ** NaN;\n        if (!isNaN(result))\n            throw "Error: bad result, (i + 0.5) ** NaN = " + result + " with i = " + i;\n    }\n}\nnoInline(testFloatingPointBaseWithNaNExponentStatic);\ntestFloatingPointBaseWithNaNExponentStatic();\n\nfunction mathPowFloatingPointBaseWithNaNExponentDynamic(x, y) {\n    return x ** y;\n}\nnoInline(mathPowFloatingPointBaseWithNaNExponentDynamic);\nfunction testFloatingPointBaseWithNaNExponentDynamic() {\n    // Warm up with 2 double.\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowFloatingPointBaseWithNaNExponentDynamic(2.5, 5.1);\n        if (result !== 107.02717054543135)\n            throw "Error: bad result, mathPowFloatingPointBaseWithNaNExponentDynamic(2.5, 5.1) = " + result + ", expected 107.02717054543135."\n    }\n\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowFloatingPointBaseWithNaNExponentDynamic(i + 0.5, NaN);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowFloatingPointBaseWithNaNExponentDynamic(i + 0.5, NaN) = " + result + " with i = " + i + ", expected NaN";\n    }\n}\nnoInline(testFloatingPointBaseWithNaNExponentDynamic);\ntestFloatingPointBaseWithNaNExponentDynamic();\n\n// If y is +0, the result is 1, even if x is NaN.\n// If y is -0, the result is 1, even if x is NaN.\n// If x is NaN and y is nonzero, the result is NaN.\nfunction testNaNBaseStatic() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = NaN ** (i + 1);\n        if (!isNaN(result))\n            throw "Error: bad result, NaN ** (i + 1) = " + result + " with i = " + i;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = NaN ** (i + 1.5);\n        if (!isNaN(result))\n            throw "Error: bad result, NaN ** (i + 1.5) = " + result + " with i = " + i;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = NaN ** 0;\n        if (result !== 1)\n            throw "Error: bad result, NaN ** 0 = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = NaN ** -0;\n        if (result !== 1)\n            throw "Error: bad result, NaN ** -0 = " + result;\n    }\n}\nnoInline(testNaNBaseStatic);\ntestNaNBaseStatic();\n\nfunction mathPowNaNBaseDynamic1(x, y) {\n    return x ** y;\n}\nfunction mathPowNaNBaseDynamic2(x, y) {\n    return x ** y;\n}\nfunction mathPowNaNBaseDynamic3(x, y) {\n    return x ** y;\n}\nfunction mathPowNaNBaseDynamic4(x, y) {\n    return x ** y;\n}\nnoInline(mathPowNaNBaseDynamic1);\nnoInline(mathPowNaNBaseDynamic2);\nnoInline(mathPowNaNBaseDynamic3);\nnoInline(mathPowNaNBaseDynamic4);\nfunction testNaNBaseDynamic() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowNaNBaseDynamic1(NaN, i + 1);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowNaNBaseDynamic1(NaN, i + 1) = " + result + " with i = " + i;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowNaNBaseDynamic2(NaN, i + 1.5);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowNaNBaseDynamic2(NaN, i + 1.5) = " + result + " with i = " + i;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowNaNBaseDynamic3(NaN, 0);\n        if (result !== 1)\n            throw "Error: bad result, mathPowNaNBaseDynamic3(NaN, 0) = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowNaNBaseDynamic4(NaN, -0);\n        if (result !== 1)\n            throw "Error: bad result, mathPowNaNBaseDynamic4(NaN, -0) = " + result;\n    }\n}\nnoInline(testNaNBaseDynamic);\ntestNaNBaseDynamic();\n\n// If abs(x) is 1 and y is +Inf the result is NaN.\n// If abs(x) is 1 and y is −Inf the result is NaN.\nfunction infiniteExponentsStatic() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = 1 ** Number.POSITIVE_INFINITY;\n        if (!isNaN(result))\n            throw "Error: bad result, 1 ** Number.POSITIVE_INFINITY = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = (-1) ** Number.POSITIVE_INFINITY;\n        if (!isNaN(result))\n            throw "Error: bad result, -1 ** Number.POSITIVE_INFINITY = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = 1 ** Number.NEGATIVE_INFINITY;\n        if (!isNaN(result))\n            throw "Error: bad result, 1 ** Number.NEGATIVE_INFINITY = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = (-1) ** Number.NEGATIVE_INFINITY;\n        if (!isNaN(result))\n            throw "Error: bad result, -1 ** Number.NEGATIVE_INFINITY = " + result;\n    }\n}\nnoInline(infiniteExponentsStatic);\ninfiniteExponentsStatic();\n\nfunction mathPowInfiniteExponentsDynamic1(x, y) {\n    return x ** y;\n}\nfunction mathPowInfiniteExponentsDynamic2(x, y) {\n    return x ** y;\n}\nfunction mathPowInfiniteExponentsDynamic3(x, y) {\n    return x ** y;\n}\nfunction mathPowInfiniteExponentsDynamic4(x, y) {\n    return x ** y;\n}\nnoInline(mathPowInfiniteExponentsDynamic1);\nnoInline(mathPowInfiniteExponentsDynamic2);\nnoInline(mathPowInfiniteExponentsDynamic3);\nnoInline(mathPowInfiniteExponentsDynamic4);\nfunction infiniteExponentsDynamic() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowInfiniteExponentsDynamic1(1, Number.POSITIVE_INFINITY);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowInfiniteExponentsDynamic1(1, Number.POSITIVE_INFINITY) = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowInfiniteExponentsDynamic2(-1, Number.POSITIVE_INFINITY);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowInfiniteExponentsDynamic2(-1, Number.POSITIVE_INFINITY) = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowInfiniteExponentsDynamic3(1, Number.NEGATIVE_INFINITY);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowInfiniteExponentsDynamic3(1, Number.NEGATIVE_INFINITY) = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = mathPowInfiniteExponentsDynamic4(-1, Number.NEGATIVE_INFINITY);\n        if (!isNaN(result))\n            throw "Error: bad result, mathPowInfiniteExponentsDynamic4(-1, Number.NEGATIVE_INFINITY) = " + result;\n    }\n}\nnoInline(infiniteExponentsDynamic);\ninfiniteExponentsDynamic();\n' }
pow-stable-results.js:SyntaxError: Unexpected token *
// This test verify the results of `**` do not change as we change optimization tier.

function opaquePow(a, b)
{
    return a ** b;
}
noInline(opaquePow);


let caseStrings = [
    "0",
    "-0.",
    "0.5",
    "1",
    "2",
    "-0.5",
    "-1",
    "999",
    "1000",
    "1001",
    "NaN",
    "Infinity",
    "-Infinity",
    "Math.PI",
    "Math.LN2",
    "Math.LN10",
    "Math.E",
    "Math.LOG10E",
    "Math.LOG2E",
    "Math.SQRT2"
];
let cases = [];
for (let caseString of caseStrings) {
    cases.push(eval(caseString));
}

let expectedResults = [];
let constantBaseFunctions = [];
let constantExponentFunctions = [];
for (let i = 0; i < cases.length; ++i) {
    let base = cases[i];

    expectedResults[i] = [];
    for (let j = 0; j < cases.length; ++j) {
        let exponent = cases[j];
        expectedResults[i][j] = base ** exponent;
    }

    eval("constantBaseFunctions[i] = function (exponent) { return (" + caseStrings[i] + ") ** exponent; }");
    eval("constantExponentFunctions[i] = function (base) { return base ** (" + caseStrings[i] + "); }");
}

function isIdentical(result, expected)
{
    if (expected === expected) {
        if (result !== expected)
            return false;
        if (!expected && 1 / expected === -Infinity && 1 / result !== -Infinity)
            return false;

        return true;
    }
    return result !== result;
}

for (let tierUpLoopCounter = 0; tierUpLoopCounter < 1e3; ++tierUpLoopCounter) {
    for (let i = 0; i < cases.length; ++i) {
        let base = cases[i];
        for (let j = 0; j < cases.length; ++j) {
            let exponent = cases[j];
            let expectedResult = expectedResults[i][j];
            let result = opaquePow(base, exponent);
            if (!isIdentical(result, expectedResult))
                throw `Failed opaquePow with base = ${base} exponent = ${exponent} expected (${expectedResult}) got (${result})`;

            result = constantBaseFunctions[i](exponent);
            if (!isIdentical(result, expectedResult))
                throw `Failed constantBaseFunctions with base = ${base} exponent = ${exponent} expected (${expectedResult}) got (${result})`;

            result = constantExponentFunctions[j](base);
            if (!isIdentical(result, expectedResult))
                throw `Failed constantExponentFunctions with base = ${base} exponent = ${exponent} expected (${expectedResult}) got (${result})`;
        }
    }
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return a ** b;',
       message: 'Parsing error: Unexpected token *',
       line: 5,
       column: 15 } ],
  output: '// This test verify the results of `**` do not change as we change optimization tier.\n\nfunction opaquePow(a, b)\n{\n    return a ** b;\n}\nnoInline(opaquePow);\n\n\nlet caseStrings = [\n    "0",\n    "-0.",\n    "0.5",\n    "1",\n    "2",\n    "-0.5",\n    "-1",\n    "999",\n    "1000",\n    "1001",\n    "NaN",\n    "Infinity",\n    "-Infinity",\n    "Math.PI",\n    "Math.LN2",\n    "Math.LN10",\n    "Math.E",\n    "Math.LOG10E",\n    "Math.LOG2E",\n    "Math.SQRT2"\n];\nlet cases = [];\nfor (let caseString of caseStrings) {\n    cases.push(eval(caseString));\n}\n\nlet expectedResults = [];\nlet constantBaseFunctions = [];\nlet constantExponentFunctions = [];\nfor (let i = 0; i < cases.length; ++i) {\n    let base = cases[i];\n\n    expectedResults[i] = [];\n    for (let j = 0; j < cases.length; ++j) {\n        let exponent = cases[j];\n        expectedResults[i][j] = base ** exponent;\n    }\n\n    eval("constantBaseFunctions[i] = function (exponent) { return (" + caseStrings[i] + ") ** exponent; }");\n    eval("constantExponentFunctions[i] = function (base) { return base ** (" + caseStrings[i] + "); }");\n}\n\nfunction isIdentical(result, expected)\n{\n    if (expected === expected) {\n        if (result !== expected)\n            return false;\n        if (!expected && 1 / expected === -Infinity && 1 / result !== -Infinity)\n            return false;\n\n        return true;\n    }\n    return result !== result;\n}\n\nfor (let tierUpLoopCounter = 0; tierUpLoopCounter < 1e3; ++tierUpLoopCounter) {\n    for (let i = 0; i < cases.length; ++i) {\n        let base = cases[i];\n        for (let j = 0; j < cases.length; ++j) {\n            let exponent = cases[j];\n            let expectedResult = expectedResults[i][j];\n            let result = opaquePow(base, exponent);\n            if (!isIdentical(result, expectedResult))\n                throw `Failed opaquePow with base = ${base} exponent = ${exponent} expected (${expectedResult}) got (${result})`;\n\n            result = constantBaseFunctions[i](exponent);\n            if (!isIdentical(result, expectedResult))\n                throw `Failed constantBaseFunctions with base = ${base} exponent = ${exponent} expected (${expectedResult}) got (${result})`;\n\n            result = constantExponentFunctions[j](base);\n            if (!isIdentical(result, expectedResult))\n                throw `Failed constantExponentFunctions with base = ${base} exponent = ${exponent} expected (${expectedResult}) got (${result})`;\n        }\n    }\n}\n' }
pow-to-number-should-be-executed-in-code-side.js:SyntaxError: Unexpected token *
function shouldBe(actual, expected)
{
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

{
    let value = {
        valueOf()
        {
            throw new Error("NG");
        }
    };
    let error = null;

    try {
        2 ** value;
    } catch (e) {
        error = e;
    }
    // global, and valueOf.
    shouldBe(error.stack.split("\n").length, 2);
}

{
    let value = {
        valueOf()
        {
            throw new Error("NG");
        }
    };
    let error = null;

    try {
        value ** 2;
    } catch (e) {
        error = e;
    }
    // global, and valueOf.
    shouldBe(error.stack.split("\n").length, 2);
}

{
    let value = {
        valueOf()
        {
            throw new Error("NG");
        }
    };
    let error = null;

    try {
        Math.pow(value, 2);
    } catch (e) {
        error = e;
    }
    // global, Math.pow, and valueOf.
    shouldBe(error.stack.split("\n").length, 3);
}

{
    let value = {
        valueOf()
        {
            throw new Error("NG");
        }
    };
    let error = null;

    try {
        Math.pow(2, value);
    } catch (e) {
        error = e;
    }
    // global, Math.pow, and valueOf.
    shouldBe(error.stack.split("\n").length, 3);
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let value = {',
       message: 'Parsing error: Unexpected token value',
       line: 8,
       column: 9 } ],
  output: 'function shouldBe(actual, expected)\n{\n    if (actual !== expected)\n        throw new Error(\'bad value: \' + actual);\n}\n\n{\n    let value = {\n        valueOf()\n        {\n            throw new Error("NG");\n        }\n    };\n    let error = null;\n\n    try {\n        2 ** value;\n    } catch (e) {\n        error = e;\n    }\n    // global, and valueOf.\n    shouldBe(error.stack.split("\\n").length, 2);\n}\n\n{\n    let value = {\n        valueOf()\n        {\n            throw new Error("NG");\n        }\n    };\n    let error = null;\n\n    try {\n        value ** 2;\n    } catch (e) {\n        error = e;\n    }\n    // global, and valueOf.\n    shouldBe(error.stack.split("\\n").length, 2);\n}\n\n{\n    let value = {\n        valueOf()\n        {\n            throw new Error("NG");\n        }\n    };\n    let error = null;\n\n    try {\n        Math.pow(value, 2);\n    } catch (e) {\n        error = e;\n    }\n    // global, Math.pow, and valueOf.\n    shouldBe(error.stack.split("\\n").length, 3);\n}\n\n{\n    let value = {\n        valueOf()\n        {\n            throw new Error("NG");\n        }\n    };\n    let error = null;\n\n    try {\n        Math.pow(2, value);\n    } catch (e) {\n        error = e;\n    }\n    // global, Math.pow, and valueOf.\n    shouldBe(error.stack.split("\\n").length, 3);\n}\n' }
pow-with-constants.js:SyntaxError: Unexpected token *
function exponentIsZero(x) {
    return x ** 0;
}
noInline(exponentIsZero);

function testExponentIsZero() {
    for (var i = 0; i < 10000; ++i) {
        var result = exponentIsZero(5);
        if (result !== 1)
            throw "Error: zeroExponent(5) should be 1, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = exponentIsZero(5.5);
        if (result !== 1)
            throw "Error: zeroExponent(5.5) should be 1, was = " + result;
    }
}
testExponentIsZero();


function exponentIsOne(x) {
    return x ** 1;
}
noInline(exponentIsOne);

function testExponentIsOne() {
    for (var i = 0; i < 10000; ++i) {
        var result = exponentIsOne(5);
        if (result !== 5)
            throw "Error: exponentIsOne(5) should be 5, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = exponentIsOne(5.5);
        if (result !== 5.5)
            throw "Error: exponentIsOne(5.5) should be 5.5, was = " + result;
    }
}
testExponentIsOne();


function powUsedAsSqrt(x) {
    return x ** 0.5;
}
noInline(powUsedAsSqrt);

function testPowUsedAsSqrt() {
    for (let i = 0; i < 1e4; ++i) {
        let result = powUsedAsSqrt(4);
        if (result !== Math.sqrt(4))
            throw "Error: powUsedAsSqrt(4) should be 2, was = " + result;
        result = powUsedAsSqrt(4.4);
        if (result !== Math.sqrt(4.4))
            throw "Error: powUsedAsSqrt(4) should be " + Math.sqrt(4.4) + ", was = " + result;
        if (powUsedAsSqrt(Infinity) !== Infinity)
            throw "Failed powUsedAsSqrt(Infinity)";
        if (powUsedAsSqrt(-Infinity) !== Infinity)
            throw "Failed powUsedAsSqrt(-Infinity)";
        let nanResult = powUsedAsSqrt(NaN)
        if (nanResult === nanResult)
            throw "Failed powUsedAsSqrt(NaN)";
        let zeroResult = powUsedAsSqrt(0.)
        if (zeroResult || (1 / zeroResult) !== Infinity)
            throw "Failed powUsedAsSqrt(0.)";
        let negativeZeroResult = powUsedAsSqrt(-0)
        if (negativeZeroResult || (1 / negativeZeroResult) !== Infinity)
            throw "Failed powUsedAsSqrt(-0)";
    }
}
testPowUsedAsSqrt();

function powUsedAsOneOverSqrt(x) {
    return x ** -0.5;
}
noInline(powUsedAsOneOverSqrt);

function testPowUsedAsOneOverSqrt() {
    for (let i = 0; i < 1e4; ++i) {
        let result = powUsedAsOneOverSqrt(4);
        if (result !== 0.5)
            throw "Error: powUsedAsOneOverSqrt(4) should be 0.5, was = " + result;
        result = powUsedAsOneOverSqrt(4.4);
        if (result !== 1/Math.sqrt(4.4))
            throw "Error: powUsedAsOneOverSqrt(4) should be " + 1/Math.sqrt(4.4) + ", was = " + result;
        if (powUsedAsOneOverSqrt(Infinity) !== 0)
            throw "Failed powUsedAsOneOverSqrt(Infinity)";
        if (powUsedAsOneOverSqrt(-Infinity) !== 0)
            throw "Failed powUsedAsOneOverSqrt(-Infinity)";
        let nanResult = powUsedAsOneOverSqrt(NaN)
        if (nanResult === nanResult)
            throw "Failed powUsedAsOneOverSqrt(NaN)";
        if (powUsedAsOneOverSqrt(0) !== Infinity)
            throw "Failed powUsedAsOneOverSqrt(0)";
        if (powUsedAsOneOverSqrt(-0.) !== Infinity)
            throw "Failed powUsedAsOneOverSqrt(-0.)";
    }
}
testPowUsedAsOneOverSqrt();

function powUsedAsSquare(x) {
    return x ** 2;
}
noInline(powUsedAsSquare);

function testPowUsedAsSquare() {
    for (let i = 0; i < 1e4; ++i) {
        let result = powUsedAsSquare(2);
        if (result !== 4)
            throw "Error: powUsedAsSquare(4) should be 2, was = " + result;
        result = powUsedAsSquare(4.4);
        if (result !== 19.360000000000003)
            throw "Error: powUsedAsSquare(4) should be " + 19.360000000000003 + ", was = " + result;
        result = powUsedAsSquare(Math.PI);
        if (result !== 9.869604401089358)
            throw "Error: powUsedAsSquare(4) should be " + 9.869604401089358 + ", was = " + result;
        if (powUsedAsSquare(Infinity) !== Infinity)
            throw "Failed powUsedAsSquare(Infinity)";
        if (powUsedAsSquare(-Infinity) !== Infinity)
            throw "Failed powUsedAsSquare(-Infinity)";
        let nanResult = powUsedAsSquare(NaN)
        if (nanResult === nanResult)
            throw "Failed powUsedAsSquare(NaN)";
        let zeroResult = powUsedAsSquare(0.)
        if (zeroResult || (1 / zeroResult) !== Infinity)
            throw "Failed powUsedAsSquare(0.)";
        let negativeZeroResult = powUsedAsSquare(-0)
        if (negativeZeroResult || (1 / negativeZeroResult) !== Infinity)
            throw "Failed powUsedAsSquare(-0)";
    }
}
testPowUsedAsSquare();

function intIntConstantsSmallNumbers() {
    return 42 ** 3;
}
function intIntConstantsLargeNumbers() {
    // The result does not fit in a integer.
    return 42 ** 42;
}
function intIntSmallConstants() {
    return 42 ** 3;
}
function intDoubleConstants() {
    return 14 ** 42.5;
}
function doubleDoubleConstants() {
    return 13.5 ** 42.5;
}
function doubleIntConstants() {
    return 13.5 ** 52;
}
noInline(intIntConstantsSmallNumbers);
noInline(intIntConstantsLargeNumbers);
noInline(intDoubleConstants);
noInline(doubleDoubleConstants);
noInline(doubleIntConstants);

function testBaseAndExponentConstantLiterals()
{
    for (var i = 0; i < 10000; ++i) {
        var result = intIntConstantsSmallNumbers();
        if (result !== 74088)
            throw "Error: intIntConstantsSmallNumbers() should be 74088, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = intIntConstantsLargeNumbers();
        if (result !== 1.5013093754529656e+68)
            throw "Error: intIntConstantsLargeNumbers() should be 1.5013093754529656e+68, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = intDoubleConstants();
        if (result !== 5.1338303882015765e+48)
            throw "Error: intDoubleConstants() should be 5.1338303882015765e+48, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = doubleDoubleConstants();
        if (result !== 1.0944228729647829e+48)
            throw "Error: doubleDoubleConstants() should be 1.0944228729647829e+48, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = doubleIntConstants();
        if (result !== 5.989022735311158e+58)
            throw "Error: doubleIntConstants() should be 5.989022735311158e+58, was = " + result;
    }
}
testBaseAndExponentConstantLiterals();


function exponentIsIntegerConstant(x) {
    return x ** 42;
}
noInline(exponentIsIntegerConstant);

function testExponentIsIntegerConstant() {
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsIntegerConstant(2);
        if (result !== 4398046511104)
            throw "Error: exponentIsIntegerConstant(2) should be 4398046511104, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsIntegerConstant(5);
        if (result !== 2.2737367544323207e+29)
            throw "Error: exponentIsIntegerConstant(5) should be 2.2737367544323207e+29, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsIntegerConstant(2.1);
        if (result !== 34135823067412.42)
            throw "Error: exponentIsIntegerConstant(2.1) should be 34135823067412.42, was = " + result;
    }
}
testExponentIsIntegerConstant();


function exponentIsDoubleConstant(x) {
    return x ** 42.5;
}
noInline(exponentIsDoubleConstant);

function testExponentIsDoubleConstant() {
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsDoubleConstant(2);
        if (result !== 6219777023950.95)
            throw "Error: exponentIsDoubleConstant(2) should be 6219777023950.95, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsDoubleConstant(5);
        if (result !== 5.084229945850415e+29)
            throw "Error: exponentIsDoubleConstant(5) should be 5.084229945850415e+29, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsDoubleConstant(2.1);
        if (result !== 49467507261113.805)
            throw "Error: exponentIsDoubleConstant(2.1) should be 49467507261113.805, was = " + result;
    }
}
testExponentIsDoubleConstant();


function exponentIsInfinityConstant(x) {
    return x ** Infinity;
}
noInline(exponentIsInfinityConstant);

function testExponentIsInfinityConstant() {
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsInfinityConstant(2);
        if (result !== Infinity)
            throw "Error: exponentIsInfinityConstant(2) should be Infinity, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsInfinityConstant(5);
        if (result !== Infinity)
            throw "Error: exponentIsInfinityConstant(5) should be Infinity, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsInfinityConstant(2.1);
        if (result !== Infinity)
            throw "Error: exponentIsInfinityConstant(2.1) should be Infinity, was = " + result;
    }
}
testExponentIsInfinityConstant();


function exponentIsNegativeInfinityConstant(x) {
    return x ** -Infinity;
}
noInline(exponentIsNegativeInfinityConstant);

function testExponentIsNegativeInfinityConstant() {
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsNegativeInfinityConstant(2);
        if (result !== 0)
            throw "Error: exponentIsNegativeInfinityConstant(2) should be zero, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsNegativeInfinityConstant(5);
        if (result !== 0)
            throw "Error: exponentIsNegativeInfinityConstant(5) should be zero, was = " + result;
    }
    for (var i = 0; i < 1000; ++i) {
        var result = exponentIsNegativeInfinityConstant(2.1);
        if (result !== 0)
            throw "Error: exponentIsNegativeInfinityConstant(2.1) should be zero, was = " + result;
    }
}
testExponentIsNegativeInfinityConstant();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return x ** 0;',
       message: 'Parsing error: Unexpected token *',
       line: 2,
       column: 15 } ],
  output: 'function exponentIsZero(x) {\n    return x ** 0;\n}\nnoInline(exponentIsZero);\n\nfunction testExponentIsZero() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = exponentIsZero(5);\n        if (result !== 1)\n            throw "Error: zeroExponent(5) should be 1, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = exponentIsZero(5.5);\n        if (result !== 1)\n            throw "Error: zeroExponent(5.5) should be 1, was = " + result;\n    }\n}\ntestExponentIsZero();\n\n\nfunction exponentIsOne(x) {\n    return x ** 1;\n}\nnoInline(exponentIsOne);\n\nfunction testExponentIsOne() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = exponentIsOne(5);\n        if (result !== 5)\n            throw "Error: exponentIsOne(5) should be 5, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = exponentIsOne(5.5);\n        if (result !== 5.5)\n            throw "Error: exponentIsOne(5.5) should be 5.5, was = " + result;\n    }\n}\ntestExponentIsOne();\n\n\nfunction powUsedAsSqrt(x) {\n    return x ** 0.5;\n}\nnoInline(powUsedAsSqrt);\n\nfunction testPowUsedAsSqrt() {\n    for (let i = 0; i < 1e4; ++i) {\n        let result = powUsedAsSqrt(4);\n        if (result !== Math.sqrt(4))\n            throw "Error: powUsedAsSqrt(4) should be 2, was = " + result;\n        result = powUsedAsSqrt(4.4);\n        if (result !== Math.sqrt(4.4))\n            throw "Error: powUsedAsSqrt(4) should be " + Math.sqrt(4.4) + ", was = " + result;\n        if (powUsedAsSqrt(Infinity) !== Infinity)\n            throw "Failed powUsedAsSqrt(Infinity)";\n        if (powUsedAsSqrt(-Infinity) !== Infinity)\n            throw "Failed powUsedAsSqrt(-Infinity)";\n        let nanResult = powUsedAsSqrt(NaN)\n        if (nanResult === nanResult)\n            throw "Failed powUsedAsSqrt(NaN)";\n        let zeroResult = powUsedAsSqrt(0.)\n        if (zeroResult || (1 / zeroResult) !== Infinity)\n            throw "Failed powUsedAsSqrt(0.)";\n        let negativeZeroResult = powUsedAsSqrt(-0)\n        if (negativeZeroResult || (1 / negativeZeroResult) !== Infinity)\n            throw "Failed powUsedAsSqrt(-0)";\n    }\n}\ntestPowUsedAsSqrt();\n\nfunction powUsedAsOneOverSqrt(x) {\n    return x ** -0.5;\n}\nnoInline(powUsedAsOneOverSqrt);\n\nfunction testPowUsedAsOneOverSqrt() {\n    for (let i = 0; i < 1e4; ++i) {\n        let result = powUsedAsOneOverSqrt(4);\n        if (result !== 0.5)\n            throw "Error: powUsedAsOneOverSqrt(4) should be 0.5, was = " + result;\n        result = powUsedAsOneOverSqrt(4.4);\n        if (result !== 1/Math.sqrt(4.4))\n            throw "Error: powUsedAsOneOverSqrt(4) should be " + 1/Math.sqrt(4.4) + ", was = " + result;\n        if (powUsedAsOneOverSqrt(Infinity) !== 0)\n            throw "Failed powUsedAsOneOverSqrt(Infinity)";\n        if (powUsedAsOneOverSqrt(-Infinity) !== 0)\n            throw "Failed powUsedAsOneOverSqrt(-Infinity)";\n        let nanResult = powUsedAsOneOverSqrt(NaN)\n        if (nanResult === nanResult)\n            throw "Failed powUsedAsOneOverSqrt(NaN)";\n        if (powUsedAsOneOverSqrt(0) !== Infinity)\n            throw "Failed powUsedAsOneOverSqrt(0)";\n        if (powUsedAsOneOverSqrt(-0.) !== Infinity)\n            throw "Failed powUsedAsOneOverSqrt(-0.)";\n    }\n}\ntestPowUsedAsOneOverSqrt();\n\nfunction powUsedAsSquare(x) {\n    return x ** 2;\n}\nnoInline(powUsedAsSquare);\n\nfunction testPowUsedAsSquare() {\n    for (let i = 0; i < 1e4; ++i) {\n        let result = powUsedAsSquare(2);\n        if (result !== 4)\n            throw "Error: powUsedAsSquare(4) should be 2, was = " + result;\n        result = powUsedAsSquare(4.4);\n        if (result !== 19.360000000000003)\n            throw "Error: powUsedAsSquare(4) should be " + 19.360000000000003 + ", was = " + result;\n        result = powUsedAsSquare(Math.PI);\n        if (result !== 9.869604401089358)\n            throw "Error: powUsedAsSquare(4) should be " + 9.869604401089358 + ", was = " + result;\n        if (powUsedAsSquare(Infinity) !== Infinity)\n            throw "Failed powUsedAsSquare(Infinity)";\n        if (powUsedAsSquare(-Infinity) !== Infinity)\n            throw "Failed powUsedAsSquare(-Infinity)";\n        let nanResult = powUsedAsSquare(NaN)\n        if (nanResult === nanResult)\n            throw "Failed powUsedAsSquare(NaN)";\n        let zeroResult = powUsedAsSquare(0.)\n        if (zeroResult || (1 / zeroResult) !== Infinity)\n            throw "Failed powUsedAsSquare(0.)";\n        let negativeZeroResult = powUsedAsSquare(-0)\n        if (negativeZeroResult || (1 / negativeZeroResult) !== Infinity)\n            throw "Failed powUsedAsSquare(-0)";\n    }\n}\ntestPowUsedAsSquare();\n\nfunction intIntConstantsSmallNumbers() {\n    return 42 ** 3;\n}\nfunction intIntConstantsLargeNumbers() {\n    // The result does not fit in a integer.\n    return 42 ** 42;\n}\nfunction intIntSmallConstants() {\n    return 42 ** 3;\n}\nfunction intDoubleConstants() {\n    return 14 ** 42.5;\n}\nfunction doubleDoubleConstants() {\n    return 13.5 ** 42.5;\n}\nfunction doubleIntConstants() {\n    return 13.5 ** 52;\n}\nnoInline(intIntConstantsSmallNumbers);\nnoInline(intIntConstantsLargeNumbers);\nnoInline(intDoubleConstants);\nnoInline(doubleDoubleConstants);\nnoInline(doubleIntConstants);\n\nfunction testBaseAndExponentConstantLiterals()\n{\n    for (var i = 0; i < 10000; ++i) {\n        var result = intIntConstantsSmallNumbers();\n        if (result !== 74088)\n            throw "Error: intIntConstantsSmallNumbers() should be 74088, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = intIntConstantsLargeNumbers();\n        if (result !== 1.5013093754529656e+68)\n            throw "Error: intIntConstantsLargeNumbers() should be 1.5013093754529656e+68, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = intDoubleConstants();\n        if (result !== 5.1338303882015765e+48)\n            throw "Error: intDoubleConstants() should be 5.1338303882015765e+48, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = doubleDoubleConstants();\n        if (result !== 1.0944228729647829e+48)\n            throw "Error: doubleDoubleConstants() should be 1.0944228729647829e+48, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = doubleIntConstants();\n        if (result !== 5.989022735311158e+58)\n            throw "Error: doubleIntConstants() should be 5.989022735311158e+58, was = " + result;\n    }\n}\ntestBaseAndExponentConstantLiterals();\n\n\nfunction exponentIsIntegerConstant(x) {\n    return x ** 42;\n}\nnoInline(exponentIsIntegerConstant);\n\nfunction testExponentIsIntegerConstant() {\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsIntegerConstant(2);\n        if (result !== 4398046511104)\n            throw "Error: exponentIsIntegerConstant(2) should be 4398046511104, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsIntegerConstant(5);\n        if (result !== 2.2737367544323207e+29)\n            throw "Error: exponentIsIntegerConstant(5) should be 2.2737367544323207e+29, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsIntegerConstant(2.1);\n        if (result !== 34135823067412.42)\n            throw "Error: exponentIsIntegerConstant(2.1) should be 34135823067412.42, was = " + result;\n    }\n}\ntestExponentIsIntegerConstant();\n\n\nfunction exponentIsDoubleConstant(x) {\n    return x ** 42.5;\n}\nnoInline(exponentIsDoubleConstant);\n\nfunction testExponentIsDoubleConstant() {\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsDoubleConstant(2);\n        if (result !== 6219777023950.95)\n            throw "Error: exponentIsDoubleConstant(2) should be 6219777023950.95, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsDoubleConstant(5);\n        if (result !== 5.084229945850415e+29)\n            throw "Error: exponentIsDoubleConstant(5) should be 5.084229945850415e+29, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsDoubleConstant(2.1);\n        if (result !== 49467507261113.805)\n            throw "Error: exponentIsDoubleConstant(2.1) should be 49467507261113.805, was = " + result;\n    }\n}\ntestExponentIsDoubleConstant();\n\n\nfunction exponentIsInfinityConstant(x) {\n    return x ** Infinity;\n}\nnoInline(exponentIsInfinityConstant);\n\nfunction testExponentIsInfinityConstant() {\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsInfinityConstant(2);\n        if (result !== Infinity)\n            throw "Error: exponentIsInfinityConstant(2) should be Infinity, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsInfinityConstant(5);\n        if (result !== Infinity)\n            throw "Error: exponentIsInfinityConstant(5) should be Infinity, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsInfinityConstant(2.1);\n        if (result !== Infinity)\n            throw "Error: exponentIsInfinityConstant(2.1) should be Infinity, was = " + result;\n    }\n}\ntestExponentIsInfinityConstant();\n\n\nfunction exponentIsNegativeInfinityConstant(x) {\n    return x ** -Infinity;\n}\nnoInline(exponentIsNegativeInfinityConstant);\n\nfunction testExponentIsNegativeInfinityConstant() {\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsNegativeInfinityConstant(2);\n        if (result !== 0)\n            throw "Error: exponentIsNegativeInfinityConstant(2) should be zero, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsNegativeInfinityConstant(5);\n        if (result !== 0)\n            throw "Error: exponentIsNegativeInfinityConstant(5) should be zero, was = " + result;\n    }\n    for (var i = 0; i < 1000; ++i) {\n        var result = exponentIsNegativeInfinityConstant(2.1);\n        if (result !== 0)\n            throw "Error: exponentIsNegativeInfinityConstant(2.1) should be zero, was = " + result;\n    }\n}\ntestExponentIsNegativeInfinityConstant();\n' }
pow-with-never-NaN-exponent.js:SyntaxError: Unexpected token *
function exponentIsNonNanDouble1(x, doubleArrayIndex) {
    var doubleArray = [4.4];
    return x ** doubleArray[doubleArrayIndex];
}
noInline(exponentIsNonNanDouble1);

function exponentIsNonNanDouble2(x, doubleArray) {
    return x ** doubleArray[0];
}
noInline(exponentIsNonNanDouble2);

function testExponentIsDoubleConstant() {
    for (var i = 0; i < 10000; ++i) {
        var result = exponentIsNonNanDouble1(2, 0);
        if (result !== 21.112126572366314)
            throw "Error: exponentIsNonNanDouble1(2, 0) should be 21.112126572366314, was = " + result;
    }
    for (var i = 0; i < 10000; ++i) {
        var result = exponentIsNonNanDouble2(3, [-1.5]);
        if (result !== 0.19245008972987526)
            throw "Error: exponentIsNonNanDouble2(3, [-1.5]) should be 0.19245008972987526, was = " + result;
    }
}
testExponentIsDoubleConstant();

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return x ** doubleArray[doubleArrayIndex];',
       message: 'Parsing error: Unexpected token *',
       line: 3,
       column: 15 } ],
  output: 'function exponentIsNonNanDouble1(x, doubleArrayIndex) {\n    var doubleArray = [4.4];\n    return x ** doubleArray[doubleArrayIndex];\n}\nnoInline(exponentIsNonNanDouble1);\n\nfunction exponentIsNonNanDouble2(x, doubleArray) {\n    return x ** doubleArray[0];\n}\nnoInline(exponentIsNonNanDouble2);\n\nfunction testExponentIsDoubleConstant() {\n    for (var i = 0; i < 10000; ++i) {\n        var result = exponentIsNonNanDouble1(2, 0);\n        if (result !== 21.112126572366314)\n            throw "Error: exponentIsNonNanDouble1(2, 0) should be 21.112126572366314, was = " + result;\n    }\n    for (var i = 0; i < 10000; ++i) {\n        var result = exponentIsNonNanDouble2(3, [-1.5]);\n        if (result !== 0.19245008972987526)\n            throw "Error: exponentIsNonNanDouble2(3, [-1.5]) should be 0.19245008972987526, was = " + result;\n    }\n}\ntestExponentIsDoubleConstant();\n' }
re-execute-error-module.js:SyntaxError: Unexpected token function
var abort = $vm.abort;

function shouldBe(actual, expected)
{
    if (actual !== expected)
        throw new Error(`bad value: ${String(actual)}`);
}

(async function () {
    {
        let errorMessage = null;
        try {
            await import("./resources/error-module.js");
        } catch (error) {
            errorMessage = String(error);
        }
        shouldBe(errorMessage, `SyntaxError: Importing binding name 'x' is not found.`);
    }
    {
        let errorMessage = null;
        try {
            await import("./resources/error-module.js");
        } catch (error) {
            errorMessage = String(error);
        }
        shouldBe(errorMessage, `SyntaxError: Importing binding name 'x' is not found.`);
    }
}()).catch(abort);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '        throw new Error(`bad value: ${String(actual)}`);',
       message: 'Parsing error: Unexpected character \'`\'',
       line: 6,
       column: 25 } ],
  output: 'var abort = $vm.abort;\n\nfunction shouldBe(actual, expected)\n{\n    if (actual !== expected)\n        throw new Error(`bad value: ${String(actual)}`);\n}\n\n(async function () {\n    {\n        let errorMessage = null;\n        try {\n            await import("./resources/error-module.js");\n        } catch (error) {\n            errorMessage = String(error);\n        }\n        shouldBe(errorMessage, `SyntaxError: Importing binding name \'x\' is not found.`);\n    }\n    {\n        let errorMessage = null;\n        try {\n            await import("./resources/error-module.js");\n        } catch (error) {\n            errorMessage = String(error);\n        }\n        shouldBe(errorMessage, `SyntaxError: Importing binding name \'x\' is not found.`);\n    }\n}()).catch(abort);\n' }
regexp-syntax-error-invalid-flags.js:SyntaxError: Invalid regular expression flag
function shouldThrow(func, errorMessage) {
    var errorThrown = false;
    var error = null;
    try {
        func();
    } catch (e) {
        errorThrown = true;
        error = e;
    }
    if (!errorThrown)
        throw new Error('not thrown');
    if (String(error) !== errorMessage)
        throw new Error(`bad error: ${String(error)}`);
}

function test()
{
    return /Hello/cocoa;
}
noInline(test);

for (var i = 0; i < 1e4; ++i)
    shouldThrow(test, `SyntaxError: Invalid regular expression: invalid flags`);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '        throw new Error(`bad error: ${String(error)}`);',
       message: 'Parsing error: Unexpected character \'`\'',
       line: 13,
       column: 25 } ],
  output: 'function shouldThrow(func, errorMessage) {\n    var errorThrown = false;\n    var error = null;\n    try {\n        func();\n    } catch (e) {\n        errorThrown = true;\n        error = e;\n    }\n    if (!errorThrown)\n        throw new Error(\'not thrown\');\n    if (String(error) !== errorMessage)\n        throw new Error(`bad error: ${String(error)}`);\n}\n\nfunction test()\n{\n    return /Hello/cocoa;\n}\nnoInline(test);\n\nfor (var i = 0; i < 1e4; ++i)\n    shouldThrow(test, `SyntaxError: Invalid regular expression: invalid flags`);\n' }
regress-161995.js:SyntaxError: Invalid regular expression flag
// Regression test for 161995.

function testStatic()
{
    return /a/Z;
}

try {
    testStatic();
    throw "Expected a SyntaxEerror for bad RegExp flags, but didn't get one.";
} catch(e) {
    if (e != "SyntaxError: Invalid regular expression: invalid flags")
        throw "Incorrect exception for bad RegExp flags.  Got: " + e;
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    return /a/Z;',
       message: 'Parsing error: Invalid regular expression flag',
       line: 5,
       column: 13 } ],
  output: '// Regression test for 161995.\n\nfunction testStatic()\n{\n    return /a/Z;\n}\n\ntry {\n    testStatic();\n    throw "Expected a SyntaxEerror for bad RegExp flags, but didn\'t get one.";\n} catch(e) {\n    if (e != "SyntaxError: Invalid regular expression: invalid flags")\n        throw "Incorrect exception for bad RegExp flags.  Got: " + e;\n}\n' }
regress-170732.js:SyntaxError: Unexpected token function
//@ runDefault("--exception=SyntaxError")
async function f() {
    await async()=>{}
}

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'async function f() {',
       message: 'Parsing error: Unexpected token function',
       line: 2,
       column: 7 } ],
  output: '//@ runDefault("--exception=SyntaxError")\nasync function f() {\n    await async()=>{}\n}\n' }
rest-parameter-is-destructuring.js:SyntaxError: Unexpected token [
function assert(b) {
    if (!b)
        throw new Error("Bad assertion")
}
noInline(assert);

function test(f, count = 1000) {
    for (let i = 0; i < count; i++)
        f();
}

function foo(a = function() { return c; }, ...[b = function() { return a; }, ...c]) {
    assert(b()() === c);
    assert(a() === c);
}


test(function() {
    foo(undefined, undefined, {});
});

function bar(a, ...{c}) {
    return c;    
}
test(function() {
    assert(bar(10, 20, 30) === undefined);
});

function baz(...[{b}, {b: c}, ...d]) {
    return [b, c, d];
}
test(function() {
    let o = {};

    let result = baz({b: 20}, {b: 30}, 40, o);
    assert(result.length === 3);
    assert(result[0] === 20);
    assert(result[1] === 30);
    assert(result[2].length === 2);
    assert(result[2][0] === 40);
    assert(result[2][1] === o);
});

function jaz(...[...[...c]]) {
    return c;
}
test(function() {
    let result = jaz(10, 20);
    assert(result.length === 2);
    assert(result[0] === 10);
    assert(result[1] === 20);
});

let raz = (a, ...[b, ...c]) => {
    return [b, ...c];
};
test(function() {
    let result = raz(10, 20, 30, 40);
    assert(result.length === 3);
    assert(result[0] === 20);
    assert(result[1] === 30);
    assert(result[2] === 40);
});

Array.prototype.c = 500;
test(function() {
    assert(bar(10, 20, 30) === 500);
});

raz = (a, ...[b = function() { return c; }, ...c]) => {
    return b();
};
test(function() {
    let result = raz(undefined, undefined, 20, 30);
    assert(result.length === 2);
    assert(result[0] === 20);
    assert(result[1] === 30);
});

raz = (a, ...[b = function() { return c; }, d = b(), ...c]) => { };
test(function() {
    let threw = false;
    try {
        raz(undefined, undefined, undefined, undefined);
    } catch(e) {
        threw = e instanceof ReferenceError; }
    assert(threw);
});

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function test(f, count = 1000) {',
       message: 'Parsing error: Unexpected token =',
       line: 7,
       column: 24 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad assertion")\n}\nnoInline(assert);\n\nfunction test(f, count = 1000) {\n    for (let i = 0; i < count; i++)\n        f();\n}\n\nfunction foo(a = function() { return c; }, ...[b = function() { return a; }, ...c]) {\n    assert(b()() === c);\n    assert(a() === c);\n}\n\n\ntest(function() {\n    foo(undefined, undefined, {});\n});\n\nfunction bar(a, ...{c}) {\n    return c;    \n}\ntest(function() {\n    assert(bar(10, 20, 30) === undefined);\n});\n\nfunction baz(...[{b}, {b: c}, ...d]) {\n    return [b, c, d];\n}\ntest(function() {\n    let o = {};\n\n    let result = baz({b: 20}, {b: 30}, 40, o);\n    assert(result.length === 3);\n    assert(result[0] === 20);\n    assert(result[1] === 30);\n    assert(result[2].length === 2);\n    assert(result[2][0] === 40);\n    assert(result[2][1] === o);\n});\n\nfunction jaz(...[...[...c]]) {\n    return c;\n}\ntest(function() {\n    let result = jaz(10, 20);\n    assert(result.length === 2);\n    assert(result[0] === 10);\n    assert(result[1] === 20);\n});\n\nlet raz = (a, ...[b, ...c]) => {\n    return [b, ...c];\n};\ntest(function() {\n    let result = raz(10, 20, 30, 40);\n    assert(result.length === 3);\n    assert(result[0] === 20);\n    assert(result[1] === 30);\n    assert(result[2] === 40);\n});\n\nArray.prototype.c = 500;\ntest(function() {\n    assert(bar(10, 20, 30) === 500);\n});\n\nraz = (a, ...[b = function() { return c; }, ...c]) => {\n    return b();\n};\ntest(function() {\n    let result = raz(undefined, undefined, 20, 30);\n    assert(result.length === 2);\n    assert(result[0] === 20);\n    assert(result[1] === 30);\n});\n\nraz = (a, ...[b = function() { return c; }, d = b(), ...c]) => { };\ntest(function() {\n    let threw = false;\n    try {\n        raz(undefined, undefined, undefined, undefined);\n    } catch(e) {\n        threw = e instanceof ReferenceError; }\n    assert(threw);\n});\n' }
sloppy-mode-function-hoisting.js:SyntaxError: Identifier 'a' has already been declared
function assert(b) {
    if (!b)
        throw new Error("Bad assertion.");
}

function test(f, ...args) {
    for (let i = 0; i < 500; i++)
        f(...args);
}

function falsey() { return false; }
noInline(falsey);
function truthy() { return true; }
noInline(truthy);

test(function() {
    var a;
    assert(a === undefined);
    {
        function a() { return 20; }
    }
    assert(a() === 20);
});

test(function(a) {
    var a;
    assert(a === undefined);
    {
        function a() { return 20; }
    }
    assert(a === undefined);
});

test(function({a}) {
    var a;
    assert(a === undefined);
    {
        function a() { return 20; }
    }
    assert(a === undefined);
}, {});

test(function() {
    let a;
    assert(a === undefined);
    {
        function a() { return 20; }
    }
    assert(a === undefined);
});

test(function() {
    assert(a === undefined);
    function foo() { return a(); }
    {
        function a() { return 20; }
    }
    assert(a() === 20);
    assert(foo() === 20);
});

test(function(a = 30) {
    assert(a === 30);
    function foo() { return a; }
    assert(foo() === 30);
    {
        function a() { return 20; }
        assert(a() === 20);
        assert(foo() === 30);
    }
    assert(a === 30);
    assert(foo() === 30);
});

test(function() {
    let x = 15;
    assert(x === 15);
    assert(a === undefined);
    {
        let x = {x: 20};
        function a() { return x; }
        assert(a() === x);
        assert(a().x === 20);
    }
    assert(a().x === 20);
    assert(x === 15);
});

test(function() {
    let x = 15;
    assert(x === 15);
    assert(a === undefined);
    let f;
    {
        let x = {x: 20};
        assert(a() === x);
        assert(a().x === 20);

        function a() { throw new Error; }
        function a() { return x; }
        f = a;
    }
    assert(a().x === 20);
    assert(x === 15);
    assert(f().x === 20);
});

test(function() {
    let x = 15;
    let f;
    assert(x === 15);
    assert(a === undefined);
    assert(f === undefined);
    {
        function a() { return f; }
        f = a;
    }
    assert(x === 15);
    assert(f() === f);
});

test(function() {
    function a() { return 20; }
    let f = a;
    assert(a() === 20);
    {
        function a() { return 25; }
        assert(a() === 25);
    }
    assert(f() === 20);
    assert(a() === 25);
});

test(function() {
    assert(f === undefined);
    for (let i = 0; i < 10; i++) {
        function f() { return i; }
        assert(f() === i);
    }
    assert(f() === 9);
});

test(function() {
    assert(f === undefined);
    let nums = [0, 1, 2, 3];
    for (let i of nums) {
        function f() { return i; }
        assert(f() === i);
    }
    assert(f() === 3);
});

test(function() {
    assert(f === undefined);
    let obj = {0:0, 1:1, 2:2, 3:3};
    for (let i in obj) {
        function f() { return i; }
        assert(f() === i);
    }
    assert(f() === "3");
});

test(function() {
    assert(f === undefined);
    let nums = [0, 1, 2, 3];
    let funcs = []
    for (let i of nums) {
        function f() { return i; }
        funcs.push(f);
        assert(f() === i);
    }
    assert(f() === 3);
    assert(funcs.length === nums.length);
    for (let i = 0; i < funcs.length; i++) {
        assert(funcs[i]() === nums[i]);
    }
});

test(function() {
    assert(f === undefined);
    try {
        throw new Error("foo");
    } catch(e) {
        function f() { return 20; }
    }
    assert(f() === 20);
});

test(function() {
    assert(f === undefined);
    try {
        ;
    } catch(e) {
        function f() { return 20; }
    }
    assert(f === undefined);
});

test(function() {
    assert(foo === undefined);
    if (falsey()) {
        function foo() { return 20; }
    }
    assert(foo === undefined);
});

test(function() {
    assert(foo === undefined);
    if (falsey())
        function foo() { return 20; }
    assert(foo === undefined);
});

test(function() {
    assert(foo === undefined);
    if (truthy()) {
        function foo() { return 20; }
    }
    assert(foo() === 20);
});

test(function() {
    assert(foo === undefined);
    while (truthy()) {
        assert(foo() === 20);
        break;

        function foo() { return 20; }
    }
    assert(foo === undefined);
});

test(function() {
    assert(foo === undefined);
    while (truthy()) {
        assert(foo() === 20);
        function foo() { return 20; }
        break;
    }
    assert(foo() === 20);
});

test(function() {
    function bar() { return foo; }
    assert(foo === undefined);
    assert(bar() === undefined);
    while (truthy()) {
        break;

        function foo() { return 20; }
    }
    assert(foo === undefined);
    assert(bar() === undefined);
});

test(function() {
    function bar() { return foo; }
    assert(foo === undefined);
    assert(bar() === undefined);
    while (truthy()) {
        function foo() { return 20; }
        break;
    }
    assert(foo() === 20);
    assert(bar()() === 20);
});

test(function() {
    function bar() { return foo; }
    assert(foo === undefined);
    assert(bar() === undefined);
    while (falsey()) {
        function foo() { return 20; }
    }
    assert(foo === undefined);
    assert(bar() === undefined);
});

test(function() {
    var a = "a";
    assert(a === "a");
    {
        let b = 1;
        assert(a === "a");
        {
            let c = 2;
            assert(a === "a");
            {
                let d = 3;
                function a() { return b + c+ d; }
                assert(a() === 6);
            }
            assert(a() === 6);
        }
        assert(a() === 6);
    }
    assert(a() === 6);
});

test(function() {
    assert(foo === undefined);
    switch(1) {
    case 0:
        function foo() { return 20; }
        break;
    case 1:
        assert(foo() === 20);
        break;
    }
    assert(foo === undefined);
});

test(function() {
    assert(foo === undefined);
    switch(1) {
    case 1:
        assert(foo() === 20);
    case 0:
        function foo() { return 20; }
        break;
    }
    assert(foo() === 20);
});

test(function() {
    assert(foo === undefined);
    switch(1) {
    case 0:{
        function foo() { return 20; }
        break;
    }
    }
    assert(foo === undefined);
});

test(function() {
    assert(foo === undefined);
    switch(0) {
    case 0:{
        function foo() { return 20; }
        break;
    }
    }
    assert(foo() === 20);
});

test(function() {
    assert(foo === undefined);
    switch(0) {
    case 0:
        function foo() { return bar; }
        break;
    case 1:
        let bar = 20;
        break;
    }

    let threw = false;
    try {
        foo();
    } catch (e) {
        assert(e instanceof ReferenceError);
        threw = true;
    }
    assert(threw);
});

test(function() {
    assert(foo === undefined);
    switch(0) {
    case 0:
        function foo() { return bar; }
    case 1:
        let bar = 20;
        break;
    }

    assert(foo() === 20);
});

test(function() {
    assert(foo === undefined);
    switch(1) {
    case 0:
        function foo() { return bar; }
    case 1:
        let bar = 20;
        assert(foo() === 20);
        break;
    }

    assert(foo === undefined);
});

test(function() {
    function capFoo1() { return foo; }
    assert(foo === undefined);
    assert(capFoo1() === undefined);
    switch(1) {
    case 0:
        function foo() { return bar; }
        function capFoo2() { return foo; }
    case 1:
        let bar = 20;
        assert(foo() === 20);
        assert(capFoo1() === undefined);
        assert(capFoo2() === foo);
        assert(capFoo2()() === 20);
        break;
    }

    assert(foo === undefined);
});

test(function() {
    assert(foo === undefined);
    switch(1) {
    case 1:
        let bar = 20;
        assert(foo() === 20);
    case 0:
        function foo() { return bar; }
    }

    assert(foo() === 20);
});

test(function(a) {
    assert(a === 25);
    switch(1) {
    case 0:
        function a() { return bar; }
    case 1:
        let bar = 20;
        assert(a() === 20);
        break;
    }

    assert(a === 25);
}, 25);

test(function() {
    let a = 25;
    assert(a === 25);
    switch(1) {
    case 0:
        function a() { return bar; }
    case 1:
        let bar = 20;
        assert(a() === 20);
        break;
    }

    assert(a === 25);
});

test(function() {
    const a = 25;
    assert(a === 25);
    switch(1) {
    case 0:
        function a() { return bar; }
    case 1:
        let bar = 20;
        assert(a() === 20);
        break;
    }

    assert(a === 25);
});

test(function() {
    let foo = {};
    class a { constructor() { return foo; } }
    assert(new a === foo);
    switch(1) {
    case 0:
        function a() { return bar; }
    case 1:
        let bar = 20;
        assert(a() === 20);
        break;
    }

    assert(new a === foo);
});

test(function() {
    assert(f === undefined);
    {
        if (true)
            function f() { return 20; }
        assert(f() === 20);
    }
    assert(f() === 20);
});

test(function() {
    assert(f === undefined);
    {
        if (false)
            function f() { return 20; }
        assert(f === undefined);
    }
    assert(f === undefined);
});

test(function() {
    var x;
    assert(f === undefined);
    if (true)
        if (true)
            if (true)
                function f() { return 20; }
    assert(f() === 20);
});

test(function() {
    var x;
    assert(f === undefined);
    {
        if (true)
            if (false)
                if (true)
                    function f() { return 20; }
    }
    assert(f === undefined);
});

test(function() {
    var x;
    assert(f === undefined);
    {
        while (false)
            while (false)
                if (true)
                    function f() { return 20; }
    }
    assert(f === undefined);
});

test(function() {
    assert(f === undefined);
    var f = 20;
    assert(f === 20);
    while (false)
        while (false)
            if (true)
                function f() { return 20; }
    assert(f === 20);
});

test(function() {
    assert(f === undefined);
    var f = 20;
    assert(f === 20);
    var i = 2;
    {
        while (i-- > 0)
            while (i-- > 0)
                if (true)
                    function f() { return 20; }
    }
    assert(f() === 20);
});

test(function() {
    assert(f === undefined);
    var f = 20;
    assert(f === 20);
    var i = 2;
    {
        while (i-- > 0)
            while (i-- > 0)
                if (false)
                    function f() { return 20; }
    }
    assert(f === 20);
});

test(function() {
    assert(f === undefined);
    var f = 20;
    assert(f === 20);
    var i = 2;
    {
        while (i-- > 0)
            while (i-- > 0)
                if (false)
                    function f() { return 20; }
                else
                    function f() { return 30; }
    }
    assert(f() === 30);
});

test(function() {
    assert(f === undefined);
    if (true) {
        label: function f() { return 20; }
    }
    assert(f() === 20);
});

test(function() {
    assert(f === undefined);
    if (true) {
        label: label2: label3: function f() { return 20; }
    }
    assert(f() === 20);
});

test(function() {
    assert(a === undefined);
    assert(b === undefined);
    assert(c === undefined);
    assert(d === undefined);
    assert(e === undefined);
    assert(f === undefined);
    assert(g === undefined);
    assert(h === undefined);
    assert(i === undefined);
    assert(j === undefined);
    assert(k === undefined);
    assert(l === undefined);
    assert(m === undefined);
    assert(n === undefined);
    assert(o === undefined);
    assert(p === undefined);
    assert(q === undefined);
    assert(r === undefined);
    assert(s === undefined);
    assert(t === undefined);
    assert(u === undefined);
    assert(v === undefined);
    assert(w === undefined);
    assert(x === undefined);
    assert(y === undefined);
    assert(z === undefined);
    {
        function a() { } 
        function b() { } 
        function c() { } 
        function d() { } 
        function e() { } 
        function f() { } 
        function g() { } 
        function h() { } 
        function i() { } 
        function j() { } 
        function k() { } 
        function l() { } 
        function m() { } 
        function n() { } 
        function o() { } 
        function p() { } 
        function q() { } 
        function r() { } 
        function s() { } 
        function t() { } 
        function u() { } 
        function v() { } 
        function w() { } 
        function x() { } 
        function y() { } 
        function z() { } 
    }
    assert(typeof a === "function");
    assert(typeof b === "function");
    assert(typeof c === "function");
    assert(typeof d === "function");
    assert(typeof e === "function");
    assert(typeof f === "function");
    assert(typeof g === "function");
    assert(typeof h === "function");
    assert(typeof i === "function");
    assert(typeof j === "function");
    assert(typeof k === "function");
    assert(typeof l === "function");
    assert(typeof m === "function");
    assert(typeof n === "function");
    assert(typeof o === "function");
    assert(typeof p === "function");
    assert(typeof q === "function");
    assert(typeof r === "function");
    assert(typeof s === "function");
    assert(typeof t === "function");
    assert(typeof u === "function");
    assert(typeof v === "function");
    assert(typeof w === "function");
    assert(typeof x === "function");
    assert(typeof y === "function");
    assert(typeof z === "function");
});

test(function() {
    function outer() { return f; }
    assert(outer() === undefined);
    {
        assert(outer() === undefined);
        assert(f() === 2);
        f = 100
        assert(outer() === undefined);
        function f() { return 1 }
        assert(outer() === 100);
        f = 200
        assert(outer() === 100); // 100
        function f() { return 2 }
        assert(outer() === 200);
    }
});

for (let i = 0; i < 500; i++)
    assert(foo() === 25);
function foo() { return 20; }

{
    function foo() { return 25; }
    assert(foo() === 25);
}
assert(foo() === 25);

for (let i = 0; i < 500; i++)
    assert(bar() === "bar2");
function bar() { return "bar1"; }
if (falsey()) {
    {
        if (falsey()) {
            function bar() { return "bar2"; }
        }
    }
}
assert(bar() === "bar2");

for (let i = 0; i < 500; i++)
    assert(baz() === "baz2");
function baz() { return "baz1"; }
while (falsey()) {
    if (falsey()) {
        function baz() { return "baz2"; }
    }
}
assert(baz() === "baz2");

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: 'function test(f, ...args) {',
       message: 'Parsing error: Unexpected token .',
       line: 6,
       column: 18 } ],
  output: 'function assert(b) {\n    if (!b)\n        throw new Error("Bad assertion.");\n}\n\nfunction test(f, ...args) {\n    for (let i = 0; i < 500; i++)\n        f(...args);\n}\n\nfunction falsey() { return false; }\nnoInline(falsey);\nfunction truthy() { return true; }\nnoInline(truthy);\n\ntest(function() {\n    var a;\n    assert(a === undefined);\n    {\n        function a() { return 20; }\n    }\n    assert(a() === 20);\n});\n\ntest(function(a) {\n    var a;\n    assert(a === undefined);\n    {\n        function a() { return 20; }\n    }\n    assert(a === undefined);\n});\n\ntest(function({a}) {\n    var a;\n    assert(a === undefined);\n    {\n        function a() { return 20; }\n    }\n    assert(a === undefined);\n}, {});\n\ntest(function() {\n    let a;\n    assert(a === undefined);\n    {\n        function a() { return 20; }\n    }\n    assert(a === undefined);\n});\n\ntest(function() {\n    assert(a === undefined);\n    function foo() { return a(); }\n    {\n        function a() { return 20; }\n    }\n    assert(a() === 20);\n    assert(foo() === 20);\n});\n\ntest(function(a = 30) {\n    assert(a === 30);\n    function foo() { return a; }\n    assert(foo() === 30);\n    {\n        function a() { return 20; }\n        assert(a() === 20);\n        assert(foo() === 30);\n    }\n    assert(a === 30);\n    assert(foo() === 30);\n});\n\ntest(function() {\n    let x = 15;\n    assert(x === 15);\n    assert(a === undefined);\n    {\n        let x = {x: 20};\n        function a() { return x; }\n        assert(a() === x);\n        assert(a().x === 20);\n    }\n    assert(a().x === 20);\n    assert(x === 15);\n});\n\ntest(function() {\n    let x = 15;\n    assert(x === 15);\n    assert(a === undefined);\n    let f;\n    {\n        let x = {x: 20};\n        assert(a() === x);\n        assert(a().x === 20);\n\n        function a() { throw new Error; }\n        function a() { return x; }\n        f = a;\n    }\n    assert(a().x === 20);\n    assert(x === 15);\n    assert(f().x === 20);\n});\n\ntest(function() {\n    let x = 15;\n    let f;\n    assert(x === 15);\n    assert(a === undefined);\n    assert(f === undefined);\n    {\n        function a() { return f; }\n        f = a;\n    }\n    assert(x === 15);\n    assert(f() === f);\n});\n\ntest(function() {\n    function a() { return 20; }\n    let f = a;\n    assert(a() === 20);\n    {\n        function a() { return 25; }\n        assert(a() === 25);\n    }\n    assert(f() === 20);\n    assert(a() === 25);\n});\n\ntest(function() {\n    assert(f === undefined);\n    for (let i = 0; i < 10; i++) {\n        function f() { return i; }\n        assert(f() === i);\n    }\n    assert(f() === 9);\n});\n\ntest(function() {\n    assert(f === undefined);\n    let nums = [0, 1, 2, 3];\n    for (let i of nums) {\n        function f() { return i; }\n        assert(f() === i);\n    }\n    assert(f() === 3);\n});\n\ntest(function() {\n    assert(f === undefined);\n    let obj = {0:0, 1:1, 2:2, 3:3};\n    for (let i in obj) {\n        function f() { return i; }\n        assert(f() === i);\n    }\n    assert(f() === "3");\n});\n\ntest(function() {\n    assert(f === undefined);\n    let nums = [0, 1, 2, 3];\n    let funcs = []\n    for (let i of nums) {\n        function f() { return i; }\n        funcs.push(f);\n        assert(f() === i);\n    }\n    assert(f() === 3);\n    assert(funcs.length === nums.length);\n    for (let i = 0; i < funcs.length; i++) {\n        assert(funcs[i]() === nums[i]);\n    }\n});\n\ntest(function() {\n    assert(f === undefined);\n    try {\n        throw new Error("foo");\n    } catch(e) {\n        function f() { return 20; }\n    }\n    assert(f() === 20);\n});\n\ntest(function() {\n    assert(f === undefined);\n    try {\n        ;\n    } catch(e) {\n        function f() { return 20; }\n    }\n    assert(f === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    if (falsey()) {\n        function foo() { return 20; }\n    }\n    assert(foo === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    if (falsey())\n        function foo() { return 20; }\n    assert(foo === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    if (truthy()) {\n        function foo() { return 20; }\n    }\n    assert(foo() === 20);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    while (truthy()) {\n        assert(foo() === 20);\n        break;\n\n        function foo() { return 20; }\n    }\n    assert(foo === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    while (truthy()) {\n        assert(foo() === 20);\n        function foo() { return 20; }\n        break;\n    }\n    assert(foo() === 20);\n});\n\ntest(function() {\n    function bar() { return foo; }\n    assert(foo === undefined);\n    assert(bar() === undefined);\n    while (truthy()) {\n        break;\n\n        function foo() { return 20; }\n    }\n    assert(foo === undefined);\n    assert(bar() === undefined);\n});\n\ntest(function() {\n    function bar() { return foo; }\n    assert(foo === undefined);\n    assert(bar() === undefined);\n    while (truthy()) {\n        function foo() { return 20; }\n        break;\n    }\n    assert(foo() === 20);\n    assert(bar()() === 20);\n});\n\ntest(function() {\n    function bar() { return foo; }\n    assert(foo === undefined);\n    assert(bar() === undefined);\n    while (falsey()) {\n        function foo() { return 20; }\n    }\n    assert(foo === undefined);\n    assert(bar() === undefined);\n});\n\ntest(function() {\n    var a = "a";\n    assert(a === "a");\n    {\n        let b = 1;\n        assert(a === "a");\n        {\n            let c = 2;\n            assert(a === "a");\n            {\n                let d = 3;\n                function a() { return b + c+ d; }\n                assert(a() === 6);\n            }\n            assert(a() === 6);\n        }\n        assert(a() === 6);\n    }\n    assert(a() === 6);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(1) {\n    case 0:\n        function foo() { return 20; }\n        break;\n    case 1:\n        assert(foo() === 20);\n        break;\n    }\n    assert(foo === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(1) {\n    case 1:\n        assert(foo() === 20);\n    case 0:\n        function foo() { return 20; }\n        break;\n    }\n    assert(foo() === 20);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(1) {\n    case 0:{\n        function foo() { return 20; }\n        break;\n    }\n    }\n    assert(foo === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(0) {\n    case 0:{\n        function foo() { return 20; }\n        break;\n    }\n    }\n    assert(foo() === 20);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(0) {\n    case 0:\n        function foo() { return bar; }\n        break;\n    case 1:\n        let bar = 20;\n        break;\n    }\n\n    let threw = false;\n    try {\n        foo();\n    } catch (e) {\n        assert(e instanceof ReferenceError);\n        threw = true;\n    }\n    assert(threw);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(0) {\n    case 0:\n        function foo() { return bar; }\n    case 1:\n        let bar = 20;\n        break;\n    }\n\n    assert(foo() === 20);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(1) {\n    case 0:\n        function foo() { return bar; }\n    case 1:\n        let bar = 20;\n        assert(foo() === 20);\n        break;\n    }\n\n    assert(foo === undefined);\n});\n\ntest(function() {\n    function capFoo1() { return foo; }\n    assert(foo === undefined);\n    assert(capFoo1() === undefined);\n    switch(1) {\n    case 0:\n        function foo() { return bar; }\n        function capFoo2() { return foo; }\n    case 1:\n        let bar = 20;\n        assert(foo() === 20);\n        assert(capFoo1() === undefined);\n        assert(capFoo2() === foo);\n        assert(capFoo2()() === 20);\n        break;\n    }\n\n    assert(foo === undefined);\n});\n\ntest(function() {\n    assert(foo === undefined);\n    switch(1) {\n    case 1:\n        let bar = 20;\n        assert(foo() === 20);\n    case 0:\n        function foo() { return bar; }\n    }\n\n    assert(foo() === 20);\n});\n\ntest(function(a) {\n    assert(a === 25);\n    switch(1) {\n    case 0:\n        function a() { return bar; }\n    case 1:\n        let bar = 20;\n        assert(a() === 20);\n        break;\n    }\n\n    assert(a === 25);\n}, 25);\n\ntest(function() {\n    let a = 25;\n    assert(a === 25);\n    switch(1) {\n    case 0:\n        function a() { return bar; }\n    case 1:\n        let bar = 20;\n        assert(a() === 20);\n        break;\n    }\n\n    assert(a === 25);\n});\n\ntest(function() {\n    const a = 25;\n    assert(a === 25);\n    switch(1) {\n    case 0:\n        function a() { return bar; }\n    case 1:\n        let bar = 20;\n        assert(a() === 20);\n        break;\n    }\n\n    assert(a === 25);\n});\n\ntest(function() {\n    let foo = {};\n    class a { constructor() { return foo; } }\n    assert(new a === foo);\n    switch(1) {\n    case 0:\n        function a() { return bar; }\n    case 1:\n        let bar = 20;\n        assert(a() === 20);\n        break;\n    }\n\n    assert(new a === foo);\n});\n\ntest(function() {\n    assert(f === undefined);\n    {\n        if (true)\n            function f() { return 20; }\n        assert(f() === 20);\n    }\n    assert(f() === 20);\n});\n\ntest(function() {\n    assert(f === undefined);\n    {\n        if (false)\n            function f() { return 20; }\n        assert(f === undefined);\n    }\n    assert(f === undefined);\n});\n\ntest(function() {\n    var x;\n    assert(f === undefined);\n    if (true)\n        if (true)\n            if (true)\n                function f() { return 20; }\n    assert(f() === 20);\n});\n\ntest(function() {\n    var x;\n    assert(f === undefined);\n    {\n        if (true)\n            if (false)\n                if (true)\n                    function f() { return 20; }\n    }\n    assert(f === undefined);\n});\n\ntest(function() {\n    var x;\n    assert(f === undefined);\n    {\n        while (false)\n            while (false)\n                if (true)\n                    function f() { return 20; }\n    }\n    assert(f === undefined);\n});\n\ntest(function() {\n    assert(f === undefined);\n    var f = 20;\n    assert(f === 20);\n    while (false)\n        while (false)\n            if (true)\n                function f() { return 20; }\n    assert(f === 20);\n});\n\ntest(function() {\n    assert(f === undefined);\n    var f = 20;\n    assert(f === 20);\n    var i = 2;\n    {\n        while (i-- > 0)\n            while (i-- > 0)\n                if (true)\n                    function f() { return 20; }\n    }\n    assert(f() === 20);\n});\n\ntest(function() {\n    assert(f === undefined);\n    var f = 20;\n    assert(f === 20);\n    var i = 2;\n    {\n        while (i-- > 0)\n            while (i-- > 0)\n                if (false)\n                    function f() { return 20; }\n    }\n    assert(f === 20);\n});\n\ntest(function() {\n    assert(f === undefined);\n    var f = 20;\n    assert(f === 20);\n    var i = 2;\n    {\n        while (i-- > 0)\n            while (i-- > 0)\n                if (false)\n                    function f() { return 20; }\n                else\n                    function f() { return 30; }\n    }\n    assert(f() === 30);\n});\n\ntest(function() {\n    assert(f === undefined);\n    if (true) {\n        label: function f() { return 20; }\n    }\n    assert(f() === 20);\n});\n\ntest(function() {\n    assert(f === undefined);\n    if (true) {\n        label: label2: label3: function f() { return 20; }\n    }\n    assert(f() === 20);\n});\n\ntest(function() {\n    assert(a === undefined);\n    assert(b === undefined);\n    assert(c === undefined);\n    assert(d === undefined);\n    assert(e === undefined);\n    assert(f === undefined);\n    assert(g === undefined);\n    assert(h === undefined);\n    assert(i === undefined);\n    assert(j === undefined);\n    assert(k === undefined);\n    assert(l === undefined);\n    assert(m === undefined);\n    assert(n === undefined);\n    assert(o === undefined);\n    assert(p === undefined);\n    assert(q === undefined);\n    assert(r === undefined);\n    assert(s === undefined);\n    assert(t === undefined);\n    assert(u === undefined);\n    assert(v === undefined);\n    assert(w === undefined);\n    assert(x === undefined);\n    assert(y === undefined);\n    assert(z === undefined);\n    {\n        function a() { } \n        function b() { } \n        function c() { } \n        function d() { } \n        function e() { } \n        function f() { } \n        function g() { } \n        function h() { } \n        function i() { } \n        function j() { } \n        function k() { } \n        function l() { } \n        function m() { } \n        function n() { } \n        function o() { } \n        function p() { } \n        function q() { } \n        function r() { } \n        function s() { } \n        function t() { } \n        function u() { } \n        function v() { } \n        function w() { } \n        function x() { } \n        function y() { } \n        function z() { } \n    }\n    assert(typeof a === "function");\n    assert(typeof b === "function");\n    assert(typeof c === "function");\n    assert(typeof d === "function");\n    assert(typeof e === "function");\n    assert(typeof f === "function");\n    assert(typeof g === "function");\n    assert(typeof h === "function");\n    assert(typeof i === "function");\n    assert(typeof j === "function");\n    assert(typeof k === "function");\n    assert(typeof l === "function");\n    assert(typeof m === "function");\n    assert(typeof n === "function");\n    assert(typeof o === "function");\n    assert(typeof p === "function");\n    assert(typeof q === "function");\n    assert(typeof r === "function");\n    assert(typeof s === "function");\n    assert(typeof t === "function");\n    assert(typeof u === "function");\n    assert(typeof v === "function");\n    assert(typeof w === "function");\n    assert(typeof x === "function");\n    assert(typeof y === "function");\n    assert(typeof z === "function");\n});\n\ntest(function() {\n    function outer() { return f; }\n    assert(outer() === undefined);\n    {\n        assert(outer() === undefined);\n        assert(f() === 2);\n        f = 100\n        assert(outer() === undefined);\n        function f() { return 1 }\n        assert(outer() === 100);\n        f = 200\n        assert(outer() === 100); // 100\n        function f() { return 2 }\n        assert(outer() === 200);\n    }\n});\n\nfor (let i = 0; i < 500; i++)\n    assert(foo() === 25);\nfunction foo() { return 20; }\n\n{\n    function foo() { return 25; }\n    assert(foo() === 25);\n}\nassert(foo() === 25);\n\nfor (let i = 0; i < 500; i++)\n    assert(bar() === "bar2");\nfunction bar() { return "bar1"; }\nif (falsey()) {\n    {\n        if (falsey()) {\n            function bar() { return "bar2"; }\n        }\n    }\n}\nassert(bar() === "bar2");\n\nfor (let i = 0; i < 500; i++)\n    assert(baz() === "baz2");\nfunction baz() { return "baz1"; }\nwhile (falsey()) {\n    if (falsey()) {\n        function baz() { return "baz2"; }\n    }\n}\nassert(baz() === "baz2");\n' }
unshiftCountSlowCase-correct-postCapacity.js:SyntaxError: Unexpected token *
//@ if $buildType == "release" && !$memoryLimited then runDefault else skip end

function temp(i) {
    let a1 = [{}];
    a1.foo = 20;
    a1.foo1 = 20;
    a1.foo2 = 20;
    a1.foo3 = 20;
    a1.foo4 = 20;
    a1.foo5 = 20;
    a1.foo6 = 20;
    a1.foo8 = 20;
    a1.foo10 = 20;
    a1.foo11 = 20;
    delete a1[0];
    try {
        let args = [-15, 1, 'foo', 20, 'bar'];
        for (let j = 0; j < i; ++j)
            args.push(j);
        for (let i = 0; i < 2**31 - 1; ++i) {
            Array.prototype.splice.apply(a1, args);
        }
    } catch(e) { }
}
let i = 62;
temp(i);

{ fixed: false,
  messages: 
   [ { ruleId: null,
       fatal: true,
       severity: 2,
       source: '    let a1 = [{}];',
       message: 'Parsing error: Unexpected token a1',
       line: 4,
       column: 9 } ],
  output: '//@ if $buildType == "release" && !$memoryLimited then runDefault else skip end\n\nfunction temp(i) {\n    let a1 = [{}];\n    a1.foo = 20;\n    a1.foo1 = 20;\n    a1.foo2 = 20;\n    a1.foo3 = 20;\n    a1.foo4 = 20;\n    a1.foo5 = 20;\n    a1.foo6 = 20;\n    a1.foo8 = 20;\n    a1.foo10 = 20;\n    a1.foo11 = 20;\n    delete a1[0];\n    try {\n        let args = [-15, 1, \'foo\', 20, \'bar\'];\n        for (let j = 0; j < i; ++j)\n            args.push(j);\n        for (let i = 0; i < 2**31 - 1; ++i) {\n            Array.prototype.splice.apply(a1, args);\n        }\n    } catch(e) { }\n}\nlet i = 62;\ntemp(i);\n' }
