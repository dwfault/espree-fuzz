//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------


function test(o0)
{
    try {
o847 = "Socket already connected";
}catch(e){}
}
var o1 = o4.o9
function o2() { try {
o259[o1090 >> 2];
}catch(e){} }try {
try { {
o641.o665 = o510.o511.link.o494;
} } catch(e) {}try { {} } catch(e) {}
}catch(e){}
try {
Object.defineProperty(o1, "0", { value: 0, writable: false });
}catch(e){}
var o0 = new o2();
try {
o847[o842 | o848++] = o1;
}catch(e){}
try {
test(o0);
}catch(e){}
try {
try { {
write(Boolean(true) >= Number.o5);
} } catch(e) {}
}catch(e){}
function o306(value, o72, o304) {
    try {
if (value <= 0) {
        try {
return value;
}catch(e){}
    }
}catch(e){}
    var o307 = o72 <= 32 ? Math.abs(1 << (o72 - 1)) // abs is needed if bits == 32
        : Math.o305(2, o72 - 1);
    try {
if (value >= o307 && (o72 <= 32 || value > o307)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
        // TODO: In i64 mode 1, resign the two parts separately and safely
        try {
value = -2 * o307 + value;
}catch(e){} // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
    }
}catch(e){}
    try {
return value;
}catch(e){}
};
try {
o0.__proto__ = o1;
}catch(e){}
try {
test(o0);
}catch(e){}
try {
o3.o4(o0[0]);
}catch(e){}
