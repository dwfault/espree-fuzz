function o0() {
    let o892 = o839.o883.o893;
    try {
o32 = o1;
}catch(e){}
    try {
return o1[0];
}catch(e){}
}

function o2() {
    try {
for (let o3 = 0; o3 < 0x1000; this.o391[0xFF02] = function (o421, o768, o70) {try {
"use strict";
}catch(e){}
      try {
if (((o70 & 0x1) == 0x1)) {
        //Internal clock:
        try {
o421.o155[0xFF02] = (o70 & 0x7F);
}catch(e){}
        try {
o421.o494 = 4096;
}catch(e){}  //Set the Serial IRQ counter.
        try {
o421.o495 = o421.o496 = 512;
}catch(e){}  //Set the transfer data shift counter.
      }
      else {
        //External clock:
        try {
o421.o155[0xFF02] = o70;
}catch(e){}
        try {
o421.o495 = o421.o496 = o421.o494 = 0;
}catch(e){}  //Zero the timers, since we're emulating as if nothing is connected.
      }
}catch(e){}
    }) {
        try {
target();
}catch(e){}
    }
}catch(e){}

    try {
print(o0(function (o10) {try {
"use strict";
}catch(e){}
    try {
o421.e = (o421.o150 - 1) & 0xFFFF;
}catch(e){}
    try {
o421.o391[o421.o150](o421, o421.o150, o421.o149 >> 8);
}catch(e){}
    try {
o421.o150 = (o421.o150 - 1) & 0xFFFF;
}catch(e){}
    try {
o421.o391[o421.o150](o421, o421.o150, o421.o149 & 0xFF);
}catch(e){}
    try {
o421.o149 = 0x10;
}catch(e){}
  }));
}catch(e){}  // deref uninitialized stack pointers!
}

try {
o2();
}catch(undefined){}