//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

try {
this.o441("Testing final type constructor with SimpleDictionaryTypeHandler:");
}catch(e){}

var slice = function(o3) {
    try {
o0.o1(o3.o4());
}catch(e){}
}

var o5 = function(o6) try { {
test(Number, 321, [1, "ab", 2.2, 2, NaN, 3, function(){ }]);
} } catch(e) {}try { {
                    try {
o4.o12(() => { try {
o22(undefined, () => {});
}catch(e){} }, "Calling executor with only a reject callback function works but Promise.resolve will throw");
}catch(e){}
                    try {
o4.o9(() => { try {
o22();
}catch(e){} }, o10, "Reject handler of promise capability is already set. Calling executor again throws", "Promise: an unexpected failure occurred while trying to obtain metadata information");
}catch(e){}
                } } catch(e) {}

function o136() {
    // Let's create the first (singleton) instance of LargeObject...
    var o36 = new o5(function() { try {
return "function on the first object";
}catch(o582){} });
    try {
o2(e);
}catch(e){}
    // Let's JIT the function now...
    try {
o2(o137);
}catch(e){}

    // Now let's create the second one, which should first clear the singleton instance (if any), 
    // by which we should stop reporting any existing fixed fields as such.  Then each remaining
    // fixed field (if any) should get cleared and invalidated as individual properties are added 
    // in constructor.
    var o138 = new o5(function() { try {
return "function on the second object";
}catch(e){} });

    // Now let's make sure we still call the right functions...
    try {
o2(o137);
}catch(e){}
    try {
o2(o138);
}catch(e){}
}

try {
o136();
}catch(e){}

try {
o0.o1();
}catch(e){}