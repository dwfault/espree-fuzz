var o6 = o3.toString();
try {
(o295.o367) ? o50 : __defineGetter__;
}catch(e){}

var o1 = o20index]o1("MediaList")] = (o10.o11.o514) ? this.o908 : this.o909(0, 0x100000); // Undecided array

var o3 = 0;
try {
o2.o494 = 4094;
}catch(e){}
try {
o2.fill(o1);
}catch(e){}

var o3 = write(Boolean(true) >= +0.0);
try {
o414 = 0x1000;
}catch(e){}
try {
o3.fill(7);
}catch(e){}

function o306(value, o72, o304) {
    try {
if (value <= 0) {
        try {
return value;
}catch(e){}
    }
}catch(e){}
    var o307 = o72 <= 32 ? Math.abs(1 << (o72 - 1)) // abs is needed if bits == 32
        : Math.o305(2, o72 - 1);
    try {
if (value >= o307 && (o72 <= 32 || value > o307)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
        // TODO: In i64 mode 1, resign the two parts separately and safely
        try {
value = -2 * o307 + value;
}catch(e){} // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
    }
}catch(e){}
    try {
return value;
}catch(e){}
}; //Shorter undecided array

try {
o2[4094] = o4;
}catch(e){}
try {
o2[4095] = o3;
}catch(e){}


try {
o1.concat.apply(o1, o2);
}catch(e){}