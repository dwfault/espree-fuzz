var o3 = Function.write(true >= new Number(NaN));

var o1 = function (o421, o768, o70) {try {
"use strict";
}catch(e){}
  try {
if (o421.o412 < 3) {  //VRAM cannot be written to during mode 3
    try {
if (o421.o155[o768] != o70) {
      //JIT the graphics render queue:
      try {
o421.o873();
}catch(e){}
      try {
o421.o155[o768] = o70;
}catch(e){}
      try {
o421.o828(o768);
}catch(e){}
    }
}catch(e){}
  }
}catch(e){}
};

function o2(){
  var o3 = Intl;
  try {
Object.prototype.o9  = !(function (o421) {try {
"use strict";
}catch(e){}
    try {
o421.o391[o421.o148](o421, o421.o148, o421.o390[o421.o148](o421, o421.o148) | 0x01);
}catch(e){}
  });
}catch(e){} // this somehow prevents an exception that prevents laoding
  try {
o0(o3, "Collator", o1);
}catch(e){}
}

try {
Number.NEGATIVE_INFINITY = o2;
}catch(e){}

var o477.o479 = new function() {
            var o31 = Symbol.for('my string');
            try {
o31 = undefined;
}catch(e){}

            // After cleaning up sym, there shouldn't be anyone pinning the PropertyRecord
            // except for the Symbol registration map.
            // If the reference to the PropertyRecord created above gets cleaned-up we will
            // cause an AV below when we try to reference it again.
            try {
o52();
}catch(e){}

            try {
o31 = Symbol.for('my string');
}catch(e){}

            try {
o4.o11('symbol', typeof o31, "Object returned from Symbol.for is actually a symbol");
}catch(e){}
            try {
o4.o11('Symbol(my string)', o31.toString(), "Symbol returned from Symbol.for has the right description");
}catch(e){}
        }(["en"]);