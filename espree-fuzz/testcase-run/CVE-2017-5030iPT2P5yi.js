var o44 = o34.__proto__;
var o680 = o843 + (o0.o15);

class o2 extends Array {
    static get [o19.prototype.indexOf.species]() {
        try {
return function() { try {
return o0;
}catch(e)try { o175 = 0; } catch(e) {}try { {
            /*var o = {
                0 : 0,
                4294967294 : 2,
                4294967295 : 3,
                4294967296 : 4,
                length : 4294967297
                }//consider property enumeration*/

            var o9 = { length : -1, 4294967294 : 1, 0: 0 };
            try {
Array.prototype.unshift.call(o9, -1);
}catch(e){}
            try {
o6.o7(-1, o9[0], "confirm length does not get converted to 4294967295");
}catch(e){}
            try {
o6.o7(undefined, o9[1], "since length was negative, we can not account for any indicies we over write and so 0 does not shift down");
}catch(e){}
            try {
o6.o7(1, o9["length"], "confirm length does not get converted to 4294967295 and instead is updated after an unshift");
}catch(e){}
            try {
o6.o7(1, o9[4294967294],"length will not account this because we added it when length was invalid");
}catch(e){}

            // Note it is not practical to unshift an object length 4294967295 or larger since we will hit an
            // Out of memory exception before computation ever completes. As a result we will have a test coverage hole,
            // but at the moment it is not a real world scenario.

       } } catch(e) {} }
}catch(e){}
    }; // custom constructor which returns a proxy object
}

var o3 = o4.o11;
try {
arguments[1] = 0.1;
}catch(e){}
try {
o52 = 0.1;
}catch(e){}

function o4() {
    try {
for (var o5 = 0; o5 < 0x100000; ++o4) {
        var o6 = new String();
    }
}catch(e){}
}

function o7() {
    try {
this.o690 = 1;
}catch(e){} // shorten the array so the backstore pointer is relocated
    try {
o4();
}catch(e){}         // force gc to move the array's elements backstore
    try {
return o1;
}catch(e){}
}

try {
Object.prototype.__defineGetter__("defineProperty", o7);
}catch(e){}

var o8 = Array.prototype.concat.call(o3);

try {
for (var o5 = 0; o5 < 20; o5++) { // however many values you want to leak
    try {
o9.o10(o8[o5]);
}catch(e){}
}
}catch(e){}