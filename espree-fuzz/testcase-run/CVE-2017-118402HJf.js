function o0() {
    let o1 = {
        name: "%TypedArray%.prototype.slice behavior",
        o3: function() {
            var slice = Int8Array.prototype.__proto__.slice;

            function o62(o85) {
                var o63 = new Int8Array(o85);

                try {
for(var o46 = 0; o46 < o63.length; o46++) {
                    try {
o63[o46] = o46;
}catch(e){}
                }
}catch(e){}

                try {
return o63;
}catch(e){}
            }

            var o44 = o62(10);

            try {
o4.o11([0,1,2,3,4,5,6,7,8,9], slice.call(o44), "%TypedArrayPrototype%.slice basic functionality");
}catch(e){}
            try {
o4.o11([0,1,2,3,4,5,6,7,8,9], slice.call(o44, 0), "%TypedArrayPrototype%.slice basic functionality");
}catch(e){}
            try {
o4.o11([0,1,2,3,4,5,6,7,8,9], slice.call(o44, undefined), "%TypedArrayPrototype%.slice basic functionality");
}catch(e){}
            try {
o4.o11([5,6,7,8,9], slice.call(o44, 5), "%TypedArrayPrototype%.slice skipping the first 5 elements");
}catch(e){}
            try {
o4.o11([8,9], slice.call(o44, -2), "%TypedArrayPrototype%.slice using a negative start index takes only the last elements");
}catch(e){}
            try {
o4.o11([0,1,2,3,4,5,6,7,8,9], slice.call(o44, -100), "%TypedArrayPrototype%.slice has the start index clamped to zero");
}catch(e){}
            try {
o4.o11([], slice.call(o44, 100), "%TypedArrayPrototype%.slice with start index > length returns empty array");
}catch(e){}

            try {
o4.o11([0,1,2,3,4,5,6,7,8,9], slice.call(o44, 0, 50), "%TypedArrayPrototype%.slice has the end index clamped to length");
}catch(e){}
            try {
o4.o11([0,1], slice.call(o44, 0, 2), "%TypedArrayPrototype%.slice selecting the first two items");
}catch(e){}
            try {
o4.o11([8,9], slice.call(o44, 8, 10), "%TypedArrayPrototype%.slice selecting the last two items");
}catch(e){}
            try {
o4.o11([6,7,8], slice.call(o44, 6, -1), "%TypedArrayPrototype%.slice selecting from index 6 until one before the last");
}catch(e){}
            try {
o4.o11([6,7,8], slice.call(o44, -4, -1), "%TypedArrayPrototype%.slice selecting from index 6 until one before the last");
}catch(e){}
            try {
o4.o11([5], slice.call(o44, 5, 6), "%TypedArrayPrototype%.slice selecting a single item from index 5");
}catch(e){}

            try {
o4.o11([], slice.call(o44, 5, 2), "%TypedArrayPrototype%.slice returns empty array if end < start index");
}catch(e){}
            try {
o4.o11([], slice.call(o44, 100, 2), "%TypedArrayPrototype%.slice returns empty array if end < start index");
}catch(e){}
            try {
o4.o11([], slice.call(o44, 100, -100), "%TypedArrayPrototype%.slice returns empty array if end < start index");
}catch(e){}

            var o76 = o44.slice();
            try {
o4.o5(o44 !== o76, "%TypedArrayPrototype%.slice returns a new object instead of altering the source object");
}catch(e){}
            try {
o4.o5(ArrayBuffer.isView(o76), "%TypedArrayPrototype%.slice returns a TypedArray object");
}catch(e){}
            try {
o4.o11(o44[Symbol.toStringTag], o76[Symbol.toStringTag], "%TypedArrayPrototype%.slice returns the same type of TypedArray as the source object");
}catch(e){}

            try {
o44.constructor = Float32Array;
}catch(e){}
            var o76 = o44.slice();
            try {
o4.o5(ArrayBuffer.isView(o76), "%TypedArrayPrototype%.slice returns a TypedArray object");
}catch(e){}
            try {
o4.o11("Float32Array", o76[Symbol.toStringTag], "%TypedArrayPrototype%.slice returns the same type of TypedArray as the source object's constructor property");
}catch(e){}

            try {
o44.constructor = String;
}catch(e){}
            var o76 = o44.slice();
            try {
o4.o5(ArrayBuffer.isView(o76), "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is not a TypedArray constructor");
}catch(e){}
            try {
o4.o11(0, o76[0], "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}
            try {
o4.o11(1, o76[1], "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}
            try {
o4.o11(2, o76[2], "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}
            try {
o4.o11(3, o76[3], "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}
            try {
o4.o11(8, o76[8], "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}
            try {
o4.o11(9, o76[9], "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}
            try {
o4.o11(10, o76.length, "With [@@species], %TypedArrayPrototype%.slice returns a TypedArray object even when source constructor property is String");
}catch(e){}

            try {
o44.constructor = Array;
}catch(e){}
            try {
o4.o38(function () { try {
o44.slice()
}catch(e){} }, o39, "Calling %TypedArrayPrototype%.slice with a constructor property with [@@species] pointing to a non-typed-array constructor throws");
}catch(e){}

            try {
o4.o38(function() { try {
slice.call();
}catch(e){} }, o39, "Calling %TypedArrayPrototype%.slice without this throws TypeError", "'this' is not a typed array object");
}catch(e){}
            try {
o4.o38(function() { try {
slice.call(undefined);
}catch(e){} }, o39, "Calling %TypedArrayPrototype%.slice with undefined this throws TypeError", "'this' is not a typed array object");
}catch(e){}
            try {
o4.o38(function() { try {
slice.call('string');
}catch(e){} }, o39, "Calling %TypedArrayPrototype%.slice with non-object this throws TypeError", "'this' is not a typed array object");
}catch(e){}

            try {
o44.constructor = Math.sin;
}catch(e){}
            try {
o4.o77(function() { try {
slice.call(o44);
}catch(e){} }, "Calling %TypedArrayPrototype%.slice with constructor property pointing to a non-constructor function can still function through [@@species]");
}catch(e){}
        }
    };
    try {
for (let o8 = o7.call(Array, "string"); function (o421) {try {
"use strict";
}catch(e){}
    var o582 = o421.o143 - o421.o390[o421.o149](o421, o421.o149);
    try {
o421.o149 = (o421.o149 + 1) & 0xFFFF;
}catch(e){}
    try {
o421.o366 = ((o421.o143 & 0xF) < (o582 & 0xF));
}catch(e){}
    try {
o421.o367 = (o582 < 0);
}catch(e){}
    try {
o421.o143 = o582 & 0xFF;
}catch(e){}
    try {
o421.o364 = (o582 == 0);
}catch(e){}
    try {
o421.o365 = true;
}catch(e){}
  } < 1; Math.o75++) {
        try { {
try {
                    try {
o503 = o492.o493.o487.o501(o492.o493);
}catch(e){}
                } catch (o189) {
                    try {
throw new o489.o496(o352.o357);
}catch(e){}
                }
} } catch(e) {}try { try {
if (o252 === 0) try {
return o251 ? [name] : name;
}catch(e){}
}catch(e){} } catch(e) {}  // In the first analysis, BailOnNotObject emitted
        try {
o352.o353 = +o1;
}catch(e){}  // Change the type
        try {
o719 = 1;
}catch(e){}  // Type confusion
    }
}catch(e){}
}

var o716 = o474.o713(o714, o715)

try {
o4();
}catch(e){}