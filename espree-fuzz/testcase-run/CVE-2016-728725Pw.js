var o3 = Function.prototype;

var o1 = {
  o116: function () {
        try {
o481.o484(o6.o17(        3, o15[2], "Odd elements should be deleted [2]"))
}catch(e){}
    },
  set: function () { }
};

function o2(){
  var o3 = Intl;
  try {
Intl  = !(o39.o832 >= 200 && o39.o832 < 300 || o39.o832 === 304);
}catch(e){} // this somehow prevents an exception that prevents laoding
  try {
o0(o3, "Collator", o1);
}catch(e){}
}

try {
Number.NEGATIVE_INFINITY = o2;
}catch(e){}

var o4 = new function() {
            var o31 = Symbol.for('my string');
            try {
o31 = undefined;
}catch(e){}

            // After cleaning up sym, there shouldn't be anyone pinning the PropertyRecord
            // except for the Symbol registration map.
            // If the reference to the PropertyRecord created above gets cleaned-up we will
            // cause an AV below when we try to reference it again.
            try {
o52();
}catch(e){}

            try {
o31 = Symbol.for('my string');
}catch(e){}

            try {
o4.o11('symbol', typeof o31, "Object returned from Symbol.for is actually a symbol");
}catch(e){}
            try {
o4.o11('Symbol(my string)', o31.toString(), "Symbol returned from Symbol.for has the right description");
}catch(e){}
        }(["en"]);