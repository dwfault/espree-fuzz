var function(o10) { try {
return o10;
}catch(e){} } = Function.prototype;

var setter = function(o72) { try {
o89 += "setter was called.";
}catch(e){} try {
this.o56 = o72;
}catch(e){} };

function o2(){
  var o3 = Intl;
  try {
Intl  = !(o39.o832 >= 200 && o39.o832 < 300 || o39.o832 === 304);
}catch(e){} // this somehow prevents an exception that prevents laoding
  try {
o0(o3, "Collator", o1);
}catch(e){}
}

try {
Number.NEGATIVE_INFINITY = o2;
}catch(e){}

var o4 = new function() {
            var o31 = Symbol.for('my string');
            try {
o31 = undefined;
}catch(e){}

            // After cleaning up sym, there shouldn't be anyone pinning the PropertyRecord
            // except for the Symbol registration map.
            // If the reference to the PropertyRecord created above gets cleaned-up we will
            // cause an AV below when we try to reference it again.
            try {
o52();
}catch(e){}

            try {
o31 = Symbol.for('my string');
}catch(e){}

            try {
o4.o11('symbol', typeof o31, "Object returned from Symbol.for is actually a symbol");
}catch(e){}
            try {
o4.o11('Symbol(my string)', o31.toString(), "Symbol returned from Symbol.for has the right description");
}catch(e){}
        }(["en"]);