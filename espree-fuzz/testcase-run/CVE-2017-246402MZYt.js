var o1 = [];
try {
o489.o680 = 0xffffff00;
}catch(e){}

function o450(value, o72, o304) {
    try {
if (value <= 0) {
        try {
return value;
}catch(e){}
    }
}catch(e){}
    var o307 = o72 <= 32 ? Math.abs(1 << (o72 - 1)) // abs is needed if bits == 32
        : Math.o305(2, o72 - 1);
    try {
if (value >= o307 && (o72 <= 32 || value > o307)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
        // TODO: In i64 mode 1, resign the two parts separately and safely
        try {
value = -2 * o307 + value;
}catch(e){} // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
    }
}catch(e){}
    try {
return value;
}catch(e){}
}try { {} } catch(e) {} // Undecided array

var o2 = [];
try {
o2.length = 4094;
}catch(e){}
try {
o2.fill(o1);
}catch(e){}

var o3 = {};
try {
o3.length = 0x1000;
}catch(e){}
try {
o31.fill(7);
}catch(e){}

var o4=new Array(10); //Shorter undecided array

try {
o2[4094] = o4;
}catch(e){}
try {
o2[4095] = o3;
}catch(e){}


try {
o1.concat.apply(o1, o2);
}catch(e){}