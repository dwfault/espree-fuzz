var o0 = o494.o539(1, 2, 3, name);
try {
o0.toLocaleString(1, 2, function () {try {
"use strict";
}catch(o299){}
  //Iterate the interpreter loop:
  var o30 = 0;
  var o773 = 0;
  try {
while (o259[o227 + 4 >> 2] & -8 | 0) {
    //Interrupt Arming:
    try {
switch (this.o497) {
      case 1:
        try {
this.o381 = true;
}catch(e){}
        try {
this.o664();
}catch(e){}
      case 2:
        try {
--this.o497;
}catch(e){}
    }
}catch(e){}
    //Is an IRQ set to fire?:
    try {
if (this.o382 > 0) {
      //IME is true and and interrupt was matched:
      try {
this.o774();
}catch(e){}
    }
}catch(e){}
    //Fetch the current opcode:
    try {
o772 = this.o390[this.o149](this, this.o149);
}catch(e){}
    //Increment the program counter to the next instruction:
    try {
this.o149 = (this.o149 + 1) & 0xFFFF;
}catch(e){}
    //Check for the program counter quirk:
    try {
if (this.o379) {
      try {
this.o149 = (this.o149 - 1) & 0xFFFF;
}catch(e){}
      try {
this.o379 = false;
}catch(e){}
    }
}catch(e){}
    //Get how many CPU cycles the current instruction counts for:
    try {
this.o386 = this.o599[o772];
}catch(e){}
    //Execute the current instruction:
    try {
this.o578[o772](this);
}catch(e){}
    //Update the state (Inlined updateCoreFull manually here):
    //Update the clocking for the LCD emulation:
    try {
this.o490 += this.o386 >> this.o387;
}catch(e){}  //LCD Timing
    try {
this.o422[this.o502](this);
}catch(e){}          //Scan Line and STAT Mode Control
    //Single-speed relative timing for A/V emulation:
    try {
o773 = this.o386 >> this.o387;
}catch(e){}    //CPU clocking can be updated from the LCD handling.
    try {
this.o485 += o773;
}catch(e){}                //Audio Timing
    try {
this.o488 += o773;
}catch(e){}              //Emulator Timing
    //CPU Timers:
    try {
this.o489 += this.o386;
}catch(e){}                //DIV Timing
    try {
if (this.o492) {                    //TIMA Timing
      try {
this.o491 += this.o386;
}catch(e){}
      try {
while (this.o491 >= this.o493) {
        try {
this.o491 -= this.o493;
}catch(e){}
        try {
if (++this.o155[0xFF05] == 0x100) {
          try {
this.o155[0xFF05] = this.o155[0xFF06];
}catch(e){}
          try {
this.o383 |= 0x4;
}catch(e){}
          try {
this.o664();
}catch(e){}
        }
}catch(e){}
      }
}catch(e){}
    }
}catch(e){}
    try {
if (this.o494 > 0) {                    //Serial Timing
      //IRQ Counter:
      try {
this.o494 -= this.o386;
}catch(e){}
      try {
if (this.o494 <= 0) {
        try {
this.o383 |= 0x8;
}catch(e){}
        try {
this.o664();
}catch(e){}
      }
}catch(e){}
      //Bit Shit Counter:
      try {
this.o495 -= this.o386;
}catch(e){}
      try {
if (this.o495 <= 0) {
        try {
this.o495 = this.o496;
}catch(e){}
        try {
this.o155[0xFF01] = ((this.o155[0xFF01] << 1) & 0xFE) | 0x01;
}catch(e){}  //We could shift in actual link data here if we were to implement such!!!
      }
}catch(e){}
    }
}catch(e){}
    //End of iteration routine:
    try {
if (this.o488 >= this.o369) {
      try {
this.o775();
}catch(e){}
    }
}catch(e){}
    // Start of code added for benchmarking:
    try {
this.o91 += 1;
}catch(e){}
    try {
if (this.o91 > this.o92) {
      try {
this.o775();
}catch(e){}
      try {
this.o380 |= 2;
}catch(e){}
      try {
o140();
}catch(e){}
    }
}catch(e){}
    // End of code added for benchmarking.
  }
}catch(e){}
}, 4)
}catch(e){}