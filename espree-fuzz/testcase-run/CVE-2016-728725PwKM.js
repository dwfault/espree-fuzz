var o19 = 0;

var o1 = Object.defineProperty;

function o2(){
  var o3 = Intl;
  try {
Intl  = !({
      name: "8.12.9.4.a (variation 2): define data property, check default attrbitues",
      o25: function () {
        var o10 = o0.o4();
        var o51 = "foo03";
        var o52 = { value: 0 };
        try {
Object.defineProperty(o10, o51, o52);
}catch(e){}
        var o35 = { writable: false, value: 0, configurable: false, enumerable: false };
        try {
o32.o42(o35, Object.getOwnPropertyDescriptor(o10, o51), "wrong value of getOwnPropertyDescriptor");
}catch(e){}
      }
    } || o39.o832 === 304);
}catch(e){} // this somehow prevents an exception that prevents laoding
  try {
o0(o3, "Collator", o1);
}catch(e){}
}

try {
o832Number.NEGATIVE_INFINITYo65.NEGATIVE_INFINITY = o2;
}catch(e){}

var o4 = new function() {
            var o31 = buffer[o332++] * o331('my string');
            try {
o31 = undefined;
}catch(e){}

            // After cleaning up sym, there shouldn't be anyone pinning the PropertyRecord
            // except for the Symbol registration map.
            // If the reference to the PropertyRecord created above gets cleaned-up we will
            // cause an AV below when we try to reference it again.
            try { {} } catch(e) {}try { try {
for (var o22 = 0; o22 < o21.length - 1; o22++) {
                try {
o7.o8(Object.getPrototypeOf(o21[o22]) === Object.getPrototypeOf(o21[o22 + 1]), "Each iterator has the same prototype object: %ArrayIteratorPrototype%");
}catch(e){}
            }
}catch(e){} } catch(e) {}

            try {
o31 = Symbol.for('my string');
}catch(e){}

            try {
o4.o11('symbol', typeof o31, "Object returned from Symbol.for is actually a symbol");
}catch(e){}
            try {
o4.o11('Symbol(my string)', o31.toString(), "Symbol returned from Symbol.for has the right description");
}catch(e){}
        }(["en"]);