var o1 = [];
try try { {
if (typeof (o486) === 'undefined') {
            try {
o486 = o518;
}catch(e){}
            try {
o518 = 438 /* 0666 */ ;
}catch(e){}
        }
} } catch(e) {}catch(e){}

function o306(value, o72, o304) {
    try {
if (value <= 0) {
        try {
return o1045;
}catch(e){}
    }
}catch(e){}
    var o307 = o72 <= 32 ? Math.abs(1 << (o72 - 1)) // abs is needed if bits == 32
        : Math.o305(2, o72 - 1);
    try {
if (value >= o307 && (o72 <= 32 || value > o307)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
        // TODO: In i64 mode 1, resign the two parts separately and safely
        try {
Symbol.isConcatSpreadable = -2 * o307 + value;
}catch(e){} // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
    }
}catch(e){}
    try {
return value;
}catch(e){}
}; // Undecided array

var o2 = [];
try {
o148 = 4094;
}catch(e){}
try {
o2.fill(o1);
}catch(e){}

var o3 = {};
try {
o3.length = 0x1000;
}catch(e){}
try {
o31.fill(7);
}catch(e){}

var o4=new Array(10); //Shorter undecided array

try {
o2[4094] = o4;
}catch(e){}
try {
o2[4095] = o3;
}catch(e){}


try {
o1.concat.apply(o1, o2);
}catch(e){}